<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
<title>Kotlin (for Scala developers)</title>
<meta name="description" content="A fast Kotlin primer for people who already know Java and Scala">
<meta name="author" content="Danilo Pianini">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/dist/reset.css">
<link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/dist/reveal.css">
  <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/css/custom-theme.min.f528c44ce51b86b314f7a0ebdd69b3768ef13692993c5c88aa6ec4e2e061ef67.css" id="theme"><link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/highlight-js/default.min.css">
    
<link rel="stylesheet" href="https://gitcdn.link/repo/DanySK/css-blur-animation/master/blur.css">
<link href="https://fonts.googleapis.com/css?family=Roboto Mono" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Oxygen Mono" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu Mono" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">

  </head>
  <body>
    
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="kotlin">Kotlin</h1>
<h2 id="for-scala-developers"><em>(for Scala developers)</em></h2>
<h2 id="hahahugoshortcode-s0-hbhb">Laboratory of Software Systems</h2>
<br>
<h3 id="danilo-pianini-----danilopianiniuniboitmailtodanilopianiniuniboit"><a href="mailto:danilo.pianini@unibo.it">Danilo Pianini ‚Äî <code>danilo.pianini@unibo.it</code></a></h3>
<br>
<p>Compiled on: 2023-01-02
 ‚Äî <a href="?print-pdf&amp;pdfSeparateFragments=false"><i class="fa fa-print" aria-hidden="true"></i> printable version</a></p>
<p><a href=".."><i class="fa fa-undo" aria-hidden="true"></i> back</a></p>
</section><section>
<h1 id="why-kotlin">Why Kotlin</h1>
<p>JetBrains-made modern programming language</p>
<ul>
<li>Focused on ‚Äúpractical use‚Äù (whatever that means)</li>
</ul>
<p>Gaining momentum since Google adopted is as <em>official Android language</em>
<br>
(along with Java and C++)</p>
<p>Clearly inspired by a mixture of Java, C#, Scala, and Groovy</p>
<p><strong>In this course</strong> ‚Äì we‚Äôll need it for Gradle and <em>internal</em> domain specific languages</p>
</section><section>
<h2 id="philosophy-kotlin-vs-scala">Philosophy: Kotlin vs. Scala</h2>
<p><strong>Sca</strong><em>la</em> is a <strong>scalable</strong> <em>language</em></p>
<ul>
<li>Few core constructs that enable a huge variety of programming patterns</li>
<li>Born in academia, adopted by some industries</li>
<li>State of the art type checker with advanced features
<ul>
<li>Higher Kinded Types</li>
<li>Type lambdas</li>
<li>macros</li>
</ul>
</li>
</ul>
<p><strong>Kotlin</strong> is somewhat <em>a better java</em></p>
<ul>
<li>Born in industry, for the industry</li>
<li>Many more ‚Äúcore‚Äù constructs and keywords than Scala</li>
<li>Focused on getting productive quickly and reducing programming errors</li>
<li>Focus on multi-target (can compile towards JVM, JavaScript, and native)
<ul>
<li>Scala can as well by the way</li>
<li>Kotlin puts more care into bidirectional compatibility</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101">Kotlin 101</h1>
<h2 id="defining-functions-constant-variables">Defining functions, constant, variables</h2>
<p>Similar to Scala. The keyword <code>def</code> is replaced by <code>fun</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">x</span> = <span style="color:#00d;font-weight:bold">10</span> <span style="color:#888">// constant
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">y</span> = <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// variable, can be reassigned
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// function definition, single expression
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">bar</span>(): Int { <span style="color:#888">// same as above with multiple expression
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// requires a return in this form...
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baz</span>() { } <span style="color:#888">// Unless it returns Unit
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-1">Kotlin 101</h1>
<h2 id="function-parameters-and-return-types">Function parameters and return types</h2>
<p>Much like Scala:</p>
<ul>
<li>All parameters are named, but can be invoked positionally as well</li>
<li>Parameters can have defaults</li>
<li>Types are annotated after the parameter name</li>
<li>Invocation can be positional or by name, with the rule that once a named parameter is used, subsequent parameters must be named as well</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>(a: Int = <span style="color:#00d;font-weight:bold">0</span>, b: String = <span style="color:#d20;background-color:#fff0f0">"foo"</span>): Int = TODO()
</span></span><span style="display:flex;"><span><span style="color:#888">// TODO() is a builtin function throwing a `NotImplementedError`
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#d20;background-color:#fff0f0">"bar"</span>) <span style="color:#888">// OK, positional
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(a = <span style="color:#00d;font-weight:bold">1</span>, b = <span style="color:#d20;background-color:#fff0f0">"bar"</span>) <span style="color:#888">// OK, named
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>, b = <span style="color:#d20;background-color:#fff0f0">"bar"</span>) <span style="color:#888">// OK, hybrid
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(a = <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#d20;background-color:#fff0f0">"bar"</span>) <span style="color:#888">// error: no value passed for parameter 'b'
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo() <span style="color:#888">// OK, both defaults
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#888">// OK, same as foo(1, "foo")
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(<span style="color:#d20;background-color:#fff0f0">"bar"</span>) <span style="color:#888">// error: type mismatch: inferred type is String but Int was expected
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo(b = <span style="color:#d20;background-color:#fff0f0">"bar"</span>) <span style="color:#888">// OK, same as foo(0, "bar")
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-2">Kotlin 101</h1>
<h2 id="top-level-functions">Top level functions</h2>
<p>Similar to Scala 3 (unsupported in Scala 2)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">def</span> foo() {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When targeting the JVM, Kotlin simply generates a <code>FileNameKt</code> class behind the scenes where the function is stored.
The behaviour can be controlled via annotations.</p>
</section><section>
<h1 id="kotlin-101-3">Kotlin 101</h1>
<h2 id="program-entry-point">Program entry point</h2>
<p>Naming a function <code>main</code> makes it a valid entry point:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>() = println(<span style="color:#d20;background-color:#fff0f0">"Hello World"</span>) <span style="color:#888">// Valid entry point
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>(arguments: Array&lt;String&gt;) = println(<span style="color:#d20;background-color:#fff0f0">"Hello World"</span>) <span style="color:#888">// Valid entry point
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>(arguments: Array&lt;String&gt;) {
</span></span><span style="display:flex;"><span>    println(<span style="color:#d20;background-color:#fff0f0">"Hello World"</span>) <span style="color:#888">// Return type is Unit, no need to return
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>} 
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101-4">Kotlin 101</h1>
<h2 id="nullable-types">Nullable types</h2>
<p>Every Kotlin type exists in two forms: normal, and nullable (likely inspired by Ceylon).
<br>
Nullable types are suffixed by a <code>?</code> and require special handling
<br>
<code>null</code> can‚Äôt be assigned to non nullable types!</p>
<ul>
<li>Nullables are the Kotlin way to deal with <code>Option</code> types</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">foo</span> = <span style="color:#d20;background-color:#fff0f0">"bar"</span> <span style="color:#888">// Okay, type is String
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = foo <span style="color:#888">// Okay, normal types can be assigned to nullables
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo = baz <span style="color:#888">// error: type mismatch: inferred type is String? but String was expected
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>foo = <span style="color:#080;font-weight:bold">null</span> <span style="color:#888">// error: null can not be a value of a non-null type String
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-5">Kotlin 101</h1>
<h2 id="accessing-nullable-types">Accessing nullable types</h2>
<p>Nullable types memebers can‚Äôt be accessed by <code>.</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">"foo"</span>
</span></span><span style="display:flex;"><span>baz.length <span style="color:#888">// error: only safe (?.) or non-null asserted (!!.) calls are allowed...
</span></span></span><span style="display:flex;"><span><span style="color:#888">// on a nullable receiver of type String?
</span></span></span></code></pre></div><h3 id="safe-call-operator-">Safe call operator <code>?.</code></h3>
<p>Performs runtime access to a member of a nullable object if it‚Äôs not <code>null</code>, otherwise returns <code>null</code></p>
<ul>
<li>Somewhat similar to Scala‚Äôs <code>Option</code>‚Äôs <code>map</code> (but no monad involved)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">"foo"</span>
</span></span><span style="display:flex;"><span>baz?.length <span style="color:#888">// returns 3, return type is "Int?", in fact...
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: Int = baz?.length <span style="color:#888">// type mismatch: inferred type is Int? but Int was expected
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>baz = <span style="color:#080;font-weight:bold">null</span>
</span></span><span style="display:flex;"><span>baz?.length <span style="color:#888">// returns null, return type is still "Int?"
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-6">Kotlin 101</h1>
<h3 id="non-null-assertion-">Non-null assertion <code>!!</code></h3>
<p>Also known as: <em>I want my code to break badly at runtime</em>
<br></p>
<ul>
<li>Invalidates the whole point of having nullable types by asserting that the nullable object is not <code>null</code> at runtime</li>
<li>It should be <strong>never</strong> used
<ul>
<li>In fact its ugly syntax is so <em>ugly by purpose</em></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">"foo"</span>
</span></span><span style="display:flex;"><span>baz!!<span class="fragment " style="color: #888;"> // Returns 'foo', type String (non nullable)</span>
</span></span><span style="display:flex;"><span>baz!!.length<span class="fragment " style="color: #888;"> // returns 3, return type is Int</span>
</span></span><span style="display:flex;"><span>baz = <span style="color:#080;font-weight:bold">null</span>
</span></span><span style="display:flex;"><span>baz!!<span class="fragment " style="color: #888;"> // throws a KotlinNullPointerException, like the good ol'times!</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101-7">Kotlin 101</h1>
<h3 id="elvis-operator-">Elvis operator <code>?:</code></h3>
<p>Yeah it‚Äôs actually named after Elvis Presley due to his haircut üòâ
<br></p>
<ul>
<li>Returns the left operand if it‚Äôs not <code>null</code>, otherwise the right one</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">"foo"</span>
</span></span><span style="display:flex;"><span>baz ?: <span style="color:#d20;background-color:#fff0f0">"bar"</span> <span style="color:#888">// Returns "foo", type String
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// returns 3, return type is Int
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>baz = <span style="color:#080;font-weight:bold">null</span>
</span></span><span style="display:flex;"><span>baz ?: <span style="color:#d20;background-color:#fff0f0">"bar"</span> <span style="color:#888">// Returns "bar", type String
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// returns 0, return type is Int
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-8">Kotlin 101</h1>
<h2 id="platform-types">Platform types</h2>
<p>Kotlin targets the JVM, JavaScript, and native code
<br>
<em>None of them has nullable types!</em></p>
<p>Nullability is unknown for types coming from the target platform, how to deal with them?</p>
<ol>
<li><span class="fragment ">Always consider them nullable (safe, but very unpleasant)</span></li>
<li><span class="fragment ">Always consider them non nullable (code is lightweight and nice, but unsafe)</span></li>
</ol>
</section><section>
<h1 id="kotlin-101-9">Kotlin 101</h1>
<h2 id="platform-types-1">Platform types</h2>
<p>Kotlin considers all foreign values whose nullability is unknown as <em>platform types</em></p>
<ul>
<li>Their type is suffixed by <code>!</code> (e.g., <code>java.util.Date!</code>)</li>
<li>At first use, their type is <em>implicitly disambiguated</em> (either nullable or non-nullable)
<ul>
<li>Namely, platform types can be used as non-nullable‚Ä¶</li>
</ul>
</li>
<li>Runtime nullability checks are put in place by the compiler (<em>fail fast!</em>)
<ul>
<li>‚Ä¶but their actual nullablity is checked at use-site</li>
</ul>
</li>
<li>Platform types <em>can‚Äôt be created</em> in Kotlin! They only come from interaction with ‚Äúplatform code‚Äù</li>
<li>If the target platform offers some way to assert nullability, Kotlin tries to use it
<ul>
<li>e.g., if a Java method/parameter is annotated with <code>@NotNull</code> (or similar common alternatives) it will be interpreted as a non-nullable type</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-10">Kotlin 101</h1>
<h2 id="type-hierarchy">Type hierarchy</h2>
<ul>
<li>In Java
<ul>
<li>top type: <code>Object</code></li>
<li>bottom type: no bottom type</li>
</ul>
</li>
<li>In Scala
<ul>
<li>top type: <code>Any</code></li>
<li>bottom type: <code>Nothing</code></li>
</ul>
</li>
<li>In Kotlin:
<ul>
<li>top type: <code><span class="fragment ">Any</span></code></li>
<li>bottom type:</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-11">Kotlin 101</h1>
<h2 id="type-hierarchy-1">Type hierarchy</h2>
<ul>
<li>In Java
<ul>
<li>top type: <code>Object</code></li>
<li>bottom type: no bottom type</li>
</ul>
</li>
<li>In Scala
<ul>
<li>top type: <code>Any</code></li>
<li>bottom type: <code>Nothing</code></li>
</ul>
</li>
<li>In Kotlin:
<ul>
<li>top type: <del><code>Any</code></del> <code><span class="fragment ">Any?</span></code></li>
<li>bottom type: <code><span class="fragment ">Nothing</span></code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-12">Kotlin 101</h1>
<h2 id="booleans"><code>Boolean</code>s</h2>
<p>Exactly as Java/Scala, but with nullability:</p>
<ul>
<li><code>Boolean</code>: <code>true</code>/<code>false</code></li>
<li><code>Boolean?</code>: <code>true</code>/<code>false</code>/<code>null</code></li>
<li><code>&amp;&amp;</code>, <code>!!</code>, and <code>!</code> operators work for <em>non-nullable</em> <code>Boolean</code>s.</li>
</ul>
<p>Likewise Scala, boxing under the JVM is dealt with by the compiler
<br>
<code>Boolean?</code> are always boxed (to be able to account for <code>null</code>)</p>
</section><section>
<h1 id="kotlin-101-13">Kotlin 101</h1>
<h2 id="numeric-types">Numeric types</h2>
<p>Same as Scala, +nullability, +<em>unsigned experimental types</em>:</p>
<ul>
<li><code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>
<ul>
<li>And nullable equivalents, always boxed under the JVM</li>
</ul>
</li>
<li><code>UByte</code>, <code>UShort</code>, <code>UInt</code>, <code>ULong</code></li>
</ul>
</section><section>
<h1 id="kotlin-101-14">Kotlin 101</h1>
<h2 id="issues-of-implicit-numeric-types-conversion">Issues of implicit numeric types conversion</h2>
<p>Implicit type conversion to ‚Äúbigger‚Äù types is source of nasty errors when automatic boxing is involved.
<br>
Consider the following Scala code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> == <span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span>
</span></span></code></pre></div>

<span class="fragment ">
  <p><code>false</code>, OK, as every sane language</p>

</span>



<span class="fragment ">
  <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> equals <span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span>
</span></span></code></pre></div>
</span>



<span class="fragment ">
  <p><code>true</code>! Boxing + Singleton make equality inconsistent!</p>

</span>



<span class="fragment ">
  <div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> a<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Int</span> = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> b<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Long</span> = a
</span></span><span style="display:flex;"><span>a == b <span style="color:#888">// true
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>a equals b <span style="color:#888">// false
</span></span></span></code></pre></div><p>This causes a chain of issues, as <code>==</code> and <code>equals</code> do a different job, as do <code>##</code> and <code>hashCode</code>: <code>Map</code>s can become very surprising!</p>

</span>

</section><section>
<h1 id="kotlin-101-15">Kotlin 101</h1>
<h2 id="numeric-type-conversions-in-kotlin">Numeric type conversions in Kotlin</h2>
<p>Kotlin numeric types are converted manually to prevent these issues:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">i</span>: Int = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = i<span class="fragment " style="color: #888;"> // error: type mismatch: inferred type is Int but Long was expected</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = i.toLong()<span class="fragment " style="color: #888;"> // OK</span>
</span></span><span style="display:flex;"><span>i + l<span class="fragment " style="color: #888;"> // OK, operators are overloaded</span>
</span></span><span style="display:flex;"><span>l + i<span class="fragment " style="color: #888;"> // OK, operators are overloaded</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101-16">Kotlin 101</h1>
<h2 id="numeric-literals">Numeric literals</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1234567</span> <span style="color:#888">// Literal Int
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1</span>_234_567 <span style="color:#888">// Literal Int, underscored syntax (preferable)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">123L</span> <span style="color:#888">// Literal Long
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1.0</span> <span style="color:#888">// Literal Double
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">123</span>e4 <span style="color:#888">// Literal Double in scientific notation
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1</span>d <span style="color:#888">// Nope :)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1f</span> <span style="color:#888">// Literal Float
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1u</span> <span style="color:#888">// Literal UInt
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0123</span> <span style="color:#888">// error: unsupported [literal prefixes and suffixes] (no octal)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xCAFE</span> <span style="color:#888">// Hex literal Int
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xCAFEBABE</span> <span style="color:#888">// Hex literal Long (automatic, as it does not fit an Int)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0x0000000</span> <span style="color:#888">// Hex literal Int, even it'd fit a Byte
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b1111111_11111111_11111111_11111111 <span style="color:#888">// Binary Int (Integer.MAX_INT)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b11111111_11111111_11111111_11111111 <span style="color:#888">// Binary Long
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b11111111_11111111_11111111_11111111u <span style="color:#888">// Binary UInt!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xFFFF</span>_FFFF_FFFFu <span style="color:#888">// ULong
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-17">Kotlin 101</h1>
<h2 id="strings-and-templating">Strings and templating</h2>
<p>Spiced up version of Java strings, Groovy-style templating:</p>
<ul>
<li><code>$</code> begins a template expression</li>
<li>Curly brackets must be used to disambiguate in case of calls inside the template: <code>${}</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">batman</span> = <span style="color:#d20;background-color:#fff0f0">"Batman"</span>
</span></span><span style="display:flex;"><span><span style="color:#888">// Groovy templating and Java-style concatenation both work
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${Double.NaN}</span><span style="color:#d20;background-color:#fff0f0">"</span>.repeat(<span style="color:#00d;font-weight:bold">10</span>) + <span style="color:#d20;background-color:#fff0f0">" </span><span style="color:#33b;background-color:#fff0f0">$batman</span><span style="color:#d20;background-color:#fff0f0">!"</span><span class="fragment " style="color: #888;"> // NaNNaNNaNNaNNaNNaNNaNNaNNaNaN Batman!</span>
</span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">"Batman is </span><span style="color:#33b;background-color:#fff0f0">$batman</span><span style="color:#d20;background-color:#fff0f0">.length characters long"</span><span class="fragment " style="color: #888;"> // Batman is Batman.length characters long</span>
</span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">"Batman is </span><span style="color:#33b;background-color:#fff0f0">${batman.length}</span><span style="color:#d20;background-color:#fff0f0"> characters long"</span><span class="fragment " style="color: #888;"> // Batman is 6 characters long</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101-18">Kotlin 101</h1>
<h2 id="raw-strings">Raw Strings</h2>
<p>Triple-double-quoted strings are considered <em>raw strings</em></p>
<ul>
<li><code>\</code> is a normal character</li>
<li>newlines are intended as part of the string</li>
<li>Very handy for writing regular expressions</li>
<li><code>$</code>-templating still works
<ul>
<li>writing a dollar symbols requires some tricks</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">dante</span> = <span style="color:#d20;background-color:#fff0f0">"""
</span></span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">    Tanto gentile e tanto onesta pare
</span></span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">    la donna mia quand'ella altrui saluta,
</span></span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">    ch'ogne lingua dev√®n, tremando, muta
</span></span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">    e li occhi non l'ardiscon di guardare.
</span></span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">    """</span>.trimIndent() <span style="color:#888">// Indentation can be trimmed
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">finalWordsEndingInA</span> = <span style="color:#d20;background-color:#fff0f0">"""\W*(\w*a)\W*</span><span style="color:#33b;background-color:#fff0f0">${'$'}</span><span style="color:#d20;background-color:#fff0f0">"""</span>.toRegex(<span style="color:#b06;font-weight:bold">RegexOption</span>.MULTILINE) <span style="color:#888">// '$' escaped
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>finalWordsEndingInA.findAll(dante).map { <span style="color:#080;font-weight:bold">it</span>.groups[<span style="color:#00d;font-weight:bold">1</span>]?.<span style="color:#080;font-weight:bold">value</span> }.toList() <span class="fragment " style="color: #888;"> // [saluta, muta]</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101-19">Kotlin 101</h1>
<h2 id="packages-and-imports">Packages and imports</h2>
<p>Same as Java, plus aliasing.
<br>
Imports go at the top of file, no locally scoped imports as in Scala</p>
<ul>
<li>There are no <code>implicit</code>s in Kotlin, the <code>import</code> statement does not modify context</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">package</span> <span style="color:#b06;font-weight:bold">it.unibo.lss.experiments</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">it.unibo.lss.ddd.Entity</span> <span style="color:#888">// Available as Entity locally
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.company.someproduct.Entity</span> <span style="color:#080;font-weight:bold">as</span> SomeProductEntity <span style="color:#888">// name aliasing
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-101-20">Kotlin 101</h1>
<h2 id="varargs">Varargs</h2>
<p>Functions can have a parameter marked as <code>vararg</code>, accepting multiple entries</p>
<ul>
<li>Typically the last one (but not mandatorily as in Java)</li>
<li>Maps to an <code>Array&lt;out T&gt;</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">printall</span>(<span style="color:#080;font-weight:bold">vararg</span> strings: String) {
</span></span><span style="display:flex;"><span>    strings.forEach { println(<span style="color:#080;font-weight:bold">it</span>) } <span style="color:#888">// We'll discuss this syntax later...
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span><span style="display:flex;"><span>printall(<span style="color:#d20;background-color:#fff0f0">"Lorem"</span>, <span style="color:#d20;background-color:#fff0f0">"ipsum"</span>, <span style="color:#d20;background-color:#fff0f0">"dolor"</span>, <span style="color:#d20;background-color:#fff0f0">"sit"</span>, <span style="color:#d20;background-color:#fff0f0">"amet"</span>)
</span></span></code></pre></div></section><section>
<h2 id="kotlin-101-21">Kotlin 101</h2>
<h3 id="naming-in-kotlin">Naming in Kotlin</h3>
<p>Kotlin is less permissive than Scala:</p>
<ul>
<li>Arbitrary symbols are not accepted as valid function names</li>
<li>‚Ä¶unless you explicitly surround them with backtics</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">def</span> ##<span style="color:#a61717;background-color:#e3d2d2">¬∞</span>@??%&amp;@^^() <span style="color:#080;font-weight:bold">=</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// Super ok for Scala: def $hash$hash$u00B0$at$qmark$qmark$percent$amp$at$up$up(): Int
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">`##¬∞@??%&amp;@^^`</span>() = <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#a61717;background-color:#e3d2d2">`##¬∞@</span>??%&amp;<span style="color:#a61717;background-color:#e3d2d2">@</span>^^<span style="color:#a61717;background-color:#e3d2d2">`</span>() <span style="color:#888">// 1. Must be invoked with backticks!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`val`</span> = <span style="color:#d20;background-color:#fff0f0">"Hey look I can name things with keywords!"</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`names can also contain spaces`</span> = <span style="color:#00d;font-weight:bold">1</span>
</span></span></code></pre></div><ul>
<li>General rule: <strong>avoid it</strong></li>
<li>It might be needed for interoperability with other languages, e.g. if a Java field is named <code>val</code></li>
<li>Tolerated in tests with Junit (but Kotlin-native suites as Kotest do not need it)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">JunitTest</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#555">@Test</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">`404 errors should cause a wait and retry`</span>() = TODO() <span style="color:#888">// Nice and very clear name
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101-22">Kotlin 101</h1>
<h2 id="local-functions">Local functions</h2>
<p>Functions can contain other functions (as in Scala)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">factorial</span>(n: UInt): ULong {
</span></span><span style="display:flex;"><span>    <span style="color:#888">// tailrec forces optimization of tail recursion (and blocks compilation if recursion is non-tail)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">tailrec</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">factorialWithAccumulator</span>(current: UInt, accumulator: ULong): ULong = <span style="color:#080;font-weight:bold">when</span> {
</span></span><span style="display:flex;"><span>        current &gt;= n -&gt; accumulator * current
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">else</span> -&gt; factorialWithAccumulator(current + <span style="color:#00d;font-weight:bold">1u</span>, accumulator * current)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> factorialWithAccumulator(<span style="color:#00d;font-weight:bold">1u</span>, <span style="color:#00d;font-weight:bold">1u</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Warning: local functions often hinder clarity</p>
</section><section>
<h1 id="kotlin-101----flow-control">Kotlin 101 ‚Äì Flow control</h1>
<h2 id="if"><code>if</code></h2>
<ul>
<li><code>if</code>/<code>else</code> is an expression and works just as in Scala</li>
<li>No ternary operator</li>
<li><code>if</code> alone is not an expression</li>
<li><strong>No</strong> <em>partial functions</em>!</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-1">Kotlin 101 ‚Äì Flow control</h1>
<h3 id="for"><code>for</code></h3>
<ul>
<li><strong>No classic</strong> <code>for(init; condition; then) { block }</code> loop</li>
<li>Only available as <code>for</code>/<code>in</code>: <code>for (element in collection) { block }</code></li>
<li><strong>Not a powerful combinator</strong> like Scala‚Äôs <code>for</code></li>
<li><em>Rarely used</em> (I think I might have used it twice in my career)</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-2">Kotlin 101 ‚Äì Flow control</h1>
<h3 id="while-and-dowhile"><code>while</code> and <code>do</code>/<code>while</code></h3>
<ul>
<li>Same as Java, but with <em>visibility of variables defined in the <code>do</code>-block</em></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">kotlin.random.Random</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">lucky</span> = <span style="color:#00d;font-weight:bold">6</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">attempts</span> = <span style="color:#00d;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">draw</span> = <span style="color:#b06;font-weight:bold">Random</span>.nextInt(lucky + <span style="color:#00d;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>    attempts++
</span></span><span style="display:flex;"><span>} <span style="color:#080;font-weight:bold">while</span> (draw != lucky) <span style="color:#888">// draw is visible here
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>println(<span style="color:#d20;background-color:#fff0f0">"Launched </span><span style="color:#33b;background-color:#fff0f0">$attempts</span><span style="color:#d20;background-color:#fff0f0"> dice before a lucky shot"</span>)
</span></span></code></pre></div></section><section>
<h1 id="kotlin-101----flow-control-3">Kotlin 101 ‚Äì Flow control</h1>
<h3 id="when"><code>when</code></h3>
<p>Kotlin <em>does not support pattern matching</em> as Scala does (unfortunately)
<br>
The <code>when</code> block is somewhat a mild surrogate, more similar to a <code>switch</code> on steroids
<br>
The base version (without subject) is a more elegant ‚Äú<code>if</code>/<code>else if</code>/<code>else</code>‚Äù chain</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">countBatmans</span>(subject: String) = <span style="color:#080;font-weight:bold">when</span> {
</span></span><span style="display:flex;"><span>    subject.length &lt; <span style="color:#d20;background-color:#fff0f0">"batman"</span>.length -&gt; <span style="color:#00d;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>    subject.length &lt; <span style="color:#00d;font-weight:bold">2</span> * <span style="color:#d20;background-color:#fff0f0">"batman"</span>.length &amp;&amp; subject.contains(<span style="color:#d20;background-color:#fff0f0">"batman"</span>) -&gt; <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#d20;background-color:#fff0f0">".*?(batman)"</span>.toRegex().findAll(subject).count().toInt()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>when</code> is an expression in any case</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-4">Kotlin 101 ‚Äì Flow control</h1>
<h3 id="when-subject"><code>when (subject)</code></h3>
<p>Checks if the value of subjects is the same of the expression on the right</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baseForSingleDigitOrNull</span>(digit: UInt) = <span style="color:#080;font-weight:bold">when</span>(digit) {
</span></span><span style="display:flex;"><span>    <span style="color:#00d;font-weight:bold">0u</span>, <span style="color:#00d;font-weight:bold">1u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"binary"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#00d;font-weight:bold">2u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"ternary"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">7u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"octal"</span> <span style="color:#888">// This is a range!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">15u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"hexadecimal"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">36u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"base36"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#080;font-weight:bold">null</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>when</code> with subject can be used to elegantly check for subtypes</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">splitAnything</span>(input: Any) = <span style="color:#080;font-weight:bold">when</span>(input) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">is</span> Int -&gt; input / <span style="color:#00d;font-weight:bold">2</span> <span style="color:#888">// No need to cast! The compiler infers type automatically (smart cast)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">is</span> String -&gt; input.substring(input.length / <span style="color:#00d;font-weight:bold">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">is</span> Double -&gt; input / <span style="color:#00d;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">else</span> -&gt; TODO()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section><section>
<h2 id="kotlin-101----flow-control-5">Kotlin 101 ‚Äì Flow control</h2>
<h3 id="jumping">Jumping</h3>
<p><strong>Jumping is awful, imperative, and you should not use it</strong>
<br>
‚Ä¶but someone might and you must be able to understand it‚Ä¶</p>
<ul>
<li><code>break</code> and <code>continue</code> work as in Java</li>
<li><code>return</code> does not, as we will see when discussing higher order functions‚Ä¶</li>
</ul>
<h4 id="labelling">labelling</h4>
<ul>
<li>Any expression can be labeled: <code>label@ 1</code> is a valid expression</li>
<li><code>break</code>, <code>continue</code>, and <code>return</code> can be <em>qualified</em> with a label</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span>outerloop<span style="color:#a61717;background-color:#e3d2d2">@</span> <span style="color:#080;font-weight:bold">for</span> (i <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">100</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">for</span> (j <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">100</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">if</span> (i * j == i + j) {
</span></span><span style="display:flex;"><span>            println(<span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$i</span><span style="color:#d20;background-color:#fff0f0"> * </span><span style="color:#33b;background-color:#fff0f0">$j</span><span style="color:#d20;background-color:#fff0f0"> equals </span><span style="color:#33b;background-color:#fff0f0">$i</span><span style="color:#d20;background-color:#fff0f0"> + </span><span style="color:#33b;background-color:#fff0f0">$j</span><span style="color:#d20;background-color:#fff0f0">"</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#080;font-weight:bold">break</span><span style="color:#555">@outerloop</span> <span style="color:#888">// Qualified break
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop">Kotlin 102 ‚Äì OOP</h1>
<h2 id="classes">Classes</h2>
<ul>
<li>Similar to Scala, the keyword <code>class</code> introduces a class definition</li>
<li>Object construction does not require <code>new</code>
<ul>
<li><code>new</code> is not a Kotlin keyword at all</li>
</ul>
</li>
<li>Objecs get built from classes by just invoking the class name:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>
</span></span><span style="display:flex;"><span>Foo() <span style="color:#888">// a new Foo is created, no new keyword
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-1">Kotlin 102 ‚Äì OOP</h1>
<h2 id="classes-and-members">Classes and members</h2>
<p>Kotlin classes have two types of members: <strong>methods</strong> and <strong>properties</strong></p>
<table>
<thead>
<tr>
<th>Language / Member Type</th>
<th style="text-align:center">Fields</th>
<th>Methods</th>
<th>Properties</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java</td>
<td style="text-align:center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td>Scala</td>
<td style="text-align:center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td>Kotlin</td>
<td style="text-align:center"><strong>No</strong> (Hidden)</td>
<td><em>Yes</em></td>
<td><em>Yes</em></td>
</tr>
<tr>
<td>C#</td>
<td style="text-align:center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><em>Yes</em></td>
</tr>
</tbody>
</table>
<p>In Scala, at the caller site, methods and fields are hard to distinguish due to the Uniform Access Principle.</p>
<ul>
<li>In Kotlin, <strong>methods/functions</strong> (except when defined <code>infix</code>) are invoked with <em>mandatory parentheses</em></li>
<li><strong>properties</strong> are instead invoked <em>without parentheses</em></li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-2">Kotlin 102 ‚Äì OOP</h1>
<h2 id="properties-vs-fields">Properties vs. fields</h2>
<p>Properties and fields are conceptually different</p>
<ul>
<li><em>fields</em> <strong>are</strong> the object‚Äôs state</li>
<li><em>properties</em> are a way to <strong>access/change</strong> the object‚Äôs state</li>
</ul>
<p>It‚Äôs considered a good practice in languages without properties (Java in particular) to hide (<em>incapsulate</em>) fields (Object‚Äôs actual state)
and provide access only via <code>get</code>/<code>set</code> methods: the actual state representation may change with no change to the API.</p>
<p>In Kotlin, fields are entirely hidden, and cannot be exposed in any way, enforcing the aforementioned convention at the language level.</p>
</section><section>
<h1 id="kotlin-102----oop-3">Kotlin 102 ‚Äì OOP</h1>
<h2 id="defining-properties-for-classes">Defining properties for classes</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span> = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#080;font-weight:bold">null</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bazLength</span>: Int <span style="color:#888">// Property with no "backing field"
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">get</span>() = baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// As its value will be computed every time
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">stringRepresentation</span>: String = <span style="color:#d20;background-color:#fff0f0">""</span> <span style="color:#888">// Backing fields is generated
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">get</span>() = baz ?: <span style="color:#080;font-weight:bold">field</span>
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">set</span>(<span style="color:#080;font-weight:bold">value</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#080;font-weight:bold">field</span> = <span style="color:#d20;background-color:#fff0f0">"custom: </span><span style="color:#33b;background-color:#fff0f0">$value</span><span style="color:#d20;background-color:#fff0f0">"</span> <span style="color:#888">// Access to backing field via `field` keyword
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">foo</span> = Foo()
</span></span><span style="display:flex;"><span>foo.bar = <span style="color:#00d;font-weight:bold">3</span><span class="fragment " style="color: #888;"> // error: val cannot be reassigned</span>
</span></span><span style="display:flex;"><span>foo.stringRepresentation<span class="fragment " style="color: #888;"> // empty string</span>
</span></span><span style="display:flex;"><span>foo.stringRepresentation = <span style="color:#d20;background-color:#fff0f0">"zed"</span><span class="fragment " style="color: #888;"> // 'custom: zed'</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-4">Kotlin 102 ‚Äì OOP</h1>
<h2 id="backing-fields">Backing fields</h2>
<p>The keyword <code>field</code> allows access to a backing field of a property
<br>
<strong>in case it is present</strong></p>
<p>The Kotlin compiler, in fact, generates backing fields only when needed</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">id</span>: String? = <span style="color:#080;font-weight:bold">null</span> <span style="color:#888">// Backing field generated
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">identifierOnce</span>: String = <span style="color:#d20;background-color:#fff0f0">"Student[</span><span style="color:#33b;background-color:#fff0f0">${id ?: "unknown"}</span><span style="color:#d20;background-color:#fff0f0">]"</span> <span style="color:#888">// Backing field generated
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">identifierUpdated</span>: String <span style="color:#080;font-weight:bold">get</span>() = <span style="color:#d20;background-color:#fff0f0">"Student[</span><span style="color:#33b;background-color:#fff0f0">${id ?: "unknown"}</span><span style="color:#d20;background-color:#fff0f0">]"</span> <span style="color:#888">// No backing field
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div><p>When designing with Kotlin, you must consider methods and properties, and forget about fields.</p>
</section><section>
<h1 id="kotlin-102----oop-5">Kotlin 102 ‚Äì OOP</h1>
<h2 id="defining-methods">Defining methods</h2>
<p>Methods are defined as <code>fun</code>ctions within the scope of a class</p>
<ul>
<li>As in any OOP language, they have an implicit parameter, the <strong>receiver</strong> (<code>this</code>)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutableComplex</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">real</span>: Double = <span style="color:#00d;font-weight:bold">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">imaginary</span>: Double = <span style="color:#00d;font-weight:bold">0.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: MutableComplex): MutableComplex = MutableComplex().also {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">it</span>.real = real + other.real
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">it</span>.imaginary = imaginary + other.imaginary
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">foo</span> = MutableComplex()
</span></span><span style="display:flex;"><span>foo.real = <span style="color:#00d;font-weight:bold">1.0</span>
</span></span><span style="display:flex;"><span>foo.imaginary = <span style="color:#00d;font-weight:bold">2.0</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span> = MutableComplex()
</span></span><span style="display:flex;"><span>bar.real = <span style="color:#00d;font-weight:bold">4.1</span>
</span></span><span style="display:flex;"><span>bar.imaginary = <span style="color:#00d;font-weight:bold">0.1</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">baz</span> = foo.plus(bar)
</span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${baz.real}</span><span style="color:#d20;background-color:#fff0f0">+</span><span style="color:#33b;background-color:#fff0f0">${baz.imaginary}</span><span style="color:#d20;background-color:#fff0f0">i"</span><span class="fragment " style="color: #888;"> // 5.1+2.1i</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-6">Kotlin 102 ‚Äì OOP</h1>
<h2 id="interfaces">Interfaces</h2>
<ul>
<li>Similar to Java 8+</li>
<li>Methods can be implemented</li>
<li>Can host properties
<ul>
<li>And their accessors can be implemented</li>
<li>Properties in interfaces <em>do not have backing fields</em></li>
</ul>
</li>
<li>Both properties and methods can be implemented there</li>
<li>Scala-like mixins not supported
<ul>
<li>A Kotlin <code>interface</code> cannot be a subclass of a Kotlin <code>class</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">trait</span> <span style="color:#b06;font-weight:bold">B</span> <span style="color:#080;font-weight:bold">extends</span> A <span style="color:#888">// All fine in Scala
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">B</span> : A <span style="color:#888">// error: an interface cannot inherit from a class
</span></span></span></code></pre></div><p>So, no mixins</p>
</section><section>
<h1 id="kotlin-102----oop-7">Kotlin 102 ‚Äì OOP</h1>
<h2 id="implementing-interfaces">Implementing interfaces</h2>
<p>Much like Java. Subtyping keyword is <code>:</code>, overrides <em>must</em> be marked with <code>override</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Shape</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">area</span>: Double
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">perimeter</span>: Double
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Shrinkable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">shrink</span>(): Unit
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutableCircle</span> : Shape, Shrinkable {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">radius</span> = <span style="color:#00d;font-weight:bold">1.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">area</span> <span style="color:#080;font-weight:bold">get</span>() = <span style="color:#b06;font-weight:bold">Math</span>.PI * radius * radius
</span></span><span style="display:flex;"><span>    <span style="color:#888">// What if we remove "get()"?
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">perimeter</span> <span style="color:#080;font-weight:bold">get</span>() = <span style="color:#00d;font-weight:bold">2</span> * <span style="color:#b06;font-weight:bold">Math</span>.PI * radius
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">shrink</span>() {
</span></span><span style="display:flex;"><span>        radius /= <span style="color:#00d;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-8">Kotlin 102 ‚Äì OOP</h1>
<h2 id="superclass-disambiguation">Superclass disambiguation</h2>
<p>A call to <code>super</code> can be qualified to disambiguate between conflincting interface declarations:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#d20;background-color:#fff0f0">"foo"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">B</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#d20;background-color:#fff0f0">"bar"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">C</span> : A, B {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#080;font-weight:bold">super</span>&lt;A&gt;.foo() + <span style="color:#080;font-weight:bold">super</span>&lt;B&gt;.foo()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>C().foo()<span class="fragment " style="color: #888;"> // foobar</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-9">Kotlin 102 ‚Äì OOP</h1>
<h2 id="primary-constructors-and-init">Primary constructors and <code>init</code></h2>
<p>Similar to Scala, but code in the class body is not part of a constructor
<br>
Primary constructor code (if any) must be in an <code>init</code> block</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String, <span style="color:#888">// This is a val property of the class
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: Int, <span style="color:#888">// This is a var property of the class
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    greeting: String = <span style="color:#d20;background-color:#fff0f0">"Hello from constructor"</span> <span style="color:#888">// non-property constructor parameter. Default values allowed
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">init</span> {
</span></span><span style="display:flex;"><span>        println(greeting)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Foo(<span style="color:#d20;background-color:#fff0f0">"bar"</span>, <span style="color:#00d;font-weight:bold">0</span>)
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-10">Kotlin 102 ‚Äì OOP</h1>
<h2 id="secondary-constructors">Secondary <code>constructor</code>s</h2>
<p>More constructors can be added to a class, but they:</p>
<ol>
<li>Must call another constructor</li>
<li>The primary constructor must be in its <em>delegation calls chain</em></li>
</ol>
<p>Call to another constructor is performed using <code>:</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">constructor</span>(longBar: Long) : <span style="color:#080;font-weight:bold">this</span>(<span style="color:#d20;background-color:#fff0f0">"number </span><span style="color:#33b;background-color:#fff0f0">${longBar.toString()}</span><span style="color:#d20;background-color:#fff0f0">"</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">constructor</span>(intBar: Int) : <span style="color:#080;font-weight:bold">this</span>(intBar.toLong())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Foo(<span style="color:#00d;font-weight:bold">1</span>).bar <span style="color:#888">// number 1
</span></span></span></code></pre></div><p>The primary constructor can be written in a longer form with the <code>constructor</code> keyword as well</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span> <span style="color:#080;font-weight:bold">constructor</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String) <span style="color:#888">// OK
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-11">Kotlin 102 ‚Äì OOP</h1>
<h2 id="nullability-and-lateinit">Nullability and <code>lateinit</code></h2>
<p>It is possible that some <code>var</code> property needs to get initialized after the object construction:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span>: Father)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span>(<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son) <span style="color:#888">// Impossible to build either
</span></span></span></code></pre></div><p>Solution 1: allow nullability (<strong>BAD</strong>)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span>: Father)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span>(<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son? = <span style="color:#080;font-weight:bold">null</span>)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span> = Father()
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">son</span> = Son(father)
</span></span><span style="display:flex;"><span>father.son = son
</span></span><span style="display:flex;"><span>father.son.father <span style="color:#888">// error, needs ?.
</span></span></span></code></pre></div><p>Solution 2: take responsibility from the compiler (<em>less bad</em>)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span>: Father)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span> { <span style="color:#080;font-weight:bold">lateinit</span> <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son } <span style="color:#888">// lateinit: I will initialize it later, stay cool
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span> = Father()
</span></span><span style="display:flex;"><span>father.son <span style="color:#888">// UninitializedPropertyAccessException: lateinit property son has not been initialized
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">son</span> = Son(father)
</span></span><span style="display:flex;"><span>father.son = son
</span></span><span style="display:flex;"><span>father.son.father <span style="color:#888">// OK!
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-12">Kotlin 102 ‚Äì OOP</h1>
<blockquote>
<p><strong>Design and document for inheritance or else prohibit it</strong>
<cite>J. Bloch, Effective Java, Item 17</cite></p>
</blockquote>
<h2 id="closed-hierarchies-and-open">Closed hierarchies and <code>open</code></h2>
<p>Kotlin enforces EJ-17 by design: all classes are final if the keyword <code>open</code> is not specified</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// error: this type is final, so it cannot be inherited from
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// OK
</span></span></span></code></pre></div><p>As in Scala, <em>the constructor of the superclass must be called at extension site</em>
<br>
Differently than Scala, such invocatin <em>always requires parentheses</em></p>
</section><section>
<h1 id="kotlin-102----oop-13">Kotlin 102 ‚Äì OOP</h1>
<h2 id="abstract-vs-open"><code>abstract</code> vs. <code>open</code></h2>
<p>The same effect of <code>open</code> can be achieved with <code>abstract</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// Perfectly fine
</span></span></span></code></pre></div><p>With abstract, however, the superclass cannot be created
<br>
(and it should have actual <code>abstract</code> memebers anyway)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Open</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Abstract</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FromOpen</span> : Open()
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FromAbstract</span> : Abstract()
</span></span><span style="display:flex;"><span>FromAbstract() <span style="color:#888">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>FromOpen() <span style="color:#888">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>Open() <span style="color:#888">// OK
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>Abstract() <span style="color:#888">// error: cannot create an instance of an abstract class
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-14">Kotlin 102 ‚Äì OOP</h1>
<h2 id="singleton-objects">Singleton <code>object</code>s</h2>
<p>Same as Scala, but with explicit <code>companion</code>s
<br>
In Scala</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">A</span> <span style="color:#888">// Same file and same name identify a companion
</span></span></span></code></pre></div><p>In Kotlin</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">companion</span> <span style="color:#080;font-weight:bold">object</span> <span style="color:#888">// Companions are inner to classes 
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span><span style="display:flex;"><span>A <span style="color:#888">// refers to A.Companion
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">A</span> <span style="color:#888">// This is an independent object
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>A <span style="color:#888">// refers to the previously defined object
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-15">Kotlin 102 ‚Äì OOP</h1>
<h2 id="information-hiding">Information hiding</h2>
<p>Simpler than Scala, more coherent than Java</p>
<ul>
<li><code>public</code> ‚Äì default visibility, visible everywhere (API)</li>
<li><code>internal</code> ‚Äì visible to everything in this <em>‚Äúmodule‚Äù</em>
<ul>
<li>module $\Rightarrow$ a set of Kotlin files compiled together</li>
</ul>
</li>
<li><code>protected</code> ‚Äì visible to subclasses (but <em>not</em> to other members of the package)</li>
<li><code>private</code> ‚Äì visible inside this class and its members</li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-16">Kotlin 102 ‚Äì OOP</h1>
<h2 id="visibility-control">Visibility control</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Visibility</span> <span style="color:#080;font-weight:bold">internal</span> <span style="color:#080;font-weight:bold">constructor</span>( <span style="color:#888">// constructor is required to apply visibility restrictionss
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: Int <span style="color:#888">// Same as Scala
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>) { 
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">protected</span> <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">state</span> = <span style="color:#00d;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">set</span> <span style="color:#888">// visibility restriction for properties in get/set methods
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="equality-hashing-string-version">Equality, hashing, string version</h2>
<p>Same as Java, but for equality:</p>
<ul>
<li><code>==</code> calls <code>equals</code></li>
<li>Java‚Äôs stack variable comparison (<code>==</code>) is Kotlin‚Äôs <code>===</code></li>
</ul>
<p>Kotlin does not suffer of Scala‚Äôs equality issues
(no automatic conversion of types)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> a<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Int</span> = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> b<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Long</span> = a
</span></span><span style="display:flex;"><span>a == b <span style="color:#888">// true
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>a equals b <span style="color:#888">// false O_O
</span></span></span></code></pre></div><p>Kotlin:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">a</span>: Int = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">b</span>: Long = a <span style="color:#888">// error: type mismatch: inferred type is Int but Long was expected
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">b</span>: Long = a.toLong()
</span></span><span style="display:flex;"><span>a == b <span style="color:#888">// error: operator '==' cannot be applied to 'Int' and 'Long'
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>a.toLong() == b <span style="color:#888">// true
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>a == b.toInt() <span style="color:#888">// true
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-1">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="infix-calls"><code>infix</code> calls</h2>
<p>Kotlin is less permissive than Scala:</p>
<ul>
<li>In Scala, every instance method with a single parameter can be invoked as infix operator:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1</span> equals <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// infix invocation of 1.equals(1)
</span></span></span></code></pre></div><ul>
<li>In Kotlin, this is not allowed:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1</span> equals <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// error: 'infix' modifier is required on 'equals' in 'kotlin.Int'
</span></span></span></code></pre></div><ul>
<li>Kotlin requires that the <code>infix</code> keyword for a method to be usable as infix</li>
<li><code>infix</code> functions have <em>lower precedence</em> than operators</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Infix</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">infix</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">with</span>(s: String) = <span style="color:#d20;background-color:#fff0f0">"in... </span><span style="color:#33b;background-color:#fff0f0">$s</span><span style="color:#d20;background-color:#fff0f0"> ...fix!"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Infix() with <span style="color:#d20;background-color:#fff0f0">"Foo"</span> <span style="color:#888">// in... Foo ...fix!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>Infix() with <span style="color:#d20;background-color:#fff0f0">"Foo"</span> + <span style="color:#d20;background-color:#fff0f0">"Bar"</span> <span class="fragment " style="color: #888;"> // in... FooBar ...fix</span>
</span></span><span style="display:flex;"><span>Infix() with <span style="color:#d20;background-color:#fff0f0">"Foo"</span> + <span style="color:#d20;background-color:#fff0f0">"Bar"</span> + Infix() with <span style="color:#d20;background-color:#fff0f0">"Baz"</span> <span class="fragment " style="color: #888;"> // error: unresolved reference: with</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-2">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="operator-creation">Operator creation</h2>
<p>In Scala, operator names are valid method names, and infix calls are automatic:</p>
<ul>
<li>Very much the whole language philosophy: few concepts, high scalability</li>
<li>Easy to abuse, degenerating to esoteric operators
<ul>
<li>Especially when software is written by people with different background</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span>executer(<span style="color:#080;font-weight:bold">:</span><span style="color:#888;font-weight:bold">/</span>(<span style="color:#888;font-weight:bold">host</span>, <span style="color:#888;font-weight:bold">port</span>) / target &lt;&lt; reqBody &gt;- { fromRespStr }) <span style="color:#888">// Using Databinder Dispatch
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> graph <span style="color:#080;font-weight:bold">=</span> <span style="color:#b06;font-weight:bold">Graph</span>((jfc ~+#&gt; fra)(<span style="color:#b06;font-weight:bold">Any</span>()), (fra ~+#&gt; dme)(<span style="color:#b06;font-weight:bold">Any</span>()) <span style="color:#888">// Using ScalaGraph
</span></span></span></code></pre></div><p>Operators are succint, but cryptic, and their meaning changes with context</p>
<p>This has been a source of cricism, Kotlin <strong>does not allow to define custom operators</strong></p>
<ul>
<li>At most, back-ticked names, but some characters are disallowed (<code>&gt;</code>, <code>/</code>, <code>:</code>, etc.)</li>
<li>Clumsy, defies the reason why one would use them (terse and succint code)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> { <span style="color:#080;font-weight:bold">infix</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">`~+#-`</span>(other: A) = <span style="color:#d20;background-color:#fff0f0">"I'm an arcane operator"</span> }
</span></span><span style="display:flex;"><span>A() <span style="color:#a61717;background-color:#e3d2d2">`</span>~+<span style="color:#a61717;background-color:#e3d2d2">#</span>-<span style="color:#a61717;background-color:#e3d2d2">`</span> A() <span style="color:#888">// I'm an arcane operator
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-3">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="operator-overloading">Operator overloading</h2>
<p>Kotlin allows for a limited set of operators to be defined/overloaded</p>
<ul>
<li>Method names must match a convention</li>
<li>Methods must be annotated with the <code>operator</code> keyword</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Complex</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">real</span>: Double, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">imaginary</span>: Double) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: Complex) = Complex(real + other.real, imaginary + other.imaginary)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: Double) = plus(Complex(other, <span style="color:#00d;font-weight:bold">0.0</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = real.toString() + <span style="color:#080;font-weight:bold">when</span> {
</span></span><span style="display:flex;"><span>        imaginary == <span style="color:#00d;font-weight:bold">0.0</span> -&gt; <span style="color:#d20;background-color:#fff0f0">""</span>
</span></span><span style="display:flex;"><span>        imaginary &gt; <span style="color:#00d;font-weight:bold">0.0</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"+</span><span style="color:#33b;background-color:#fff0f0">${imaginary}</span><span style="color:#d20;background-color:#fff0f0">i"</span>
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${imaginary}</span><span style="color:#d20;background-color:#fff0f0">i"</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Complex(<span style="color:#00d;font-weight:bold">1.0</span>, <span style="color:#00d;font-weight:bold">1.0</span>) + <span style="color:#00d;font-weight:bold">3.4</span> <span style="color:#888">// 4.4+1.0i
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-4">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="unary-operator-overloading-table">Unary Operator overloading table</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+x</code></td>
<td style="text-align:center"><code>unaryPlus</code></td>
<td><code>x.unaryPlus()</code></td>
</tr>
<tr>
<td><code>-x</code></td>
<td style="text-align:center"><code>unaryMinus</code></td>
<td><code>x.unaryMinus()</code></td>
</tr>
<tr>
<td><code>++x</code></td>
<td style="text-align:center"><code>inc</code></td>
<td><code>x.inc().also { x = it }</code></td>
</tr>
<tr>
<td><code>x++</code></td>
<td style="text-align:center"><code>inc</code></td>
<td><code>x.also { x = it.inc() }</code></td>
</tr>
<tr>
<td><code>--x</code></td>
<td style="text-align:center"><code>dec</code></td>
<td><code>x.dec().also { x = it }</code></td>
</tr>
<tr>
<td><code>x--</code></td>
<td style="text-align:center"><code>dec</code></td>
<td><code>x.also { x = it.dec() }</code></td>
</tr>
<tr>
<td><code>!x</code></td>
<td style="text-align:center"><code>not</code></td>
<td><code>x.not()</code></td>
</tr>
<tr>
<td><code>x()</code></td>
<td style="text-align:center"><code>invoke</code></td>
<td><code>x.invoke()</code></td>
</tr>
</tbody>
</table>
<p>Function invocation is an operator and can be overloaded!
<br>
This will turn useful in future‚Ä¶</p>
</section><section>
<h1 id="kotlin-102----oop-conventions-5">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="binary-operator-overloading-arithmetic">Binary Operator overloading: arithmetic</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x + y</code></td>
<td style="text-align:center"><code>plus</code></td>
<td><code>x.plus(y)</code></td>
</tr>
<tr>
<td><code>x - y</code></td>
<td style="text-align:center"><code>minus</code></td>
<td><code>x.minus(y)</code></td>
</tr>
<tr>
<td><code>x * y</code></td>
<td style="text-align:center"><code>times</code></td>
<td><code>x.times(y)</code></td>
</tr>
<tr>
<td><code>x / y</code></td>
<td style="text-align:center"><code>div</code></td>
<td><code>x.div(y)</code></td>
</tr>
<tr>
<td><code>x % y</code></td>
<td style="text-align:center"><code>rem</code></td>
<td><code>x.rem(y)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-6">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="binary-operator-overloading-assignment">Binary Operator overloading: assignment</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x += y</code></td>
<td style="text-align:center"><code>plusAssign</code></td>
<td><code>x.plusAssign(y)</code></td>
</tr>
<tr>
<td><code>x -= y</code></td>
<td style="text-align:center"><code>minusAssign</code></td>
<td><code>x.minusAssign(y)</code></td>
</tr>
<tr>
<td><code>x *= y</code></td>
<td style="text-align:center"><code>timesAssign</code></td>
<td><code>x.timesAssign(y)</code></td>
</tr>
<tr>
<td><code>x /= y</code></td>
<td style="text-align:center"><code>divAssign</code></td>
<td><code>x.divAssign(y)</code></td>
</tr>
<tr>
<td><code>x %= y</code></td>
<td style="text-align:center"><code>remAssign</code></td>
<td><code>x.remAssign(y)</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Assignment functions <em>can be defined only if their arithmetic equivalent is undefined</em>.</li>
<li>If an aritmetic operator <code>op</code> is defined, the compiler infers the assign version as:
<ul>
<li><code>a op= b</code> $\Rightarrow$ <code>a = a op b</code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-conventions-7">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="binary-operator-overloading-comparison">Binary Operator overloading: comparison</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x == y</code></td>
<td style="text-align:center"><code>equals</code></td>
<td><code>x?.equals(y) ?: (y === null)</code></td>
</tr>
<tr>
<td><code>x != y</code></td>
<td style="text-align:center"><code>equals</code></td>
<td><code>!(x?.equals(y) ?: (y === null))</code></td>
</tr>
<tr>
<td><code>x &gt; y</code></td>
<td style="text-align:center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &gt; 0</code></td>
</tr>
<tr>
<td><code>x &lt; y</code></td>
<td style="text-align:center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &lt; 0</code></td>
</tr>
<tr>
<td><code>x &gt;= y</code></td>
<td style="text-align:center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &gt;= 0</code></td>
</tr>
<tr>
<td><code>x &lt;= y</code></td>
<td style="text-align:center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &lt;= 0</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-8">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="binary-operator-overloading-others">Binary Operator overloading: others</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x..y</code></td>
<td style="text-align:center"><code>rangeTo</code></td>
<td><code>x.rangeTo(y)</code></td>
</tr>
<tr>
<td><code>x in y</code></td>
<td style="text-align:center"><code>contains</code></td>
<td><code>y.contains(x)</code></td>
</tr>
<tr>
<td><code>x !in y</code></td>
<td style="text-align:center"><code>contains</code></td>
<td><code>!y.contains(x)</code></td>
</tr>
<tr>
<td><code>x[y]</code></td>
<td style="text-align:center"><code>get</code></td>
<td><code>x.get(y)</code></td>
</tr>
<tr>
<td><code>x(y)</code></td>
<td style="text-align:center"><code>invoke</code></td>
<td><code>x.invoke(y)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-9">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="ternary-operator-overloading">Ternary Operator overloading</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[y, z]</code></td>
<td style="text-align:center"><code>get</code></td>
<td><code>x.get(y, z)</code></td>
</tr>
<tr>
<td><code>x[y] = z</code></td>
<td style="text-align:center"><code>set</code></td>
<td><code>x.set(y) = z</code></td>
</tr>
<tr>
<td><code>x(y, z)</code></td>
<td style="text-align:center"><code>invoke</code></td>
<td><code>x.invoke(y, z)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-10">Kotlin 102 ‚Äì OOP Conventions</h1>
<h2 id="n-ary-operator-overloading">n-ary Operator overloading</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th style="text-align:center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[y, ..., z]</code></td>
<td style="text-align:center"><code>get</code></td>
<td><code>x.get(y, ..., z)</code></td>
</tr>
<tr>
<td><code>x[y, ..., z] = a</code></td>
<td style="text-align:center"><code>set</code></td>
<td><code>x.set(y, ..., z) = a</code></td>
</tr>
<tr>
<td><code>x(y, ..., z)</code></td>
<td style="text-align:center"><code>invoke</code></td>
<td><code>x.invoke(y, ..., z)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-103----generics">Kotlin 103 ‚Äì Generics</h1>
<h2 id="compared-with-java-and-scala">Compared with Java and Scala</h2>
<p>Kotlin‚Äôs type system supports generics</p>
<ul>
<li>Handier than Java‚Äôs</li>
<li><strong>way</strong> less powerful than Scala‚Äôs</li>
<li>No higher kinded types (found in Scala)</li>
<li>No type lambdas (found in Scala)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">trait</span> <span style="color:#b06;font-weight:bold">Functor</span>[<span style="color:#888;font-weight:bold">F</span>[<span style="color:#080;font-weight:bold">_</span>]] <span style="color:#888">// Scala 2: there is no Kotlin equivalent
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">MapFunctor</span> = <span style="color:#b06;font-weight:bold">Functor</span>[({ <span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">T</span>[<span style="color:#888;font-weight:bold">A</span>] <span style="color:#888;font-weight:bold">=</span> <span style="color:#888;font-weight:bold">Map</span>[<span style="color:#888;font-weight:bold">Int</span>, <span style="color:#888;font-weight:bold">A</span>] })<span style="color:#080;font-weight:bold">#</span><span style="color:#888;font-weight:bold">T</span>]
</span></span></code></pre></div><br>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">MapFunctor</span> = [<span style="color:#888;font-weight:bold">A</span>] =&gt;&gt; <span style="color:#b06;font-weight:bold">Map</span>[<span style="color:#888;font-weight:bold">Int</span>, <span style="color:#888;font-weight:bold">A</span>] <span style="color:#888">// Scala 3: there is no Kotlin equivalent
</span></span></span></code></pre></div><br>
<ul>
<li>Declaration-site variance (absent in Java)</li>
<li>Generic type reification via inlining (not found in Java, somewhat obtainable in Scala 3)</li>
</ul>
</section><section>
<h1 id="kotlin-103----generics-1">Kotlin 103 ‚Äì Generics</h1>
<h2 id="base-syntax">Base syntax</h2>
<p>Syntax similar to Java generics</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>&lt;A, B : CharSequence&gt;
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span> : <span style="color:#b06;font-weight:bold">Comparable</span>&lt;<span style="color:#b06;font-weight:bold">T</span>&gt;&gt; <span style="color:#06b;font-weight:bold">maxOf3</span>(first: T, second: T, third: T): T = <span style="color:#080;font-weight:bold">when</span> {
</span></span><span style="display:flex;"><span>    first &gt;= second &amp;&amp; first &gt;= third -&gt; first
</span></span><span style="display:flex;"><span>    second &gt;= third -&gt; second
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">else</span> -&gt; third
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>type upper bounds can be specified with <code>:</code></li>
<li>if no bound is specified, the generic is <em>nullable</em>!</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span>&gt; <span style="color:#06b;font-weight:bold">className</span>(<span style="color:#080;font-weight:bold">receiver</span>: T) = <span style="color:#080;font-weight:bold">receiver</span>::<span style="color:#080;font-weight:bold">class</span>.simpleName
</span></span><span style="display:flex;"><span><span style="color:#888">// error: expression in a class literal has a nullable type 'T', use !! to make the type non-nullable
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-103----generics-2">Kotlin 103 ‚Äì Generics</h1>
<h2 id="where"><code>where</code></h2>
<p>In case multiple bounds are present, the definition can become cumbersome
<br>
Kotlin provides a <code>where</code> keyword to specify type bounds separately from the rest of the signature</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#888">// From an actual Alchemist interface
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">NavigationStrategy</span>&lt;T, P, A, L, R, N, E&gt;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">where</span> P : Position&lt;P&gt;, P : Vector&lt;P&gt;,
</span></span><span style="display:flex;"><span>          A : GeometricTransformation&lt;P&gt;,
</span></span><span style="display:flex;"><span>          L : ConvexGeometricShape&lt;P, A&gt;,
</span></span><span style="display:flex;"><span>          N : ConvexGeometricShape&lt;P, A&gt; {
</span></span><span style="display:flex;"><span><span style="color:#888">// Interface content, if any
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888">// Function syntax
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span>, <span style="color:#b06;font-weight:bold">P</span>, <span style="color:#b06;font-weight:bold">A</span>, <span style="color:#b06;font-weight:bold">L</span>, <span style="color:#b06;font-weight:bold">R</span>, <span style="color:#b06;font-weight:bold">N</span>, <span style="color:#b06;font-weight:bold">E</span>&gt; <span style="color:#06b;font-weight:bold">navigationStrategy</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">where</span> P : Position&lt;P&gt;, P : Vector&lt;P&gt;,
</span></span><span style="display:flex;"><span>          A : GeometricTransformation&lt;P&gt;,
</span></span><span style="display:flex;"><span>          L : ConvexGeometricShape&lt;P, A&gt;,
</span></span><span style="display:flex;"><span>          N : ConvexGeometricShape&lt;P, A&gt; = TODO()
</span></span></code></pre></div></section><section>
<h1 id="kotlin-103----generics-3">Kotlin 103 ‚Äì Generics</h1>
<h2 id="variance-and-type-projection">Variance and type projection</h2>
<p>Kotlin supports (co/contro)variance using:</p>
<ul>
<li><code>&lt;out T&gt;</code> to mark covariance (similar to Java‚Äôs <code>&lt;? extends T&gt;</code>)</li>
<li><code>&lt;in T&gt;</code> to mark controvariance (similar to Java‚Äôs <code>&lt;? super T&gt;</code>)</li>
<li><code>&lt;*&gt;</code> to mark that only the bound is known for the type (similar to Java‚Äôs <code>&lt;?&gt;</code>)</li>
</ul>
<p>Type variant in Kotlin is expressed <em>at declaration site</em>!</p>
<ul>
<li>In Java type variance is only for methods</li>
<li>In Kotlin type variance is only for classes and interfaces</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">ProduceAndConsume</span>&lt;<span style="color:#080;font-weight:bold">in</span> X, <span style="color:#080;font-weight:bold">out</span> Y&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">consume</span>(x: X): Any = TODO()<span class="fragment " style="color: #888;"> // OK</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">consume2</span>(y: Y): Any = TODO()<span class="fragment " style="color: #888;"> // Y is declared as 'out' but occurs in 'in' position</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">produce</span>(): Y = TODO()<span class="fragment " style="color: #888;"> // OK</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">produce2</span>(): X = TODO()<span class="fragment " style="color: #888;"> // X is declared as 'in' but occurs in 'out' position</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-103----generics-4">Kotlin 103 ‚Äì Generics</h1>
<h2 id="type-reification">Type reification</h2>
<p>Generics at runtime can be dealt with two strategies:</p>
<ul>
<li><strong>erasure</strong>: generic information is used by the compiler, but it‚Äôs discarded at runtime
<ul>
<li>Java / Scala</li>
</ul>
</li>
<li><strong>monomorphization</strong>: concrete type are emitted when generic types are actually used
<ul>
<li>Rust / C#</li>
</ul>
</li>
</ul>
<p>Delicate balance between executable size, performance, and usability</p>
<p>Kotlin uses erasure, but allows to control inlining via the <code>inline</code> keyword.
<br>
In inlined functions, <em>types can be locally monomorphized</em>!
<br>
Local monomorphization is expressed with the <code>reified</code> keyword.</p>
</section><section>
<h1 id="kotlin-103----generics-5">Kotlin 103 ‚Äì Generics</h1>
<h2 id="type-reification-example">Type reification example</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">inline</span> <span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#080;font-weight:bold">reified</span> <span style="color:#b06;font-weight:bold">T</span>&gt; <span style="color:#06b;font-weight:bold">checkIsType</span>(a: Any): Boolean = a <span style="color:#080;font-weight:bold">is</span> T <span style="color:#888">// instance check on a generic!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>checkIsType&lt;Long&gt;(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#888">// false
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>checkIsType&lt;Long&gt;(<span style="color:#00d;font-weight:bold">1L</span>) <span style="color:#888">// true
</span></span></span></code></pre></div><p>Note on Java interoperability:</p>
<ul>
<li><code>inline</code> functions get inlined if the caller is Kotlin-compiled code,
they don‚Äôt if they are called by other bytecode-targeting compilers (<code>javac</code>, <code>scalac</code>‚Ä¶)</li>
<li><code>reified</code> types <em>requires</em> inlining to perform the local monorphization:
the function code is <em>copied</em> on call site, and the compiler must know how to do it</li>
</ul>
<p>$\Rightarrow$ Can‚Äôt be used if interoperability is a concern</p>
<ul>
<li>or a wrapper must be provided</li>
</ul>
</section><section>
<h1 id="kotlin-103----collections">Kotlin 103 ‚Äì Collections</h1>
<p>Similar to Scala, but based (for the JVM target) on the Java implementation</p>
<ul>
<li>No <code>toJava()</code>/<code>toScala()</code> equivalent</li>
<li><code>List</code>, <code>Set</code>, <code>Map</code> are <em>unmodifiable</em> but not guaranteed <em>immutable</em>
<ul>
<li>e.g., at runtime, <code>List</code> may be backed by an <code>ArrayList</code></li>
<li>clients calling from Java will see mutable collections</li>
<li>Under the JVM, the immutable interfaces are erased at runtime</li>
</ul>
</li>
<li>Mutable collections are available via <code>Mutable</code>(<code>List</code>/<code>Set</code>/<code>Map</code>)</li>
<li>As in Scala, invocation of functional manipulation on collections returns a new collection</li>
<li>Differently than Scala, when a collection is returned, the type is usually <code>List</code>
<ul>
<li>Type is lost, no higher kinded types in Kotlin to express it</li>
</ul>
</li>
<li><code>Sequence</code>s prevent a collection creation at each step</li>
<li><code>Flow</code>s represent collections that are processed in parallel</li>
<li>Creation usually via functions <code>flowOf</code>/<code>listOf</code>/<code>mapOf</code>/<code>sequenceOf</code>/<code>setOf</code></li>
</ul>
</section><section>
<h1 id="kotlin-201----advanced-oop">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="data-classes">Data classes</h2>
<p>Very similar to Scala‚Äôs <code>case class</code>es:</p>
<ul>
<li>inheritance prohibited (Scala allows non-<code>case</code> classes to inherit from <code>case</code> classes)</li>
<li><code>equals</code>, <code>hashCode</code>, <code>toString</code> for free</li>
<li><code>copy</code> function, to be used to generate new immutable objects</li>
<li><code>component1</code>, <code>component2</code>, ‚Ä¶, <code>componentN</code> functions, called in case of destructuring</li>
</ul>
<p><code>Pair</code> and <code>Triple</code> provided by the standard library
<br>
(<code>Tuple4</code>, <code>Tuple5</code>, and so on are not in standard library as opposed as Scala)</p>
</section><section>
<h1 id="kotlin-201----advanced-oop-1">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="destructuring-declarations">Destructuring declarations</h2>
<p>If a class has <code>operator</code> functions named called <code>componentX</code> with <code>X</code> an integer from <code>1</code>,
they can be ‚Äúdestructured‚Äù.
<br>
This feature is <em>way</em> less powerful than Scala‚Äôs pattern matching.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#888">// to is an inline function that creates a Pair, similar to Scala's -&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">ferrari2021</span> = <span style="color:#d20;background-color:#fff0f0">"Ferrari"</span> to Pair(<span style="color:#d20;background-color:#fff0f0">"Sainz"</span>, <span style="color:#d20;background-color:#fff0f0">"Leclerc"</span>)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#a61717;background-color:#e3d2d2">(</span><span style="color:#369;font-weight:bold">team</span>, lineup) = ferrari2021
</span></span><span style="display:flex;"><span>team <span style="color:#888">// "Ferrari"
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>lineup <span style="color:#888">// Sainz to Leclerc
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#a61717;background-color:#e3d2d2">(</span><span style="color:#369;font-weight:bold">driver1</span>, driver2) = lineup
</span></span><span style="display:flex;"><span>driver1 <span style="color:#888">// Sainz
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>driver2 <span style="color:#888">// Leclerc
</span></span></span></code></pre></div><br>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">component1</span>() = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">component2</span>() = <span style="color:#00d;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">component3</span>() = <span style="color:#00d;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#a61717;background-color:#e3d2d2">(</span><span style="color:#369;font-weight:bold">a</span>, b, c) = A()
</span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$a$b$c</span><span style="color:#d20;background-color:#fff0f0">"</span>
</span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-2">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="sealed-hierarchies">Sealed hierarchies</h2>
<p>Similar to Scala‚Äôs <code>sealed trait</code>s:</p>
<ul>
<li><del><code>class</code>es, not supported for <code>interface</code>s</del> Supported since <a href="https://kotlinlang.org/docs/whatsnew15.html#sealed-interfaces">Kotlin 1.5.0</a></li>
<li>subtypes must be defined inside the sealed class</li>
<li>sealed hierarchies proved <em>exhaustive checking</em> inside <code>where</code> clauses</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">sealed</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Booze</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Rum</span> : Booze()
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Whisky</span> : Booze()
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Vodka</span> : Booze()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">goGetMeSome</span>(beverage: Booze) = <span style="color:#080;font-weight:bold">when</span> (beverage) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">is</span> <span style="color:#b06;font-weight:bold">Booze</span>.Rum -&gt; <span style="color:#d20;background-color:#fff0f0">"Diplomatico"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">is</span> <span style="color:#b06;font-weight:bold">Booze</span>.Whisky -&gt; <span style="color:#d20;background-color:#fff0f0">"Caol Ila"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">is</span> <span style="color:#b06;font-weight:bold">Booze</span>.Vodka -&gt; <span style="color:#d20;background-color:#fff0f0">"Zubrowka"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>goGetMeSome(<span style="color:#b06;font-weight:bold">Booze</span>.Rum())
</span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-3">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="nested-and-inner-classes">Nested and inner classes</h2>
<ul>
<li>Nesting a class inside another does not allow access to outer members
<ul>
<li>It‚Äôs equivalent to a Java‚Äôs <code>static</code> inner class</li>
</ul>
</li>
<li>To create an inner class, the <code>inner</code> modifier must be explicit</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Outer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">readMeIfYouCan</span> = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Nested</span> { <span style="color:#080;font-weight:bold">init</span> { println(readMeIfYouCan) } } <span style="color:#888">// error: unresolved reference: readMeIfYouCan
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Outer</span> { <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Nested</span>() }
</span></span><span style="display:flex;"><span><span style="color:#b06;font-weight:bold">Outer</span>.Nested() <span style="color:#888">// OK
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Outer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">readMeIfYouCan</span> = <span style="color:#00d;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">inner</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Inner</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">init</span> { println(readMeIfYouCan) } <span style="color:#888">// ok
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#b06;font-weight:bold">Outer</span>.Inner() <span style="color:#888">// error: constructor of inner class Inner can be called only with receiver of containing class
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>Outer().Inner() <span style="color:#888">// OK
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-4">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="enum-classes">Enum classes</h2>
<p>Same as Java, with Kotlin syntax</p>
<h2 id="object-expressions">Object expressions</h2>
<p><code>object</code> expressions replace anonymous classes</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">first</span>(): Unit
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">second</span>(): Unit
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">object</span> <span style="color:#a61717;background-color:#e3d2d2">: </span><span style="color:#b06;font-weight:bold">Test</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">first</span>() { }
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">second</span>() { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-5">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="type-aliases">Type aliases</h2>
<ul>
<li>Types can be aliased</li>
<li>Only at the top level</li>
<li>Type aliases in Kotlin <strong>are not</strong> Scala‚Äôs <code>type</code> definitions</li>
<li>Kotlin has no equivalent of Scala‚Äôs <code>type</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">typealias</span> Drivers = Pair&lt;String, String&gt;
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">typealias</span> Team = Pair&lt;String, Drivers&gt;
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">typealias</span> Formula1 = Map&lt;String, Team&gt;
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`f1 2020`</span> = mapOf(
</span></span><span style="display:flex;"><span>    Team(<span style="color:#d20;background-color:#fff0f0">"Ferrari"</span>, Drivers(<span style="color:#d20;background-color:#fff0f0">"Vettel"</span>, <span style="color:#d20;background-color:#fff0f0">"Leclerc"</span>)),
</span></span><span style="display:flex;"><span>    Team(<span style="color:#d20;background-color:#fff0f0">"RedBull"</span>, Drivers(<span style="color:#d20;background-color:#fff0f0">"Versbatten"</span>, <span style="color:#d20;background-color:#fff0f0">"Albon"</span>)),
</span></span><span style="display:flex;"><span>    Team(<span style="color:#d20;background-color:#fff0f0">"Merdeces"</span>, Drivers(<span style="color:#d20;background-color:#fff0f0">"Hamilton"</span>, <span style="color:#d20;background-color:#fff0f0">"Bottas"</span>)),
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#a61717;background-color:#e3d2d2">`</span>f1 <span style="color:#00d;font-weight:bold">2020</span><span style="color:#a61717;background-color:#e3d2d2">`</span> <span style="color:#888">// Map&lt;String, Pair&lt;String, Pair&lt;String, String&gt;&gt;&gt;
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-6">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="delegation">Delegation</h2>
<blockquote>
<p><strong>Favour composition over inheritance</strong><br>
<code>A</code> should extend <code>B</code> only if <code>A</code> truly ‚Äòis-a‚Äô a <code>B</code>,
if not, <em>use composition</em> instead,
which means <code>A</code> should hold a reference of <code>B</code> and <em>expose a simpler API</em>.
<cite> <em>J. Bloch, Effective Java, Item 16</em></cite></p>
</blockquote>
<p><strong>Delegation</strong> is one of the mechanisms to implement composition,
see the <a href="https://en.wikipedia.org/wiki/Delegation_pattern">delegation pattern</a>
<br>
Delegation is often verbose and very mechanic in implementation</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">surname</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: String)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Exam</span> : MutableCollection&lt;Student&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">representation</span> = mutableListOf&lt;Student&gt;()
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">add</span>(e E) = representation.add(e)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">addAll</span>(e E) = representation.addAll(e)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">clear</span>() = representation.clear()
</span></span><span style="display:flex;"><span>    ... <span style="color:#888">// BOOOOOOORING
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-7">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="delegation-via-by">Delegation via <code>by</code></h2>
<p>Kotlin supports delegation at the language level</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">surname</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: String)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Exam</span> : MutableCollection&lt;Student&gt; <span style="color:#080;font-weight:bold">by</span> mutableListOf&lt;Student&gt;() {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">register</span>(name: String, surname: String, id: String) = add(Student(name, surname, id))
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = toList().toString() <span style="color:#888">// No access to the delegate! `toString` unavailable!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">exam</span> = Exam()
</span></span><span style="display:flex;"><span>exam.register(<span style="color:#d20;background-color:#fff0f0">"Luca"</span>, <span style="color:#d20;background-color:#fff0f0">"Ghiotto"</span>, <span style="color:#d20;background-color:#fff0f0">"00000025"</span>)
</span></span><span style="display:flex;"><span>exam <span style="color:#888">// [Student(name=Luca, surname=Ghiotto, id=00000025)]
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>exam.clear()
</span></span><span style="display:flex;"><span>exam <span style="color:#888">// []
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-8">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="delegated-properties-and-variables">Delegated properties and variables</h2>
<p>Properties and variables can be delegated as well
<br>
some delegates are built-in, e.g. <code>lazy</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">someLazyString</span> <span style="color:#080;font-weight:bold">by</span> lazy {
</span></span><span style="display:flex;"><span>    println(<span style="color:#d20;background-color:#fff0f0">"I'm initializing myself"</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#d20;background-color:#fff0f0">"I'm intialized"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>println(<span style="color:#d20;background-color:#fff0f0">"Doing stuff"</span>)
</span></span><span style="display:flex;"><span>println(someLazyString) <span style="color:#888">// "I'm initializing myself" gets printed here
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-9">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="delegation-via-maps">Delegation via maps</h2>
<p>Class properties can be stored in an appropriate <code>Map</code>
<br>
Useful when dealing with dynamic languages or untyped serialization (e.g. JSON or YAML)</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">fromJson</span> = mapOf(<span style="color:#d20;background-color:#fff0f0">"name"</span> to <span style="color:#d20;background-color:#fff0f0">"John Smith"</span>, <span style="color:#d20;background-color:#fff0f0">"birthYear"</span> to <span style="color:#00d;font-weight:bold">2020</span>)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Person</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">jsonRepresentation</span>: Map&lt;String, Any&gt;) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span> <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">birthYear</span>: Int <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$name</span><span style="color:#d20;background-color:#fff0f0"> born in </span><span style="color:#33b;background-color:#fff0f0">$birthYear</span><span style="color:#d20;background-color:#fff0f0">"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>Person(fromJson)
</span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-10">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="delegation-via-maps-and-mutability">Delegation via maps and mutability</h2>
<p>In case of mutable properties, a <code>MutableMap</code> is required as delegate</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">janesJson</span>: MutableMap&lt;String, Any&gt; = mutableMapOf(<span style="color:#d20;background-color:#fff0f0">"name"</span> to <span style="color:#d20;background-color:#fff0f0">"Jane Smith"</span>, <span style="color:#d20;background-color:#fff0f0">"birthYear"</span> to <span style="color:#00d;font-weight:bold">1999</span>)
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutablePerson</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">jsonRepresentation</span>: MutableMap&lt;String, Any&gt;) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">name</span> <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">birthYear</span>: Int <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$name</span><span style="color:#d20;background-color:#fff0f0"> born in </span><span style="color:#33b;background-color:#fff0f0">$birthYear</span><span style="color:#d20;background-color:#fff0f0">"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">jane</span> = MutablePerson(janesJson)
</span></span><span style="display:flex;"><span>jane.toString()
</span></span><span style="display:flex;"><span>jane.name = <span style="color:#d20;background-color:#fff0f0">"Janet Smitherson"</span>
</span></span><span style="display:flex;"><span>jane.toString()
</span></span><span style="display:flex;"><span>janesJson <span style="color:#888">// Does it change? <span class="fragment " style="color: #888;">{name=Janet Smitherson, birthYear=1999} -- YES! Bidirectional</span>
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-11">Kotlin 201 ‚Äì Advanced OOP</h1>
<h2 id="custom-delegates">Custom delegates</h2>
<p>A valid delegate for a <code>val</code> is a <code>class</code> with a method:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">getValue</span>(thisRef: T, <span style="color:#080;font-weight:bold">property</span>: KProperty&lt;*&gt;): R
</span></span></code></pre></div><p>where T is the ‚Äúowner‚Äù type, and R is the type of the property</p>
<p>A valid delegate for a <code>var</code> must also have a <code>setValue</code> method:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">setValue</span>(thisRef: T, <span style="color:#080;font-weight:bold">property</span>: KProperty&lt;*&gt;, <span style="color:#080;font-weight:bold">value</span>: P): R
</span></span></code></pre></div><p>where T and R are the same as in <code>getValue</code>, and P is a supertype of R</p>
</section><section>
<h1 id="kotlin-202----functional-kotlin">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="lambda-expressions">Lambda expressions</h2>
<p>Kotlin lambda expression‚Äôs syntax is inspired by Groovy
<br>
and is similar to Smalltalk / Ceylon / Xtend / Ruby as well</p>
<ul>
<li>Enclosing an expression in curly brackets creates a lambda expression</li>
<li>Parameters are listed <em>inside</em> the brackets, a <code>-&gt;</code> separates them from the body</li>
<li>If there is one single parameter, it can be unspecified and referred with the keyword <code>it</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">myLambda</span> = {
</span></span><span style="display:flex;"><span>    println(<span style="color:#d20;background-color:#fff0f0">"Hey I'm computing"</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">whatsMyReturnType</span>() = { 
</span></span><span style="display:flex;"><span>    <span style="color:#d20;background-color:#fff0f0">"A string"</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>myLambda.invoke() <span style="color:#888">// Java-style invocation
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>myLambda() <span style="color:#888">// Decent-style invocation (invoke is an operator!)
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>myLambda()() <span style="color:#888">// Guess <span class="fragment " style="color: #888;">error: expression 'myLambda()' of type 'Unit' cannot be invoked as a function.</span>
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>whatsMyReturnType() <span style="color:#888">// Guess <span class="fragment " style="color: #888;">Subtle, but the compiler raises warnings</span>
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>whatsMyReturnType()() <span style="color:#888">// Guess <span class="fragment " style="color: #888;">A string</span>
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-1">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="function-type-literals">Function type literals</h2>
<p>Just as Scala, Kotlin supports function type literals
<br>
No need for verbose interfaces such as <code>Function&lt;T, R&gt;</code>, <code>BiConsumer&lt;T, R&gt;</code>, etc.</p>
<p>Function type literals have parameter types in parentheses, a <code>-&gt;</code>, and the return type</p>
<ul>
<li><code>() -&gt; Any</code> ‚Äì 0-ary function returning <code>Any</code></li>
<li><code>(String) -&gt; Any</code> ‚Äì Unary function taking a <code>String</code> and returning <code>Any</code></li>
<li><code>(String, Int) -&gt; Unit</code> ‚Äì Binary function taking a <code>String</code> and an <code>Int</code> and returning <code>Unit</code></li>
<li><code>(String, Int?) -&gt; Any?</code> ‚Äì Binary function taking a <code>String</code> and a nullable <code>Int?</code> returning a nullable <code>Any?</code></li>
</ul>
<p>Function type literals allow for writing cleaner <em>higher-order functions</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span>, <span style="color:#b06;font-weight:bold">I</span>, <span style="color:#b06;font-weight:bold">R</span>&gt; <span style="color:#06b;font-weight:bold">compose</span>(f: (I) -&gt; R, g: (T) -&gt; I): (T) -&gt; R = { f(g(<span style="color:#080;font-weight:bold">it</span>)) }
</span></span><span style="display:flex;"><span>compose({v: Int -&gt; v * v}, {v: Double -&gt; v.toInt()})(<span style="color:#00d;font-weight:bold">3.9</span>) <span style="color:#888">// 9
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-2">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="function-references">Function references</h2>
<p>Functions can be referred by using <code>::</code>
<br>
the left operand is the receiver (if present)
<br>
the right operand is the function name</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span>, <span style="color:#b06;font-weight:bold">I</span>, <span style="color:#b06;font-weight:bold">R</span>&gt; <span style="color:#06b;font-weight:bold">compose</span>(f: (I) -&gt; R, g: (T) -&gt; I): (T) -&gt; R = { f(g(<span style="color:#080;font-weight:bold">it</span>)) }
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">square</span>(v: Int) = v * v
</span></span><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">floor</span>(v: Double) = v.toInt()
</span></span><span style="display:flex;"><span>compose(::square, ::floor)(<span style="color:#00d;font-weight:bold">3.9</span>)
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-3">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="the-trailing-lambda-convention">The <strong>trailing lambda</strong> convention</h2>
<p>A simple special rule that enables very elegant syntactic forms:
<br>
<em>if a lambda expression is the last parameter in a function call</em>
<br>
<em>then it can be placed outside of the parentheses</em></p>
<p>If used correctly, feels like adding custom blocks to a language</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span> <span style="color:#888">// Java's thread + trailing lambda + SAM conversion
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">delayed</span>(delay: Long = <span style="color:#00d;font-weight:bold">1000L</span>, operation: () -&gt; Unit) = Thread {
</span></span><span style="display:flex;"><span>    <span style="color:#b06;font-weight:bold">Thread</span>.sleep(delay)
</span></span><span style="display:flex;"><span>    operation()
</span></span><span style="display:flex;"><span>}.start()
</span></span><span style="display:flex;"><span>println(<span style="color:#d20;background-color:#fff0f0">"Start"</span>)
</span></span><span style="display:flex;"><span><span style="color:#888">// Now we have a delayed block!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>delayed {
</span></span><span style="display:flex;"><span>    println(<span style="color:#d20;background-color:#fff0f0">"I was waiting"</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>delayed(<span style="color:#00d;font-weight:bold">300</span>) { println(<span style="color:#d20;background-color:#fff0f0">"I wait less"</span>) }
</span></span><span style="display:flex;"><span>println(<span style="color:#d20;background-color:#fff0f0">"Finished"</span>)
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-4">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="closures">Closures</h2>
<p>Closures are supported
<br>
They are allowed on <code>var</code>s as well as on <code>val</code>s</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#888">// Side effecting from functional manipulation is bad though
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">sum</span> = <span style="color:#00d;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>(<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">100</span>).map {
</span></span><span style="display:flex;"><span>    sum += <span style="color:#080;font-weight:bold">it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">it</span> * <span style="color:#00d;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>sum
</span></span><span style="display:flex;"><span>sum == (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">100</span>).sum()
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-5">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="flow-control-with-lambdas">Flow control with lambdas</h2>
<p>Kotlin rule: <code>return</code> returns from the closest <em>named</em> <code>fun</code>ction</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">breakingFlow</span>(): List&lt;Int&gt; = (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">10</span>).toList().map {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#080;font-weight:bold">it</span> &gt; <span style="color:#00d;font-weight:bold">4</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">return</span> (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#080;font-weight:bold">it</span>).toList() <span style="color:#888">// returns from breakingFlow
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">it</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>breakingFlow()
</span></span></code></pre></div><p>A <em>qualified <code>return</code></em> can be used to return from lambdas:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">breakingFlow</span>(): List&lt;Int&gt; = (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">10</span>).toList().map {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">if</span> (<span style="color:#080;font-weight:bold">it</span> &gt; <span style="color:#00d;font-weight:bold">4</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-weight:bold">return</span><span style="color:#555">@map</span> <span style="color:#080;font-weight:bold">it</span> * <span style="color:#00d;font-weight:bold">10</span> <span style="color:#888">// returns from the lambda
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">it</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>breakingFlow()
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-6">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="destructuring-lambda-parameters">Destructuring lambda parameters</h2>
<p>Lambda parameters can be destructured</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span>mapOf(<span style="color:#00d;font-weight:bold">46</span> to <span style="color:#d20;background-color:#fff0f0">"Rossi"</span>, <span style="color:#00d;font-weight:bold">4</span> to <span style="color:#d20;background-color:#fff0f0">"Dovizioso"</span>).map { (number, rider) -&gt;
</span></span><span style="display:flex;"><span>    <span style="color:#888">// destructured Pair
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$rider</span><span style="color:#d20;background-color:#fff0f0"> has number </span><span style="color:#33b;background-color:#fff0f0">$number</span><span style="color:#d20;background-color:#fff0f0">"</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-7">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="extension-functions">Extension functions</h2>
<p>Kotlin allows to extend any type capabilities from anywhere
<br>
via <strong>extension functions</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">String</span>.containsBatman(): Boolean = <span style="color:#d20;background-color:#fff0f0">".*b.*a.*t.*m.*a.*n.*"</span>.toRegex().matches(<span style="color:#080;font-weight:bold">this</span>)
</span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">"battere le mani"</span>.containsBatman() <span style="color:#888">// true
</span></span></span></code></pre></div><p>Inside extension functions, the <em>receiver</em> of the method is overridden
<br>
Any type, including nullables, can be extended
<br>
<code>object</code>s and <code>companion</code>s can be extended as well</p>
<p><strong>IMPORTANT</strong>: calls to extension methods are resolved <em>statically</em>.
<br>
Namely, <em>the receiver type is determined at compile time</em>.</p>
<p><strong>IMPORTANT/2</strong>: Extensions cannot shadow members,
<em>members always take priority</em></p>
</section><section>
<h1 id="kotlin-202----functional-kotlin-8">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="extension-properties">Extension properties</h2>
<p>Same as functions, but for properties</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">String</span>.containsBatman <span style="color:#080;font-weight:bold">get</span>(): Boolean = <span style="color:#d20;background-color:#fff0f0">".*b.*a.*t.*m.*a.*n.*"</span>.toRegex().matches(<span style="color:#080;font-weight:bold">this</span>)
</span></span><span style="display:flex;"><span><span style="color:#d20;background-color:#fff0f0">"battere le mani"</span>.containsBatman <span style="color:#888">// true
</span></span></span></code></pre></div><p>Note:</p>
<ol>
<li>extension properties cannot have backing fields</li>
<li>extension properties can‚Äôt get initialized,
their behaviour is entirely specified by <code>get</code> and <code>set</code> accessors.</li>
</ol>
</section><section>
<h1 id="kotlin-202----functional-kotlin-9">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="extension-function-type-literals">Extension function type literals</h2>
<p>Extensions functions are‚Ä¶ functions, like any other
<br>
as such, their type can be legally expressed by:</p>
<ul>
<li>prefixing the *receiver type</li>
<li>following by a <code>.</code></li>
<li>then list parameters and return types as for any function type literal</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#888">// Extension function taking an extension function as parameter
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span>&gt; <span style="color:#06b;font-weight:bold">MutableList</span>&lt;T&gt;.configure(configuration: MutableList&lt;T&gt;.() -&gt; Unit): MutableList&lt;T&gt; {
</span></span><span style="display:flex;"><span>    configuration()
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">this</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#888">// We are creating a configuration block!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>mutableListOf&lt;String&gt;().configure {
</span></span><span style="display:flex;"><span>    add(<span style="color:#d20;background-color:#fff0f0">"Pippo"</span>)
</span></span><span style="display:flex;"><span>    add(<span style="color:#d20;background-color:#fff0f0">"Pluto"</span>)
</span></span><span style="display:flex;"><span>    add(<span style="color:#d20;background-color:#fff0f0">"Paperino"</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>‚Ä¶sounds easy to write DSLs‚Ä¶</p>
</section><section>
<h1 id="kotlin-202----functional-kotlin-10">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="extension-members-and-implicit-receivers">Extension members and implicit receivers</h2>
<p>When extensions are defined as members, there are multiple <em>implicit recevers</em>:</p>
<ol>
<li><strong>dispatch receiver</strong>: the <code>object</code> or instance of the <code>class</code> in which the extension is declared</li>
<li><strong>extension receiver</strong> the instance of the <em>receiver type</em> of the extension is called</li>
</ol>
<p><em>Extension receivers have priority</em>, dispatch receivers access requires the <em>qualified <code>this</code></em> syntax
<br></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">Batman</span> { <span style="color:#888">// the Batman object is the dispatch receiver
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span> = <span style="color:#d20;background-color:#fff0f0">"Batman"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">String</span>.<span style="color:#b06;font-weight:bold">Companion</span>.intro <span style="color:#080;font-weight:bold">get</span>() = generateSequence { <span style="color:#b06;font-weight:bold">Double</span>.NaN } <span style="color:#888">// String.Companion is extension receiver
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        .take(<span style="color:#00d;font-weight:bold">10</span>)
</span></span><span style="display:flex;"><span>        .joinToString(separator = <span style="color:#d20;background-color:#fff0f0">""</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">String</span>.withBatman() = <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$this</span><span style="color:#d20;background-color:#fff0f0"> </span><span style="color:#33b;background-color:#fff0f0">${this@Batman.name}</span><span style="color:#d20;background-color:#fff0f0">!"</span> <span style="color:#888">// Qualified this access to the dispatch receiver
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-11">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="dsl-scope-control-via-extension-members">DSL scope control via extension members</h2>
<p>Extension members are visible only when the dispatch receiver is the type where the extensions were defined
<br>
This enables a powerful form of <em>scope control</em></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">Batman</span> { <span style="color:#888">// Batman is the dispatch receiver
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span> = <span style="color:#d20;background-color:#fff0f0">"Batman"</span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">String</span>.<span style="color:#b06;font-weight:bold">Companion</span>.intro <span style="color:#080;font-weight:bold">get</span>() = generateSequence { <span style="color:#b06;font-weight:bold">Double</span>.NaN } <span style="color:#888">// String is extension receiver
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>        .take(<span style="color:#00d;font-weight:bold">10</span>)
</span></span><span style="display:flex;"><span>        .joinToString(separator = <span style="color:#d20;background-color:#fff0f0">""</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">String</span>.withBatman() = <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">$this</span><span style="color:#d20;background-color:#fff0f0"> </span><span style="color:#33b;background-color:#fff0f0">${this@Batman.name}</span><span style="color:#d20;background-color:#fff0f0">!"</span> <span style="color:#888">// Qualified this access to the dispatch receiver
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span><span style="display:flex;"><span><span style="color:#888">// Extension members are actual members! They require a receiver!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#b06;font-weight:bold">String</span>.intro.withBatman() <span style="color:#888">// error: unresolved reference: intro
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;<span style="color:#b06;font-weight:bold">T</span>, <span style="color:#b06;font-weight:bold">R</span>&gt; <span style="color:#06b;font-weight:bold">insideTheScopeOf</span>(<span style="color:#080;font-weight:bold">receiver</span>: T, method: <span style="color:#b06;font-weight:bold">T</span>.() -&gt; R): R = <span style="color:#080;font-weight:bold">receiver</span>.method() 
</span></span><span style="display:flex;"><span>insideTheScopeOf(Batman) { <span style="color:#888">// inside this function, Batman is the dispatch receiver!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>    <span style="color:#b06;font-weight:bold">String</span>.intro.withBatman() <span style="color:#888">// OK!
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>}
</span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-12">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="scope-functions">Scope functions</h2>
<p>Kotlin provides a number of built-in functions that run a lambda expression in a custom scope:</p>
<ul>
<li>by changing the receiver (as we‚Äôve done with <code>insideTheScopeOf</code> in the previous slide)</li>
<li>by creating an implicit <code>it</code> parameter</li>
<li>by changing the return type</li>
</ul>
</section><section>
<h1 id="kotlin-202----functional-kotlin-13">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="scope-functions-1">Scope functions</h2>
<h4 id="let--tt---r---r"><code>let</code> : <code>T.((T) -&gt; R) -&gt; R</code></h4>
<p>Can be invoked on an object, passing a lambda expression.
<br>
The method receiver is bound to the lambda parameter
<br>
the return type is the result of the function</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1.l</span>et { <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${it + 1}</span><span style="color:#d20;background-color:#fff0f0">1"</span> } <span style="color:#888">// 21: String
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1.l</span>et { one -&gt; <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${one + 1}</span><span style="color:#d20;background-color:#fff0f0">1"</span> } <span style="color:#888">// Same as above: it's a normal lambda
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-14">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="scope-functions-2">Scope functions</h2>
<h4 id="run--tt---r---r"><code>run</code> : <code>T.(T.() -&gt; R) -&gt; R</code></h4>
<p>Can be invoked on an object, passing a lambda expression.
<br>
The method receiver is bound to the implicit receiver <code>this</code>
<br>
the return type is the result of the function</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1.</span>run { <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${this + 1}</span><span style="color:#d20;background-color:#fff0f0">1"</span> } <span style="color:#888">// 21: String
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-15">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="scope-functions-3">Scope functions</h2>
<h4 id="with--t---r---r"><code>with</code> : <code>(T.() -&gt; R) -&gt; R</code></h4>
<p>Non-extension version of <code>run</code>,
the context object is passed as first parameter
<br>
The method receiver is bound to the implicit receiver <code>this</code>
<br>
the return type is the result of the function</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span>with(<span style="color:#00d;font-weight:bold">1</span>) { <span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${this + 1}</span><span style="color:#d20;background-color:#fff0f0">1"</span> } <span style="color:#888">// 21: String
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-16">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="scope-functions-4">Scope functions</h2>
<h4 id="apply--tt---unit---t"><code>apply</code> : <code>T.(T.() -&gt; Unit) -&gt; T</code></h4>
<p>Similar to <code>run</code>,
but returns the context object
<br>
Used to cause side effects from a specific context,
and returning the original object</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1.</span>apply { println(<span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${this + 1}</span><span style="color:#d20;background-color:#fff0f0">1"</span>) } <span style="color:#888">// Prints 21, returns 1
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span>mutableListOf&lt;Int&gt;().apply {
</span></span><span style="display:flex;"><span>    addAll((<span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">10</span>).toList())
</span></span><span style="display:flex;"><span>} <span style="color:#888">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</span></span></span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-17">Kotlin 202 ‚Äì Functional Kotlin</h1>
<h2 id="scope-functions-5">Scope functions</h2>
<h4 id="also--tt---unit---t"><code>also</code> : <code>T.((T) -&gt; Unit) -&gt; T</code></h4>
<p>Similar to <code>apply</code>, but does not change the context,
<br>
the context object is bound to the first lambda parameter
<br>
Used to cause side effects and returning the original object</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="nohighlight" data-noescape=""><span style="display:flex;"><span><span style="color:#00d;font-weight:bold">1.</span>also { println(<span style="color:#d20;background-color:#fff0f0">"</span><span style="color:#33b;background-color:#fff0f0">${it + 1}</span><span style="color:#d20;background-color:#fff0f0">1"</span>) } <span style="color:#888">// Prints 21, returns 1
</span></span></span></code></pre></div></section><section>
<h1 id="extra-content">Extra content</h1>
<p>A lot of language details have been left out of this guide, non complete list:</p>
<ul>
<li>arrays</li>
<li>enum classes</li>
<li>spread operator</li>
<li>annotations</li>
<li><code>noinline</code> and <code>crossinline</code></li>
<li>coroutines</li>
<li>interoperatibility with Java</li>
<li><code>inline class</code>es</li>
</ul>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-hugo/object-assign.js"></script>

<a href="/Course-Laboratory-of-Software-Systems/reveal-js/dist/print/" id="print-location" style="display: none;"></a>

<script type="application/json" id="reveal-hugo-site-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"height":"900","history":true,"mermaid":[{"fontFamily":"Inconsolata","gitGraph":{"mainBranchName":"master","rotateCommitLabel":true},"startOnLoad":false,"theme":"default","useMaxWidth":false}],"pdfseparatefragments":false,"slide_number":true,"theme":"white","transition":"slide","transition_speed":"fast","width":"1440"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"custom_theme_options":{"enablesourcemap":true,"targetpath":"css/custom-theme.css"},"transition":"slide","transition_speed":"fast"}</script>

<script src="/Course-Laboratory-of-Software-Systems/reveal-js/dist/reveal.js"></script>


  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/zoom/zoom.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/notes/notes.js"></script>
  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/notes/notes.js"></script>




<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };

  var revealHugoPlugins = { 
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealZoom ]
   };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams),
    camelize(revealHugoPlugins));
  Reveal.initialize(options);
</script>










  <script src="https://cdn.jsdelivr.net/npm/mermaid@9.1.6/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({"fontFamily":"Inconsolata","gitGraph":{"mainBranchName":"master","rotateCommitLabel":true},"startOnLoad":false,"theme":"default","useMaxWidth":false});

    let render = (event) => {
      let mermaidElems = event.currentSlide.querySelectorAll('.mermaid');
      if (!mermaidElems.length){
          return
      }
      mermaidElems.forEach(mermaidElem => {
          let processed = mermaidElem.getAttribute('data-processed');
          if (!processed){
              
              mermaid.init(undefined, mermaidElem);
          }
      });
    };
    Reveal.addEventListener('slidechanged', render);
    Reveal.addEventListener('ready', render);
  </script>

    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>

<script type="text/javascript" id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<script>
  if (/.*?(\?|&)print-pdf/.test(window.location.toString())) {
      var ytVideos = document.getElementsByTagName("iframe")
      for (let i = 0; i < ytVideos.length; i++) {
          var videoFrame = ytVideos[i]
          var isYouTube = /^https?:\/\/(www.)youtube\.com\/.*/.test(videoFrame.src)
          if (isYouTube) {
              console.log(`Removing ${videoFrame.src}`)
              var parent = videoFrame.parentElement
              videoFrame.remove()
              var p = document.createElement('p')
              p.append(
                  document.createTextNode(
                      "There was an embedded video here, but it is disabled in the printed version of the slides."
                  )
              )
              p.append(document.createElement('br'))
              p.append(
                  document.createTextNode(
                      `Visit instead ${
                          videoFrame.src
                      } or ${
                          videoFrame.src.replace(
                              /(^https?:\/\/(www.)youtube\.com)\/(embed\/)(\w+).*/,
                              "https://www.youtube.com/watch?v=$4"
                          )
                      }`
                  )
              )
              parent.appendChild(p)
          }
      }
  }
</script>

    
  

</body></html>