<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>Introduction to Laboratory of Software Systems</title>
<meta name="description" content="Description of the course">
<meta name="author" content="Danilo Pianini">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reset.css">
<link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reveal.css">
  <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/css/custom-theme.min.1e2604bf0c24e445faa3ae7d68b2f0146c34bc9e7b9bd6aee2b7187115560e96.css" id="theme"><link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/highlight-js/default.min.css">
    
<link rel="stylesheet" href="https://gitcdn.link/repo/DanySK/css-blur-animation/master/blur.css">
<link href='https://fonts.googleapis.com/css?family=Roboto Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Oxygen Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Ubuntu Mono' rel='stylesheet'>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="hahahugoshortcode-s0-hbhb">Laboratory of Software Systems</h1>
<h2 id="kotlin-for-scala-developers">Kotlin (for Scala developers)</h2>
<h3 id="danilo-pianinimailtodanilopianiniuniboit"><a href="mailto:danilo.pianini@unibo.it">Danilo Pianini</a></h3>
2020-09-04

</section><section>
<h1 id="why-kotlin">Why Kotlin</h1>
<p>JetBrains-made modern programming language</p>
<ul>
<li>Focused on &ldquo;practical use&rdquo; (whatever that means)</li>
</ul>
<p>Gaining momentum since Google adopted is as <em>official Android language</em> (along with Java and C++)</p>
<p>Clearly inspired by a mixture of Java, C#, Scala, and Groovy</p>
<p><strong>In this course</strong> &ndash; we&rsquo;ll need it for Gradle and <em>internal</em> domain specific languages</p>
</section><section>
<h1 id="philosophy-kotlin-vs-scala">Philosophy: Kotlin vs. Scala</h1>
<p><strong>Sca</strong><em>la</em> is a <strong>scalable</strong> <em>language</em></p>
<ul>
<li>Few core constructs that enable a huge variety of programming patterns</li>
<li>Born in academia</li>
<li>State of the art type checker with advanced features
<ul>
<li>Higher Kinded Types</li>
<li>Type lambdas</li>
<li>Enough to do type programming&hellip;</li>
</ul>
</li>
</ul>
<p><strong>Kotlin</strong> is somewhat <em>a better java</em></p>
<ul>
<li>Born in industry, for the industry</li>
<li>Many more &ldquo;core&rdquo; constructs and keywords than Scala</li>
<li>Focused on getting productive quickly and reducing programming errors</li>
<li>Focus on multi-target (can compile towards JVM, JavaScript, and native)
<ul>
<li>Scala can as well by the way</li>
<li>Kotlin puts more care into bidirectional compatibility</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101">Kotlin 101</h1>
<h2 id="defining-functions-constant-variables">Defining functions, constant, variables</h2>
<p>Similar to Scala. The keyword <code>def</code> is replaced by <code>fun</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">x</span> = <span style="color:#00d;font-weight:bold">10</span> <span style="color:#888">// constant
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">y</span> = <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// variable, can be reassigned
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// function definition, single expression
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">bar</span>(): Int { <span style="color:#888">// same as above with multiple expression
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// requires a return in this form...
</span><span style="color:#888"></span>}
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baz</span>() { } <span style="color:#888">// Unless it returns Unit
</span><span style="color:#888"></span>
</code></pre></div></section><section>
<h1 id="kotlin-101-1">Kotlin 101</h1>
<h2 id="function-parameters-and-return-types">Function parameters and return types</h2>
<p>Much like Scala:</p>
<ul>
<li>All parameters are named, but can be invoked positionally as well</li>
<li>Parameters can have defaults</li>
<li>Types are annotatedd after the parameter name</li>
<li>Invocation can be positional or by name, with the rule that once a named parameter is used, subsequent parameters must be named as well</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>(a: Int = <span style="color:#00d;font-weight:bold">0</span>, b: String = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>): Int = TODO() <span style="color:#888">// TODO() is a builtin function throwing a `NotImplementedError`
</span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, positional
</span><span style="color:#888"></span>foo(a = <span style="color:#00d;font-weight:bold">1</span>, b = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, named
</span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>, b = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, hybrid
</span><span style="color:#888"></span>foo(a = <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// error: no value passed for parameter &#39;b&#39;
</span><span style="color:#888"></span>foo() <span style="color:#888">// OK, both defaults
</span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#888">// OK, same as foo(1, &#34;foo&#34;)
</span><span style="color:#888"></span>foo(<span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// error: type mismatch: inferred type is String but Int was expected
</span><span style="color:#888"></span>foo(b = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, same as foo(0, &#34;bar&#34;)
</span></code></pre></div></section><section>
<h1 id="kotlin-101-2">Kotlin 101</h1>
<h2 id="top-level-functions">Top level functions</h2>
<p>Kotlin supports top level functions</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() {
    ...
}
</code></pre></div><p>By contrast, Scala requires to put them in an <code>object</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">Foo</span> {
    <span style="color:#080;font-weight:bold">def</span> foo() {
        ...
    }
}
</code></pre></div><p>When targeting the JVM, Kotlin simply generates a <code>FileNameKt</code> class behind the scenes where the function is stored.
The behaviour can be controlled via annotations.</p>
</section><section>
<h1 id="kotlin-101-3">Kotlin 101</h1>
<h2 id="program-entry-point">Program entry point</h2>
<p>Naming a function <code>main</code> makes it a valid entry point:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>() = println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello World&#34;</span>) <span style="color:#888">// Valid entry point
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>(arguments: Array&lt;String&gt;) = println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello World&#34;</span>) <span style="color:#888">// Valid entry point
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>(arguments: Array&lt;String&gt;) {
    println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello World&#34;</span>) <span style="color:#888">// Return type is Unit, no need to return
</span><span style="color:#888"></span>} 
</code></pre></div></section><section>
<h1 id="kotlin-101-4">Kotlin 101</h1>
<h2 id="nullable-types">Nullable types</h2>
<p>Every Kotlin type exists in two forms: normal, and nullable (likely inspired by Ceylon).
<br/>
Nullable types are suffixed by a <code>?</code> and require special handling
<br/>
<code>null</code> can&rsquo;t be assigned to non nullable types!</p>
<ul>
<li>Nullables are the Kotlin way to deal with <code>Option</code> types</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">foo</span> = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span> <span style="color:#888">// Okay, type is String
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = foo <span style="color:#888">// Okay, normal types can be assigned to nullables
</span><span style="color:#888"></span>foo = baz <span style="color:#888">// error: type mismatch: inferred type is String? but String was expected
</span><span style="color:#888"></span>foo = <span style="color:#080;font-weight:bold">null</span> <span style="color:#888">// error: null can not be a value of a non-null type String
</span></code></pre></div></section><section>
<h1 id="kotlin-101-5">Kotlin 101</h1>
<h2 id="accessing-nullable-types">Accessing nullable types</h2>
<p>Nullable types memebers can&rsquo;t be accessed by <code>.</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz.length <span style="color:#888">// error: only safe (?.) or non-null asserted (!!.) calls are allowed...
</span><span style="color:#888">// on a nullable receiver of type String?
</span></code></pre></div><h3 id="safe-call-operator-">Safe call operator <code>?.</code></h3>
<p>Performs runtime access to a member of a nullable object if it&rsquo;s not <code>null</code>, otherwise returns <code>null</code></p>
<ul>
<li>Somewhat similar to Scala&rsquo;s <code>Option</code>'s <code>map</code> (but no monad involved)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz?.length <span style="color:#888">// returns 3, return type is &#34;Int?&#34;, in fact...
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: Int = baz?.length <span style="color:#888">// ...error: type mismatch: inferred type is Int? but Int was expected
</span><span style="color:#888"></span>baz = <span style="color:#080;font-weight:bold">null</span>
baz?.length <span style="color:#888">// returns null, return type is still &#34;Int?&#34;
</span></code></pre></div></section><section>
<h1 id="kotlin-101-6">Kotlin 101</h1>
<h3 id="non-null-assertion-">Non-null assertion <code>!!</code></h3>
<p>Also known as: <em>I want my code to break badly at runtime</em>
<br/></p>
<ul>
<li>Invalidates the whole point of having nullable types by asserting that the nullable object is not <code>null</code> at runtime</li>
<li>It should be <strong>never</strong> used
<ul>
<li>In fact its ugly syntax is so <em>ugly by purpose</em></li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz!!<span class='fragment '  style="color: #888;"> // Returns &#39;foo&#39;, type String (non nullable)</span>
baz!!.length<span class='fragment '  style="color: #888;"> // returns 3, return type is Int</span>
baz = <span style="color:#080;font-weight:bold">null</span>
baz!!<span class='fragment '  style="color: #888;"> // throws a KotlinNullPointerException, like the good ol&#39;times!</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-7">Kotlin 101</h1>
<h3 id="elvis-operator-">Elvis operator <code>?:</code></h3>
<p>Yeah it&rsquo;s actually named after Elvis Presley due to his haircut ðŸ˜‰
<br/></p>
<ul>
<li>Returns the left operand if it&rsquo;s not <code>null</code>, otherwise the right one</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz ?: <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span> <span style="color:#888">// Returns &#34;foo&#34;, type String
</span><span style="color:#888"></span>baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// returns 3, return type is Int
</span><span style="color:#888"></span>baz = <span style="color:#080;font-weight:bold">null</span>
baz ?: <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span> <span style="color:#888">// Returns &#34;bar&#34;, type String
</span><span style="color:#888"></span>baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// returns 0, return type is Int
</span></code></pre></div></section><section>
<h1 id="kotlin-101-8">Kotlin 101</h1>
<h2 id="platform-types">Platform types</h2>
<p>Kotlin targets the JVM, JavaScript, and native code
<br/>
<em>None of them has nullable types!</em></p>
<p>Nullability is unknown for types coming from the target platform, how to deal with them?</p>
<ol>
<li><span class='fragment '
  >
  Always consider them nullable (safe, but very unpleasant)
</span></li>
<li><span class='fragment '
  >
  Always consider them non nullable (code is lightweight and nice, but unsafe)
</span></li>
</ol>
</section><section>
<h1 id="kotlin-101-9">Kotlin 101</h1>
<h2 id="platform-types-1">Platform types</h2>
<p>Kotlin considers all foreign values whose nullability is unknown as <em>platform types</em></p>
<ul>
<li>Their type is suffixed by <code>!</code> (e.g., <code>java.util.Date!</code>)</li>
<li>At first use, their type is <em>implicitly disambiguated</em> (either nullable or non-nullable)
<ul>
<li>Namely, platform types can be used as non-nullable&hellip;</li>
</ul>
</li>
<li>Runtime nullability checks are put in place by the compiler (<em>fail fast!</em>)
<ul>
<li>&hellip;but their actual nullablity is checked at use-site</li>
</ul>
</li>
<li>Platform types <em>can&rsquo;t be created</em> in Kotlin! They only come from interaction with &ldquo;platform code&rdquo;</li>
<li>If the target platform offers some way to assert nullability, Kotlin tries to use it
<ul>
<li>e.g., if a Java method/parameter is annotated with <code>@NotNull</code> (or similar common alternatives) it will be interpreted as a non-nullable type</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-10">Kotlin 101</h1>
<h2 id="type-hierarchy">Type hierarchy</h2>
<ul>
<li>In Java
<ul>
<li>top type: <code>Object</code></li>
<li>bottom type: no bottom type</li>
</ul>
</li>
<li>In Scala
<ul>
<li>top type: <code>Any</code></li>
<li>bottom type: <code>Nothing</code></li>
</ul>
</li>
<li>In Kotlin:
<ul>
<li>top type: <code><span class='fragment '
  >
  Any
</span></code></li>
<li>bottom type:</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-11">Kotlin 101</h1>
<h2 id="type-hierarchy-1">Type hierarchy</h2>
<ul>
<li>In Java
<ul>
<li>top type: <code>Object</code></li>
<li>bottom type: no bottom type</li>
</ul>
</li>
<li>In Scala
<ul>
<li>top type: <code>Any</code></li>
<li>bottom type: <code>Nothing</code></li>
</ul>
</li>
<li>In Kotlin:
<ul>
<li>top type: <del><code>Any</code></del> <code><span class='fragment '
  >
  Any?
</span></code></li>
<li>bottom type: <code><span class='fragment '
  >
  Nothing
</span></code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-12">Kotlin 101</h1>
<h2 id="booleans"><code>Boolean</code>s</h2>
<p>Exactly as Java/Scala, but with nullability:</p>
<ul>
<li><code>Boolean</code>: <code>true</code>/<code>false</code></li>
<li><code>Boolean?</code>: <code>true</code>/<code>false</code>/<code>null</code></li>
<li><code>&amp;&amp;</code>, <code>!!</code>, and <code>!</code> operators work for <em>non-nullable</em> <code>Boolean</code>s.</li>
</ul>
<p>Likewise Scala, boxing under the JVM is dealt with by the compiler
<br/>
<code>Boolean?</code> are always boxed (to be able to account for <code>null</code>)</p>
</section><section>
<h1 id="kotlin-101-13">Kotlin 101</h1>
<h2 id="numeric-types">Numeric types</h2>
<p>Same as Scala, +nullability, +<em>unsigned experimental types</em>:</p>
<ul>
<li><code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>
<ul>
<li>And nullable equivalents, always boxed under the JVM</li>
</ul>
</li>
<li><code>UByte</code>, <code>UShort</code>, <code>UInt</code>, <code>ULong</code></li>
</ul>
</section><section>
<h1 id="kotlin-101-14">Kotlin 101</h1>
<h2 id="issues-of-implicit-numeric-types-conversion">Issues of implicit numeric types conversion</h2>
<p>Implicit type conversion to &ldquo;bigger&rdquo; types is source of nasty errors when automatic boxing is involved.
<br/>
Consider the following Scala code:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> == <span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> <span style="color:#888">// false, OK, as every sane language
</span><span style="color:#888"></span><span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> equals <span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> <span style="color:#888">// true! Boxing + Singleton make equality inconsistent!
</span></code></pre></div><p>Another example:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> a<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Int</span> = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> b<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Long</span> = a
a == b <span style="color:#888">// true
</span><span style="color:#888"></span>a equals b <span style="color:#888">// false
</span></code></pre></div><p>This causes a chain of issues, as <code>==</code> and <code>equals</code> do a different job, as do <code>##</code> and <code>hashCode</code>: <code>Map</code>s can become very surprising!</p>
</section><section>
<h1 id="kotlin-101-15">Kotlin 101</h1>
<h2 id="numeric-type-conversions-in-kotlin">Numeric type conversions in Kotlin</h2>
<p>Kotlin numeric types are converted manually to prevent these issues:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">i</span>: Int = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = i<span class='fragment '  style="color: #888;"> // error: type mismatch: inferred type is Int but Long was expected</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = i.toLong()<span class='fragment '  style="color: #888;"> // OK</span>
i + l<span class='fragment '  style="color: #888;"> // OK, operators are overloaded</span>
l + i<span class='fragment '  style="color: #888;"> // OK, operators are overloaded</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-16">Kotlin 101</h1>
<h2 id="numeric-literals">Numeric literals</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1234567</span> <span style="color:#888">// Literal Int
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1</span>_234_567 <span style="color:#888">// Literal Int, underscored syntax (preferable)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">123L</span> <span style="color:#888">// Literal Long
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1.0</span> <span style="color:#888">// Literal Double
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">123</span>e4 <span style="color:#888">// Literal Double in scientific notation
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1</span>d <span style="color:#888">// Nope :)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1f</span> <span style="color:#888">// Literal Float
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1u</span> <span style="color:#888">// Literal UInt
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0123</span> <span style="color:#888">// error: unsupported [literal prefixes and suffixes] (no octal)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xCAFE</span> <span style="color:#888">// Hex literal Int
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xCAFEBABE</span> <span style="color:#888">// Hex literal Long (automatic, as it does not fit an Int)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0x0000000</span> <span style="color:#888">// Hex literal Int, even it&#39;d fit a Byte
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b1111111_11111111_11111111_11111111 <span style="color:#888">// Binary Int (Integer.MAX_INT)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b11111111_11111111_11111111_11111111 <span style="color:#888">// Binary Long
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b11111111_11111111_11111111_11111111u <span style="color:#888">// Binary UInt!
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xFFFF</span>_FFFF_FFFFu <span style="color:#888">// ULong
</span></code></pre></div></section><section>
<h1 id="kotlin-101-17">Kotlin 101</h1>
<h2 id="strings-and-templating">Strings and templating</h2>
<p>Spiced up version of Java strings, Groovy-style templating:</p>
<ul>
<li><code>$</code> begins a template expression</li>
<li>Curly brackets must be used to disambiguate in case of calls inside the template: <code>${}</code></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">batman</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Batman&#34;</span>
<span style="color:#888">// Groovy templating and Java-style concatenation both work
</span><span style="color:#888"></span><span style="color:#d20;background-color:#fff0f0">&#34;${Double.NaN}&#34;</span>.repeat(<span style="color:#00d;font-weight:bold">10</span>) + <span style="color:#d20;background-color:#fff0f0">&#34; $batman!&#34;</span><span class='fragment '  style="color: #888;"> // NaNNaNNaNNaNNaNNaNNaNNaNNaNaN Batman!</span>
<span style="color:#d20;background-color:#fff0f0">&#34;Batman is $batman.length characters long&#34;</span><span class='fragment '  style="color: #888;"> // Batman is Batman.length characters long</span>
<span style="color:#d20;background-color:#fff0f0">&#34;Batman is ${batman.length} characters long&#34;</span><span class='fragment '  style="color: #888;"> // Batman is 6 characters long</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-18">Kotlin 101</h1>
<h2 id="raw-strings">Raw Strings</h2>
<p>Triple-double-quoted strings are considered <em>raw strings</em></p>
<ul>
<li><code>\</code> is a normal character</li>
<li>newlines are intended as part of the string</li>
<li>Very handy for writing regular expressions</li>
<li><code>$</code>-templating still works
<ul>
<li>writing a dollar symbols requires some tricks</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">dante</span> = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;&#34;
</span><span style="color:#d20;background-color:#fff0f0">    Tanto gentile e tanto onesta pare
</span><span style="color:#d20;background-color:#fff0f0">    la donna mia quand&#39;ella altrui saluta,
</span><span style="color:#d20;background-color:#fff0f0">    ch&#39;ogne lingua devÃ¨n, tremando, muta
</span><span style="color:#d20;background-color:#fff0f0">    e li occhi non l&#39;ardiscon di guardare.
</span><span style="color:#d20;background-color:#fff0f0">    &#34;&#34;&#34;</span>.trimIndent() <span style="color:#888">// Indentation can be trimmed
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">finalWordsEndingInA</span> = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;&#34;\W*(\w*a)\W*${&#39;$&#39;}&#34;&#34;&#34;</span>.toRegex(RegexOption.MULTILINE) <span style="color:#888">// See how $ must be escaped
</span><span style="color:#888"></span>finalWordsEndingInA.findAll(dante).map { it.groups[<span style="color:#00d;font-weight:bold">1</span>]?.value }.toList() <span class='fragment '  style="color: #888;"> // [saluta, muta]</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-19">Kotlin 101</h1>
<h2 id="packages-and-imports">Packages and imports</h2>
<p>Same as Java, plus aliasing.
<br/>
Imports go at the top of file, no locally scoped imports as in Scala</p>
<ul>
<li>There are no <code>implicit</code>s in Kotlin, the <code>import</code> statement does not modify context</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">package</span> <span style="color:#b06;font-weight:bold">it.unibo.lss.experiments</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">it.unibo.lss.ddd.Entity</span> <span style="color:#888">// Available as Entity locally
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.company.someproduct.Entity</span> <span style="color:#080;font-weight:bold">as</span> SomeProductEntity <span style="color:#888">// Aliasing, accessible as SomeProductEntity
</span></code></pre></div></section><section>
<h1 id="kotlin-101-20">Kotlin 101</h1>
<h2 id="varargs">Varargs</h2>
<p>Functions can have a parameter marked as <code>vararg </code>, accepting multiple entries</p>
<ul>
<li>Typically the last one (but not mandatorily as in Java)</li>
<li>Maps to an `Array<out ></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">printall</span>(<span style="color:#080;font-weight:bold">vararg</span> strings: String) {
    strings.forEach { println(it) } <span style="color:#888">// We&#39;ll discuss this syntax later...
</span><span style="color:#888"></span>}
printall(<span style="color:#d20;background-color:#fff0f0">&#34;Lorem&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;ipsum&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;dolor&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;sit&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;amet&#34;</span>)
</code></pre></div></section><section>
<h1 id="kotlin-101-21">Kotlin 101</h1>
<h2 id="naming-in-kotlin">Naming in Kotlin</h2>
<p>Kotlin is less permissive than Scala:</p>
<ul>
<li>Arbitrary symbols are not accepted as valid function names</li>
<li>&hellip;unless you explicitly surround them with backtics</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">def</span> ##<span style="color:#a61717;background-color:#e3d2d2">Â°</span>@??%&amp;@^^() <span style="color:#080;font-weight:bold">=</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// Super ok for Scala: def $hash$hash$u00B0$at$qmark$qmark$percent$amp$at$up$up(): Int
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">`##Â°@??%&amp;@^^`() = 1 // </span><span style="color:#06b;font-weight:bold">OK</span>
<span style="color:#a61717;background-color:#e3d2d2">`##Â°@</span>??%&amp;<span style="color:#a61717;background-color:#e3d2d2">@</span>^^<span style="color:#a61717;background-color:#e3d2d2">`</span>() <span style="color:#888">// 1. Must be invoked with backticks!
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`val`</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Hey look I can name things with keywords!&#34;</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`names can also contain spaces`</span> = <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><ul>
<li>General rule: <strong>avoid it</strong></li>
<li>It might be needed for interoperability with other languages, e.g. if a Java field is named <code>val</code></li>
<li>Tolerated in tests with Junit (but Kotlin-native suites as Kotest do not need it)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">JunitTest</span> {
    @Test
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">`404 </span><span style="color:#06b;font-weight:bold">errors</span> should cause a wait and retry<span style="color:#a61717;background-color:#e3d2d2">`</span>() { <span style="color:#888">// Nice and very clear name
</span><span style="color:#888"></span>        TODO()
    }
}
</code></pre></div></section><section>
<h1 id="kotlin-101-22">Kotlin 101</h1>
<h2 id="local-functions">Local functions</h2>
<p>Functions can contain other functions (as in Scala)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">factorial</span>(n: UInt): ULong {
    <span style="color:#888">// tailrec forces optimization of tail recursion (and blocks compilation if recursion is non-tail)
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">tailrec</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">factorialWithAccumulator</span>(current: UInt, accumulator: ULong): ULong = <span style="color:#080;font-weight:bold">when</span> {
        current &gt;= n -&gt; accumulator * current
        <span style="color:#080;font-weight:bold">else</span> -&gt; factorialWithAccumulator(current + <span style="color:#00d;font-weight:bold">1u</span>, accumulator * current)
    }
    <span style="color:#080;font-weight:bold">return</span> factorialWithAccumulator(<span style="color:#00d;font-weight:bold">1u</span>, <span style="color:#00d;font-weight:bold">1u</span>)
}
</code></pre></div><p>Warning: local functions often hinder clarity</p>
</section><section>
<h1 id="kotlin-101----flow-control">Kotlin 101 &ndash; Flow control</h1>
<h2 id="if"><code>if</code></h2>
<ul>
<li><code>if</code>/<code>else</code> is an expression and works just as in Scala</li>
<li>No ternary operator</li>
<li><code>if</code> alone is not an expression</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-1">Kotlin 101 &ndash; Flow control</h1>
<h3 id="for"><code>for</code></h3>
<ul>
<li><strong>No classic</strong> <code>for(init; condition; then) { block }</code> loop</li>
<li>Only available as <code>for</code>/<code>in</code>: <code>for (element in collection) { block }</code></li>
<li><strong>Not a powerful combinator</strong> like Scala&rsquo;s <code>for</code></li>
<li><em>Rarely used</em> (I think I might have used it twice in my career)</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-2">Kotlin 101 &ndash; Flow control</h1>
<h3 id="while-and-dowhile"><code>while</code> and <code>do</code>/<code>while</code></h3>
<ul>
<li>Same as Java, but with <em>visibility of variables defined in the <code>do</code>-block</em></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">kotlin.random.Random</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">lucky</span> = <span style="color:#00d;font-weight:bold">6</span>
<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">attempts</span> = <span style="color:#00d;font-weight:bold">0</span>
<span style="color:#080;font-weight:bold">do</span> {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">draw</span> = Random.nextInt(lucky + <span style="color:#00d;font-weight:bold">1</span>)
    attempts++
} <span style="color:#080;font-weight:bold">while</span> (draw != lucky) <span style="color:#888">// draw is visible here
</span><span style="color:#888"></span>println(<span style="color:#d20;background-color:#fff0f0">&#34;Launched $attempts dice before a lucky shot&#34;</span>)
</code></pre></div></section><section>
<h1 id="kotlin-101----flow-control-3">Kotlin 101 &ndash; Flow control</h1>
<h3 id="when"><code>when</code></h3>
<p>Kotlin <em>does not support pattern matching</em> as Scala does (unfortunately)
<br/>
The <code>when</code> block is somewhat a mild surrogate, more similar to a <code>switch</code> on steroids
<br/>
The base version (without subject) is a more elegant &ldquo;<code>if</code>/<code>else if</code>/<code>else</code>&rdquo; chain</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">countBatmans</span>(subject: String) = <span style="color:#080;font-weight:bold">when</span> {
    subject.length &lt; <span style="color:#d20;background-color:#fff0f0">&#34;batman&#34;</span>.length -&gt; <span style="color:#00d;font-weight:bold">0</span>
    subject.length &lt; <span style="color:#00d;font-weight:bold">2</span> * <span style="color:#d20;background-color:#fff0f0">&#34;batman&#34;</span>.length &amp;&amp; subject.contains(<span style="color:#d20;background-color:#fff0f0">&#34;batman&#34;</span>) -&gt; <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;.*?(batman)&#34;</span>.toRegex().findAll(subject).count().toInt()
}
</code></pre></div><ul>
<li><code>when</code> is an expression in any case</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-4">Kotlin 101 &ndash; Flow control</h1>
<h3 id="when-subject"><code>when (subject)</code></h3>
<p>Checks if the value of subjects is the same of the expression on the right</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baseForSingleDigitOrNull</span>(digit: UInt) = <span style="color:#080;font-weight:bold">when</span>(digit) {
    <span style="color:#00d;font-weight:bold">0u</span>, <span style="color:#00d;font-weight:bold">1u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;binary&#34;</span>
    <span style="color:#00d;font-weight:bold">2u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;ternary&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">7u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;octal&#34;</span> <span style="color:#888">// This is a range!
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">15u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;hexadecimal&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">36u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;base36&#34;</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#080;font-weight:bold">null</span>
}
</code></pre></div><ul>
<li><code>when</code> with subject can be used to elegantly check for subtypes</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">splitAnything</span>(input: Any) = <span style="color:#080;font-weight:bold">when</span>(input) {
    <span style="color:#080;font-weight:bold">is</span> Int -&gt; input / <span style="color:#00d;font-weight:bold">2</span> <span style="color:#888">// No need to cast! The compiler infers type automatically (smart cast)
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">is</span> String -&gt; input.substring(input.length / <span style="color:#00d;font-weight:bold">2</span>)
    <span style="color:#080;font-weight:bold">is</span> Double -&gt; input / <span style="color:#00d;font-weight:bold">2</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; TODO()
}
</code></pre></div></section><section>
<h1 id="kotlin-101----flow-control-5">Kotlin 101 &ndash; Flow control</h1>
<h3 id="when-1"><code>when</code></h3>
<p>Checks if the value of subjects is the same of the expression on the right</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baseForSingleDigitOrNull</span>(digit: UInt) = <span style="color:#080;font-weight:bold">when</span>(digit) {
    <span style="color:#00d;font-weight:bold">0u</span>, <span style="color:#00d;font-weight:bold">1u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;binary&#34;</span>
    <span style="color:#00d;font-weight:bold">2u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;ternary&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">7u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;octal&#34;</span> <span style="color:#888">// This is a range!
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">15u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;hexadecimal&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">36u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;base36&#34;</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#080;font-weight:bold">null</span>
}
</code></pre></div><ul>
<li><code>when</code> is an expression in any case</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-6">Kotlin 101 &ndash; Flow control</h1>
<h3 id="jumping">Jumping</h3>
<p><strong>Jumping is awful, imperative, and you should not use it</strong>
<br/>
&hellip;but someone might and you must be able to understand it&hellip;</p>
<ul>
<li><code>break</code> and <code>continue</code> work as in Java</li>
<li><code>return</code> does not, as we will see when discussing higher order functions&hellip;</li>
</ul>
<h4 id="labeling">labeling</h4>
<ul>
<li>Any expression can be labeled: <code>label@ 1</code> is a valid expression</li>
<li><code>break</code>, <code>continue</code>, and <code>return</code> can be <em>qualified</em> with a label</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>outerloop<span style="color:#a61717;background-color:#e3d2d2">@</span> <span style="color:#080;font-weight:bold">for</span> (i <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">100</span>) {
    <span style="color:#080;font-weight:bold">for</span> (j <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">100</span>) {
        <span style="color:#080;font-weight:bold">if</span> (i * j == i + j) {
            println(<span style="color:#d20;background-color:#fff0f0">&#34;$i * $j equals $i + $j&#34;</span>)
            <span style="color:#080;font-weight:bold">break</span>@outerloop <span style="color:#888">// Qualified break
</span><span style="color:#888"></span>        }
    }
}
</code></pre></div></section><section>
<h1 id="kotlin-102----oop">Kotlin 102 &ndash; OOP</h1>
<h2 id="classes">Classes</h2>
<ul>
<li>Similar to Scala, the keyword <code>class</code> introduces a class definition</li>
<li>Object construction does not require <code>new</code>
<ul>
<li><code>new</code> is not a Kotlin keyword at all</li>
</ul>
</li>
<li>Objecs get built from classes by just invoking the class name:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>
Foo() <span style="color:#888">// a new Foo is created, no new keyword
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-1">Kotlin 102 &ndash; OOP</h1>
<h2 id="classes-and-members">Classes and members</h2>
<p>Kotlin classes have two types of members: <strong>methods</strong> and <strong>properties</strong></p>
<table>
<thead>
<tr>
<th>Language / Member Type</th>
<th align="center">Fields</th>
<th>Methods</th>
<th>Properties</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java</td>
<td align="center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td>Scala</td>
<td align="center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td>Kotlin</td>
<td align="center"><strong>No</strong> (Hidden)</td>
<td><em>Yes</em></td>
<td><em>Yes</em></td>
</tr>
<tr>
<td>C#</td>
<td align="center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><em>Yes</em></td>
</tr>
</tbody>
</table>
<p>In Scala, at the caller site, methods and fields are hard to distinguish, as parentheses for 0-ary method calls are optional</p>
<p>In Kotlin, methods/functions (except when defined <code>infix</code>) are invoked with mandatory parentheses
<br/>
properties are instead invoked without parentheses</p>
</section><section>
<h1 id="kotlin-102----oop-2">Kotlin 102 &ndash; OOP</h1>
<h2 id="properties-vs-fields">Properties vs. fields</h2>
<p>Properties and fields are conceptually different</p>
<ul>
<li><em>fields</em> <strong>are</strong> the object&rsquo;s state</li>
<li><em>properties</em> are a way to <strong>access/change</strong> the object&rsquo;s state</li>
</ul>
<p>It&rsquo;s considered a good practice in languages without properties (Java in particular) to hide (<em>incapsulate</em>) fields (Object&rsquo;s actual state)
and provide access only via <code>get</code>/<code>set</code> methods: the actual state representation may change with no change to the API.</p>
<p>In Kotlin, fields are entirely hidden, and cannot be exposed in any way, enforcing the aforementioned convention at the language level.</p>
</section><section>
<h1 id="kotlin-102----oop-3">Kotlin 102 &ndash; OOP</h1>
<h2 id="defining-properties-for-classes">Defining properties for classes</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span> {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span> = <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#080;font-weight:bold">null</span>
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bazLength</span>: Int
        <span style="color:#080;font-weight:bold">get</span>() = baz?.length ?: <span style="color:#00d;font-weight:bold">0</span>
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">stringRepresentation</span>: String = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>
        <span style="color:#080;font-weight:bold">get</span>() = baz ?: field
        <span style="color:#080;font-weight:bold">set</span>(value) {
            field = <span style="color:#d20;background-color:#fff0f0">&#34;custom: $value&#34;</span>
        }

}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">foo</span> = Foo()
foo.bar = <span style="color:#00d;font-weight:bold">3</span><span class='fragment '  style="color: #888;"> // error: val cannot be reassigned</span>
foo.stringRepresentation<span class='fragment '  style="color: #888;"> // empty string</span>
foo.stringRepresentation = <span style="color:#d20;background-color:#fff0f0">&#34;zed&#34;</span><span class='fragment '  style="color: #888;"> // &#39;custom: zed&#39;</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-4">Kotlin 102 &ndash; OOP</h1>
<h2 id="backing-fields">Backing fields</h2>
<p>The keyword <code>field</code> allows access to a backing field of a property
<br/>
<strong>in case it is present</strong></p>
<p>The Kotlin compiler, in fact, generates backing fields only where it&rsquo;s needed</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span> {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">id</span>: String? = <span style="color:#080;font-weight:bold">null</span> <span style="color:#888">// Backing field generated
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">identifier</span>: String = <span style="color:#d20;background-color:#fff0f0">&#34;Student[${id ?: &#34;</span>unknown<span style="color:#d20;background-color:#fff0f0">&#34;}]&#34;</span> <span style="color:#888">// No backing field
</span><span style="color:#888"></span>}
</code></pre></div><p>When designing with Kotlin, you must consider methods and properties, and forget about fields.</p>
</section><section>
<h1 id="kotlin-102----oop-5">Kotlin 102 &ndash; OOP</h1>
<h2 id="defining-methods">Defining methods</h2>
<p>Methods are defined as <code>fun</code>ctions within the scope of a class</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutableComplex</span> {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">real</span>: Double = <span style="color:#00d;font-weight:bold">0.0</span>
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">imaginary</span>: Double = <span style="color:#00d;font-weight:bold">0.0</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: MutableComplex): MutableComplex = MutableComplex().also {
        it.real = real + other.real
        it.imaginary = imaginary + other.imaginary
    }
}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">foo</span> = MutableComplex()
foo.real = <span style="color:#00d;font-weight:bold">1.0</span>
foo.imaginary = <span style="color:#00d;font-weight:bold">2.0</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span> = MutableComplex()
bar.real = <span style="color:#00d;font-weight:bold">4.1</span>
bar.imaginary = <span style="color:#00d;font-weight:bold">0.1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">baz</span> = foo.plus(bar)
<span style="color:#d20;background-color:#fff0f0">&#34;${baz.real}+${baz.imaginary}i&#34;</span><span class='fragment '  style="color: #888;"> // 5.1&#43;2.1i</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-6">Kotlin 102 &ndash; OOP</h1>
<h2 id="interfaces">Interfaces</h2>
<ul>
<li>Similar to Java 8+</li>
<li>Methods can be implemented</li>
<li>Can host properties
<ul>
<li>And their accessors can be implemented</li>
<li>Properties in interfaces <em>do not have backing fields</em></li>
</ul>
</li>
<li>Both properties and methods can be implemented there</li>
<li>Scala-like mixins not supported
<ul>
<li>A Kotlin <code>interface</code> cannot be a subclass of a Kotlin <code>class</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">trait</span> <span style="color:#b06;font-weight:bold">B</span> <span style="color:#080;font-weight:bold">extends</span> A <span style="color:#888">// All fine in Scala
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">B</span> : A <span style="color:#888">// error: an interface cannot inherit from a class
</span></code></pre></div><p>So, no mixins</p>
</section><section>
<h1 id="kotlin-102----oop-7">Kotlin 102 &ndash; OOP</h1>
<h2 id="implementing-interfaces">Implementing interfaces</h2>
<p>Much like Java. Subtyping keyword is <code>:</code>, overrides must be marked with <code>override</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Shape</span> {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">area</span>: Double
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">perimeter</span>: Double
}
<span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Shrinkable</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">shrink</span>(): Unit
}
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutableCircle</span> : Shape, Shrinkable {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">radius</span> = <span style="color:#00d;font-weight:bold">1.0</span>
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">area</span> <span style="color:#080;font-weight:bold">get</span>() = Math.PI * radius * radius
    <span style="color:#888">// What if we remove &#34;get()&#34;?
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">perimeter</span> <span style="color:#080;font-weight:bold">get</span>() = <span style="color:#00d;font-weight:bold">2</span> * Math.PI * radius
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">shrink</span>() {
        radius /= <span style="color:#00d;font-weight:bold">2</span>
    }
}
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-8">Kotlin 102 &ndash; OOP</h1>
<h2 id="superclass-disambiguation">Superclass disambiguation</h2>
<p>A call to <code>super</code> can be qualified to disambiguate between conflincting interface declarations:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">A</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
}
<span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">B</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>
}
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">C</span> : A, B {
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#080;font-weight:bold">super</span>&lt;A&gt;.foo() + <span style="color:#080;font-weight:bold">super</span>&lt;B&gt;.foo()
}
C().foo()<span class='fragment '  style="color: #888;"> // foobar</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-9">Kotlin 102 &ndash; OOP</h1>
<h2 id="primary-constructors-and-init">Primary constructors and <code>init</code></h2>
<p>Similar to Scala, but code in the class body is not part of a constructor
<br/>
Primary constructor code (if any) must be in an <code>init</code> block</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>(
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String, <span style="color:#888">// This is a val property of the class
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: Int, <span style="color:#888">// This is a var property of the class
</span><span style="color:#888"></span>    greeting: String = <span style="color:#d20;background-color:#fff0f0">&#34;Hello from constructor&#34;</span> <span style="color:#888">// Constructor parameter, not a property. Default values allowed.
</span><span style="color:#888"></span>) {
    init {
        println(greeting)
    }
}
Foo(<span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>, <span style="color:#00d;font-weight:bold">0</span>)
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-10">Kotlin 102 &ndash; OOP</h1>
<h2 id="secondary-constructors">Secondary <code>constructor</code>s</h2>
<p>More constructors can be added to a class, but them:</p>
<ol>
<li>Must call another constructor</li>
<li>The primary constructor must be in its <em>delegation calls chain</em></li>
</ol>
<p>Call to another constructor is performed using <code>:</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String) {
    <span style="color:#080;font-weight:bold">constructor</span>(longBar: Long) : <span style="color:#080;font-weight:bold">this</span>(<span style="color:#d20;background-color:#fff0f0">&#34;number ${longBar.toString()}&#34;</span>)
    <span style="color:#080;font-weight:bold">constructor</span>(intBar: Int) : <span style="color:#080;font-weight:bold">this</span>(intBar.toLong())
}
Foo(<span style="color:#00d;font-weight:bold">1</span>).bar <span style="color:#888">// number 1
</span></code></pre></div><p>The primary constructor can be written in a longer form with the <code>constructor</code> keyword as well</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span> <span style="color:#080;font-weight:bold">constructor</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String) <span style="color:#888">// OK
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-11">Kotlin 102 &ndash; OOP</h1>
<h2 id="nullability-and-lateinit">Nullability and <code>lateinit</code></h2>
<p>It is possible that some <code>var</code> property needs to get initialized after the object construction:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span>: Father)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span>(<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son) <span style="color:#888">// Impossible to build either
</span></code></pre></div><p>Solution 1: allow nullability (<strong>BAD</strong>)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span>: Father)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span>(<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son? = <span style="color:#080;font-weight:bold">null</span>)
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span> = Father()
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">son</span> = Son(father)
father.son = son
father.son.father <span style="color:#888">// error, needs ?.
</span></code></pre></div><p>Solution 1: take responsibility from the compiler (<em>less bad</em>)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span>: Father)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span> { <span style="color:#080;font-weight:bold">lateinit</span> <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son } <span style="color:#888">// lateinit: I will initialize it later, stay cool
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span> = Father()
father.son <span style="color:#888">// UninitializedPropertyAccessException: lateinit property son has not been initialized
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">son</span> = Son(father)
father.son = son
father.son.father <span style="color:#888">// OK!
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-12">Kotlin 102 &ndash; OOP</h1>
<blockquote>
<p><strong>Design and document for inheritance or else prohibit it</strong><br/>
<em>J. Bloch, Effective Java, Item 17</em></p>
</blockquote>
<h2 id="closed-hierarchies-and-open">Closed hierarchies and <code>open</code></h2>
<p>Kotlin enforces EJ-17 by design: all classes are final if the keyword <code>open</code> is not specified</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// error: this type is final, so it cannot be inherited from
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// OK
</span></code></pre></div><p>As in Scala, <em>the constructor of the superclass must be called at extension site</em>
<br/>
Differently than Scala, such invocatin <em>always requires parentheses</em></p>
</section><section>
<h1 id="kotlin-102----oop-13">Kotlin 102 &ndash; OOP</h1>
<h2 id="abstract-vs-open"><code>abstract</code> vs. <code>open</code></h2>
<p>The same effect of <code>open</code> can be achieved with <code>abstract</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// Perfectly fine
</span></code></pre></div><p>With abstract, however, the superclass cannot be created
<br/>
(and it should have actual <code>abstract</code> memebers anyway)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Open</span>
<span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Abstract</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FromOpen</span> : Open()
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FromAbstract</span> : Abstract()
FromAbstract() <span style="color:#888">// OK
</span><span style="color:#888"></span>FromOpen() <span style="color:#888">// OK
</span><span style="color:#888"></span>Open() <span style="color:#888">// OK
</span><span style="color:#888"></span>Abstract() <span style="color:#888">// error: cannot create an instance of an abstract class
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-14">Kotlin 102 &ndash; OOP</h1>
<h2 id="singleton-objects">Singleton <code>object</code>s</h2>
<p>Same as Scala, but with explicit <code>companion</code>s
<br/>
In Scala</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">A</span> <span style="color:#888">// Same file and same name identify a companion
</span></code></pre></div><p>In Kotlin</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> {
    <span style="color:#080;font-weight:bold">companion</span> <span style="color:#080;font-weight:bold">object</span> <span style="color:#888">// Companions are inner to classes 
</span><span style="color:#888"></span>}
A <span style="color:#888">// refers to A.Companion
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">A</span> <span style="color:#888">// This is an independent object
</span><span style="color:#888"></span>A <span style="color:#888">// refers to the previously defined object
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-15">Kotlin 102 &ndash; OOP</h1>
<h2 id="information-hiding">Information hiding</h2>
<p>Simpler than Scala, more coherent than Java</p>
<ul>
<li><code>public</code> &ndash; default visibility, visible everywhere (API)</li>
<li><code>internal</code> &ndash; visible to everything in this <em>&ldquo;module&rdquo;</em>
<ul>
<li>module $\Rightarrow$ a set of Kotlin files compiled together</li>
</ul>
</li>
<li><code>protected</code> &ndash; visible to subclasses (but <em>not</em> to other members of the package)</li>
<li><code>private</code> &ndash; visible inside this class and its members</li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-16">Kotlin 102 &ndash; OOP</h1>
<h2 id="visibility-control">Visibility control</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Visibility</span> <span style="color:#080;font-weight:bold">internal</span> <span style="color:#080;font-weight:bold">constructor</span>( <span style="color:#888">// constructor is required to apply visibility restrictionss
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: Int <span style="color:#888">// Same as Scala
</span><span style="color:#888"></span>) { 
    <span style="color:#080;font-weight:bold">protected</span> <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">state</span> = <span style="color:#00d;font-weight:bold">0</span>
        <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">set</span> <span style="color:#888">// visibility restriction for properties in get/set methods
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="equality-hashing-string-version">Equality, hashing, string version</h2>
<p>Same as Java, but for equality:</p>
<ul>
<li><code>==</code> calls <code>equals</code></li>
<li>Java&rsquo;s stack variable comparison (<code>==</code>) is Kotlin&rsquo;s <code>===</code></li>
</ul>
<p>Kotlin does not suffer of Scala&rsquo;s equality issues
(no automatic conversion of types)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> a<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Int</span> = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> b<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Long</span> = a
a == b <span style="color:#888">// true
</span><span style="color:#888"></span>a equals b <span style="color:#888">// false O_O
</span></code></pre></div><p>Kotlin:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">a</span>: Int = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">b</span>: Long = a <span style="color:#888">// error: type mismatch: inferred type is Int but Long was expected
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">b</span>: Long = a.toLong()
a == b <span style="color:#888">// error: operator &#39;==&#39; cannot be applied to &#39;Int&#39; and &#39;Long&#39;
</span><span style="color:#888"></span>a.toLong() == b <span style="color:#888">// true
</span><span style="color:#888"></span>a == b.toInt() <span style="color:#888">// true
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-1">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="infix-calls"><code>infix</code> calls</h2>
<p>Kotlin is less permissive than scala:</p>
<ul>
<li>In Scala, every instance method with a single parameter can be invoked as infix operator:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1</span> equals <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// infix invocation of 1.equals(1)
</span></code></pre></div><ul>
<li>In Kotlin, this is not allowed:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1</span> equals <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// error: &#39;infix&#39; modifier is required on &#39;equals&#39; in &#39;kotlin.Int&#39;
</span></code></pre></div><ul>
<li>Kotlin requires that the <code>infix</code> keyword for a method to be usable as infix</li>
<li><code>infix</code> functions have <em>lower precedence</em> than operators</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Infix</span> {
    <span style="color:#080;font-weight:bold">infix</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">andThen</span>(s: String) = <span style="color:#d20;background-color:#fff0f0">&#34;in... $s ...fix!&#34;</span>
}
Infix() andThen <span style="color:#d20;background-color:#fff0f0">&#34;Foo&#34;</span> <span style="color:#888">// in... Foo ...fix!
</span><span style="color:#888"></span>Infix() andThen <span style="color:#d20;background-color:#fff0f0">&#34;Foo&#34;</span> + <span style="color:#d20;background-color:#fff0f0">&#34;Bar&#34;</span> <span class='fragment '  style="color: #888;"> // in... FooBar ...fix</span>
Infix() andThen <span style="color:#d20;background-color:#fff0f0">&#34;Foo&#34;</span> + <span style="color:#d20;background-color:#fff0f0">&#34;Bar&#34;</span> + Infix() andThen <span style="color:#d20;background-color:#fff0f0">&#34;Baz&#34;</span> <span class='fragment '  style="color: #888;"> // error: unresolved reference: andThen (searched in String)</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-2">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="operator-creation">Operator creation</h2>
<p>In Scala, operator names are valid method names, and prefix and infix calls are automatic:</p>
<ul>
<li>Very much the whole language philosophy: few concepts, high scalability</li>
<li>Easy to abuse, degenerating to esoteric operators
<ul>
<li>Especially when software is written by people with different background</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>executer(<span style="color:#080;font-weight:bold">:</span><span style="color:#888;font-weight:bold">/</span>(<span style="color:#888;font-weight:bold">host</span>, <span style="color:#888;font-weight:bold">port</span>) / target &lt;&lt; reqBody &gt;- { fromRespStr }) <span style="color:#888">// Using Databinder Dispatch
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> graph <span style="color:#080;font-weight:bold">=</span> <span style="color:#b06;font-weight:bold">Graph</span>((jfc ~+#&gt; fra)(<span style="color:#b06;font-weight:bold">Any</span>()), (fra ~+#&gt; dme)(<span style="color:#b06;font-weight:bold">Any</span>()) <span style="color:#888">// Using ScalaGraph
</span></code></pre></div><p>Operators are succint, but cryptic, and their meaning changes with context</p>
<p>This has been a source of cricism, Kotlin <strong>does not allow to define custom operators</strong></p>
<ul>
<li>At most, back-ticked names, but some characters are disallowed (<code>&gt;</code>, <code>/</code>, <code>:</code>, etc.)</li>
<li>Clumsy, defies the reason why one would use them (terse and succint code)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> { <span style="color:#080;font-weight:bold">infix</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">`~+#-`(</span><span style="color:#06b;font-weight:bold">other</span>: A) = <span style="color:#d20;background-color:#fff0f0">&#34;I&#39;m an arcane operator&#34;</span> }
A() <span style="color:#a61717;background-color:#e3d2d2">`</span>~+<span style="color:#a61717;background-color:#e3d2d2">#</span>-<span style="color:#a61717;background-color:#e3d2d2">`</span> A() <span style="color:#888">// I&#39;m an arcane operator
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-3">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="operator-overloading">Operator overloading</h2>
<p>Kotlin allows for a limited set of operators to be defined/overloaded</p>
<ul>
<li>Method names must match a convention</li>
<li>Methods must be annotated with the <code>operator</code> keyword</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Complex</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">real</span>: Double, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">imaginary</span>: Double) {
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: Complex) = Complex(real + other.real, imaginary + other.imaginary)
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: Double) = plus(Complex(other, <span style="color:#00d;font-weight:bold">0.0</span>))
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = real.toString() + <span style="color:#080;font-weight:bold">when</span> {
        imaginary == <span style="color:#00d;font-weight:bold">0.0</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>
        imaginary &gt; <span style="color:#00d;font-weight:bold">0.0</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;+${imaginary}i&#34;</span>
        <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;${imaginary}i&#34;</span>
    }
}
Complex(<span style="color:#00d;font-weight:bold">1.0</span>, <span style="color:#00d;font-weight:bold">1.0</span>) + <span style="color:#00d;font-weight:bold">3.4</span> <span style="color:#888">// 4.4+1.0i
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-4">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="unary-operator-overloading-table">Unary Operator overloading table</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+x</code></td>
<td align="center"><code>unaryPlus</code></td>
<td><code>x.unaryPlus()</code></td>
</tr>
<tr>
<td><code>-x</code></td>
<td align="center"><code>unaryMinus</code></td>
<td><code>x.unaryMinus()</code></td>
</tr>
<tr>
<td><code>++x</code></td>
<td align="center"><code>inc</code></td>
<td><code>x.inc().also { x = it }</code></td>
</tr>
<tr>
<td><code>x++</code></td>
<td align="center"><code>inc</code></td>
<td><code>x.also { x = it.inc() }</code></td>
</tr>
<tr>
<td><code>--x</code></td>
<td align="center"><code>dec</code></td>
<td><code>x.dec().also { x = it }</code></td>
</tr>
<tr>
<td><code>x--</code></td>
<td align="center"><code>dec</code></td>
<td><code>x.also { x = it.dec() }</code></td>
</tr>
<tr>
<td><code>!x</code></td>
<td align="center"><code>not</code></td>
<td><code>x.not()</code></td>
</tr>
<tr>
<td><code>x()</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke()</code></td>
</tr>
</tbody>
</table>
<p>Function invocation is an operator and can be overloaded!
<br/>
This will turn useful in future&hellip;</p>
</section><section>
<h1 id="kotlin-102----oop-conventions-5">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-arithmetic">Binary Operator overloading: arithmetic</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x + y</code></td>
<td align="center"><code>plus</code></td>
<td><code>x.plus(y)</code></td>
</tr>
<tr>
<td><code>x - y</code></td>
<td align="center"><code>minus</code></td>
<td><code>x.minus(y)</code></td>
</tr>
<tr>
<td><code>x * y</code></td>
<td align="center"><code>times</code></td>
<td><code>x.times(y)</code></td>
</tr>
<tr>
<td><code>x / y</code></td>
<td align="center"><code>div</code></td>
<td><code>x.div(y)</code></td>
</tr>
<tr>
<td><code>x % y</code></td>
<td align="center"><code>rem</code></td>
<td><code>x.rem(y)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-6">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-assignment">Binary Operator overloading: assignment</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x += y</code></td>
<td align="center"><code>plusAssign</code></td>
<td><code>x.plusAssign(y)</code></td>
</tr>
<tr>
<td><code>x -= y</code></td>
<td align="center"><code>minusAssign</code></td>
<td><code>x.minusAssign(y)</code></td>
</tr>
<tr>
<td><code>x *= y</code></td>
<td align="center"><code>timesAssign</code></td>
<td><code>x.timesAssign(y)</code></td>
</tr>
<tr>
<td><code>x /= y</code></td>
<td align="center"><code>divAssign</code></td>
<td><code>x.divAssign(y)</code></td>
</tr>
<tr>
<td><code>x %= y</code></td>
<td align="center"><code>remAssign</code></td>
<td><code>x.remAssign(y)</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Assignment functions <em>can be defined only if their arithmetic equivalent is undefined</em>.</li>
<li>If an aritmetic operator <code>op</code> is defined, the compiler infers the assign version as:
<ul>
<li><code>a op= b</code> $\Rightarrow$ <code>a = a op b</code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-conventions-7">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-comparison">Binary Operator overloading: comparison</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x == y</code></td>
<td align="center"><code>equals</code></td>
<td><code>x?.equals(y) ?: (b === null)</code></td>
</tr>
<tr>
<td><code>x != y</code></td>
<td align="center"><code>equals</code></td>
<td><code>!(x?.equals(y) ?: (b === null))</code></td>
</tr>
<tr>
<td><code>x &gt; y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &gt; 0</code></td>
</tr>
<tr>
<td><code>x &lt; y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &lt; 0</code></td>
</tr>
<tr>
<td><code>x &gt;= y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &gt;= 0</code></td>
</tr>
<tr>
<td><code>x &lt;= y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &lt;= 0</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-8">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-others">Binary Operator overloading: others</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x..y</code></td>
<td align="center"><code>rangeTo</code></td>
<td><code>x.rangeTo(y)</code></td>
</tr>
<tr>
<td><code>x in y</code></td>
<td align="center"><code>contains</code></td>
<td><code>y.contains(x)</code></td>
</tr>
<tr>
<td><code>x !in y</code></td>
<td align="center"><code>contains</code></td>
<td><code>!y.contains(x)</code></td>
</tr>
<tr>
<td><code>x[y]</code></td>
<td align="center"><code>get</code></td>
<td><code>x.get(y)</code></td>
</tr>
<tr>
<td><code>x(y)</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke(y)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-9">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="ternary-operator-overloading">Ternary Operator overloading</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[y, z]</code></td>
<td align="center"><code>get</code></td>
<td><code>x.get(y, z)</code></td>
</tr>
<tr>
<td><code>x[y] = z</code></td>
<td align="center"><code>set</code></td>
<td><code>x.set(y) = z</code></td>
</tr>
<tr>
<td><code>x(y, z)</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke(y, z)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-10">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="n-ary-operator-overloading">n-ary Operator overloading</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[y, ..., z]</code></td>
<td align="center"><code>get</code></td>
<td><code>x.get(y, ..., z)</code></td>
</tr>
<tr>
<td><code>x[y, ..., z] = a</code></td>
<td align="center"><code>set</code></td>
<td><code>x.set(y, ..., z) = a</code></td>
</tr>
<tr>
<td><code>x(y, ..., z)</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke(y, ..., z)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-103----generics">Kotlin 103 &ndash; Generics</h1>
<h2 id="compared-with-java-and-scala">Compared with Java and Scala</h2>
<p>Kotlin&rsquo;s type system supports generics</p>
<ul>
<li>Handier than Java&rsquo;s</li>
<li><strong>way</strong> less powerful than Scala&rsquo;s</li>
<li>No higher kinded types (they are in Scala)</li>
<li>No type lambdas (they are in Scala)</li>
<li>Declaration-site variance (absent in Java)</li>
<li>Generic type reification via inlining (not found in Java nor Scala)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">trait</span> <span style="color:#b06;font-weight:bold">Functor</span>[<span style="color:#888;font-weight:bold">F</span>[<span style="color:#080;font-weight:bold">_</span>]] <span style="color:#888">// There is no Kotlin equivalent for these lines
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">MapFunctor</span> = <span style="color:#b06;font-weight:bold">Functor</span>[({ <span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">T</span>[<span style="color:#888;font-weight:bold">A</span>] <span style="color:#888;font-weight:bold">=</span> <span style="color:#888;font-weight:bold">Map</span>[<span style="color:#888;font-weight:bold">Int</span>, <span style="color:#888;font-weight:bold">A</span>] })<span style="color:#080;font-weight:bold">#</span><span style="color:#888;font-weight:bold">T</span>]
</code></pre></div></section><section>
<h1 id="kotlin-103----generics-1">Kotlin 103 &ndash; Generics</h1>
<h2 id="base-syntax">Base syntax</h2>
<p>Syntax similar to Java generics</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>&lt;A, B : CharSequence&gt;
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">&lt;</span><span style="color:#06b;font-weight:bold">T</span> : Comparable&lt;T&gt;&gt; maxOf3(first: T, second: T, third: T): T = <span style="color:#080;font-weight:bold">when</span> {
    first &gt;= second &amp;&amp; first &gt;= third -&gt; first
    second &gt;= third -&gt; second
    <span style="color:#080;font-weight:bold">else</span> -&gt; third
}
</code></pre></div><ul>
<li>type upper bounds can be specified with <code>:</code></li>
<li>if no bound is specified, the generic is <em>nullable</em>!</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> &lt;T&gt; <span style="color:#06b;font-weight:bold">className</span>(receiver: T) = receiver::<span style="color:#080;font-weight:bold">class</span>.simpleName
<span style="color:#888">// error: expression in a class literal has a nullable type &#39;T&#39;, use !! to make the type non-nullable
</span></code></pre></div></section><section>
<h1 id="kotlin-103----generics-2">Kotlin 103 &ndash; Generics</h1>
<h2 id="where"><code>where</code></h2>
<p>In case multiple bounds are present, the definition can become cumbersome
<br/>
Kotlin provides a <code>where</code> keyword to specify type bounds separately from the rest of the signature</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// From an actual Alchemist interface
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">NavigationStrategy</span>&lt;T, P, A, L, R, N, E&gt;
    <span style="color:#080;font-weight:bold">where</span> P : Position&lt;P&gt;, P : Vector&lt;P&gt;,
          A : GeometricTransformation&lt;P&gt;,
          L : ConvexGeometricShape&lt;P, A&gt;,
          N : ConvexGeometricShape&lt;P, A&gt; {
<span style="color:#888">// Interface content, if any
</span><span style="color:#888"></span>}

<span style="color:#888">// Function syntax
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;T, P, A, L, R, N, E&gt; <span style="color:#06b;font-weight:bold">navigationStrategy</span>()
    <span style="color:#080;font-weight:bold">where</span> P : Position&lt;P&gt;, P : Vector&lt;P&gt;,
          A : GeometricTransformation&lt;P&gt;,
          L : ConvexGeometricShape&lt;P, A&gt;,
          N : ConvexGeometricShape&lt;P, A&gt; = TODO()
</code></pre></div></section><section>
<h1 id="kotlin-103----generics-3">Kotlin 103 &ndash; Generics</h1>
<h2 id="variance-and-type-projection">Variance and type projection</h2>
<p>Kotlin supports (co/contro)variance using:</p>
<ul>
<li><code>&lt;out T&gt;</code> to mark covariance (similar to Java&rsquo;s <code>&lt;? extends T&gt;</code>)</li>
<li><code>&lt;in T&gt;</code> to mark controvariance (similar to Java&rsquo;s <code>&lt;? super T&gt;</code>)</li>
<li><code>&lt;*&gt;</code> to mark that only the bound is known for the type (similar to Java&rsquo;s <code>&lt;?&gt;</code>)</li>
</ul>
<p>Type variant in Kotlin is expressed <em>at declaration site</em>!</p>
<ul>
<li>In Java type variance is only for methods</li>
<li>In Kotlin type variance is only for classes and interfaces</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">ProduceAndConsume</span>&lt;<span style="color:#080;font-weight:bold">in</span> X, <span style="color:#080;font-weight:bold">out</span> Y&gt; {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">consume</span>(x: X): Any = TODO()<span class='fragment '  style="color: #888;"> // OK</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">consume2</span>(y: Y): Any = TODO()<span class='fragment '  style="color: #888;"> // type parameter Y is declared as &#39;out&#39; but occurs in &#39;in&#39; position in type Y</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">produce</span>(): Y = TODO()<span class='fragment '  style="color: #888;"> // OK</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">produce2</span>(): X = TODO()<span class='fragment '  style="color: #888;"> // error: type parameter X is declared as &#39;in&#39; but occurs in &#39;out&#39; position in type X</span>
}
</code></pre></div></section><section>
<h1 id="kotlin-103----generics-4">Kotlin 103 &ndash; Generics</h1>
<h2 id="type-reification">Type reification</h2>
<p>Generics at runtime can be dealt with two strategies:</p>
<ul>
<li><strong>erasure</strong>: generic information is used by the compiler, but it&rsquo;s discarded at runtime
<ul>
<li>Java / Scala</li>
</ul>
</li>
<li><strong>monomorphization</strong>: concrete type are emitted when generic types are actually used
<ul>
<li>Rust / C#</li>
</ul>
</li>
</ul>
<p>Delicate balance between executable size, performance, and usability</p>
<p>Kotlin uses erasure, but allows to control inlining via the <code>inline</code> keyword.
<br>
In inlined functions, <em>types can be locally monomorphized</em>!
<br>
Local monomorphization is expressed with the <code>reified</code> keyword.</p>
</section><section>
<h1 id="kotlin-103----generics-5">Kotlin 103 &ndash; Generics</h1>
<h2 id="type-reification-example">Type reification example</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">inline</span> <span style="color:#080;font-weight:bold">fun</span> &lt;reified T&gt; <span style="color:#06b;font-weight:bold">checkIsType</span>(a: Any): T = a <span style="color:#080;font-weight:bold">is</span> T <span style="color:#888">// instance check on a generic!
</span><span style="color:#888"></span>checkIsType&lt;Long&gt;(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#888">// false
</span><span style="color:#888"></span>checkIsType&lt;Long&gt;(<span style="color:#00d;font-weight:bold">1L</span>) <span style="color:#888">// true
</span></code></pre></div><p>Note on Java interoperability:</p>
<ul>
<li><code>inline</code> functions get inlined if the caller is Kotlin-compiled code,
they don&rsquo;t if they are called by other bytecode-targeting compilers (<code>javac</code>, <code>scalac</code>&hellip;)</li>
<li><code>reified</code> types <em>requires</em> inlining to perform the local monorphization:
the function code is <em>copied</em> on call site, and the compiler must know how to do it</li>
</ul>
<p>$\Rightarrow$ Can&rsquo;t be used if interoperability is a concern</p>
<ul>
<li>or a wrapper must be provided</li>
</ul>
</section><section>
<h1 id="kotlin-103----collections">Kotlin 103 &ndash; Collections</h1>
<p>Similar to Scala, but based (for the JVM target) on the Java implementation</p>
<ul>
<li>No <code>toJava()</code>/<code>toScala()</code> equivalent</li>
<li><code>List</code>, <code>Set</code>, <code>Map</code> are <em>unmodifiable</em> but not guaranteed <em>immutable</em>
<ul>
<li>e.g., at runtime, <code>List</code> may be backed by an <code>ArrayList</code></li>
<li>clients calling from Java will see mutable collections</li>
<li>Under the JVM, the immutable interfaces are erased at runtime</li>
</ul>
</li>
<li>Mutable collections are available via <code>Mutable</code>(<code>List</code>/<code>Set</code>/<code>Map</code>)</li>
<li>As in Scala, invocation of functional manipulation on collections returns a new collection</li>
<li>Differently than Scala, when a collection is returned, the type is usually <code>List</code>
<ul>
<li>Type is lost, no higher kinded types in Kotlin to express it</li>
</ul>
</li>
<li><code>Sequence</code>s prevent a collection creation at each step</li>
<li><code>Flow</code>s represent collections that are processed in parallel</li>
</ul>
</section><section>
<h1 id="kotlin-201----advanced-oop">Kotlin 201 &ndash; Advanced OOP</h1>
</section><section>
<h2 id="extended-oop">extended OOP</h2>
<p>data classes
copy / equals / toString
destructuring declarations
Pair / Triple
sealed classes
sealing and when
nested classes
inner classes
enum classes
anonymous classes via object expression
type aliasing
delegation and <code>by</code>
contract implementation by delegation (favor composition over inheritance)
delegated properties and variables
delegated properties <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">https://kotlinlang.org/docs/reference/delegated-properties.html</a>
lazy
observable
delegation via map (mutability via MutableMap)
implementing a custom delegate for properties</p>
<h2 id="functional-kotlin">functional kotlin</h2>
<p>function types
function types and nullability
lambda expressions
trailing lambdas
implicit single parameters
closures
return from lambda
return at label
destructuring in lambdas
anonymous functions (rarely used)
invoke convention
inline functions</p>
<h2 id="extensions">extensions</h2>
<p>extension functions vs implicits
extension properties (no backing field)
nullable receivers
companion extensions
generic extensions
extensions resolution
extension members (scope control)
visibility of private members</p>
<h2 id="extensions--functional">extensions + functional</h2>
<p>function types with receiver</p>
<h2 id="standard-library">standard library</h2>
<p>let / run / apply / with
arrays
primitive arrays
ranges</p>
<h2 id="performance">performance</h2>
<p>tail recursion
inline functions
noinline
crossinline
inline classes &ndash; mentioned and skipped, ref to <a href="https://kotlinlang.org/docs/reference/inline-classes.html">https://kotlinlang.org/docs/reference/inline-classes.html</a></p>
<h2 id="java-interop">java interop</h2>
<p>@JvmOverloads
@JvmDefault</p>
<h2 id="dsls-in-kotlin-type-safe-builders">DSLs in Kotlin (type-safe builders)</h2>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/Course-Laboratory-of-Software-Systems/reveal-hugo/object-assign.js></script>

<a href="/Course-Laboratory-of-Software-Systems/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"height":"100%","pdfseparatefragments":false,"theme":"white","width":"100%"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"custom_theme_options":{"enablesourcemap":true,"targetpath":"css/custom-theme.css"},"transition":"slide","transition_speed":"fast"}</script>

<script src="/Course-Laboratory-of-Software-Systems/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/notes/notes.js"></script>



    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>

<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

    
  </body>
</html>
