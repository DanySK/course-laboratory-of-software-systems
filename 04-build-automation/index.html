<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>Build Automation</title>
<meta name="description" content="The art of letting machines do the job for you, with Gradle as example">
<meta name="author" content="Danilo Pianini">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reset.css">
<link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reveal.css">
  <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/css/custom-theme.min.1e2604bf0c24e445faa3ae7d68b2f0146c34bc9e7b9bd6aee2b7187115560e96.css" id="theme"><link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/highlight-js/default.min.css">
    
<link rel="stylesheet" href="https://gitcdn.link/repo/DanySK/css-blur-animation/master/blur.css">
<link href='https://fonts.googleapis.com/css?family=Roboto Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Oxygen Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Ubuntu Mono' rel='stylesheet'>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="hahahugoshortcode-s0-hbhb">Laboratory of Software Systems</h1>
<h2 id="build-automation">Build Automation</h2>
<h3 id="danilo-pianinimailtodanilopianiniuniboit"><a href="mailto:danilo.pianini@unibo.it">Danilo Pianini</a></h3>
2021-01-05

</section><section>
<h1 id="build-automation-1">Build automation</h1>
<p>The process of automating the creation of <em>software artifacts</em>
<br/>
going from <em>source</em> code to <em>tested</em> deployable artifact</p>
<p>May include, depending on the system specifics:</p>
<ul>
<li>Automated <em>source code manipulation</em> and generation</li>
<li>Source code <em>quality assurance</em></li>
<li><em>Dependency management</em></li>
<li><em>Compilation</em>, linking</li>
<li><em>Binary manipulation</em></li>
<li><em>Test execution</em></li>
<li>Test <em>quality assurance</em> (e.g., coverage)</li>
<li>API <em>documentation</em></li>
<li><em>Packaging</em></li>
<li><em>Delivery</em></li>
</ul>
</section><section>
<h1 id="overview">Overview</h1>
<ul>
<li>Build automation: basics, styles</li>
<li>Gradle as paradigmatic build automator
<ul>
<li>Core concepts and basics</li>
<li>Dependency management and configurations</li>
<li>The build system as a dependency</li>
<li>Hierarchial organization</li>
<li>Isolation of imperativity</li>
<li>Declarativity via DSLs</li>
<li>Reuse via plug-ins</li>
<li>Testing plug-ins</li>
<li>Existing plugins</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="build-automation-basics-and-styles">Build automation: basics and styles</h2>
<p>It&rsquo;s just a software that automates the building of some software
<br/>
hence, all concerns that hold for sofware creation hold for build systems creation.</p>
<p><strong>Imperative style</strong>: write a script that tells the system what to do to get
from code to artifacts</p>
<ul>
<li><em>Examples</em>: make, cmake, Apache Ant</li>
<li>Verbose, repetitive</li>
<li>Configuration (declarative) and actionable (imperative) logics mixed together</li>
<li>Highly configurable</li>
</ul>
<p><strong>Declarative style</strong>: adhere to some convention, specify additional configuration,
and let the tool decide what to do actually</p>
<ul>
<li><em>Examples</em>: Apache Maven</li>
<li>Separation between <em>what</em> to do and <em>how</em> to do it</li>
<li>Configuration limited by the provided options</li>
</ul>
</section><section>
<h2 id="hybrid-automators">Hybrid automators</h2>
<p>Create a <em>declarative infrastructure</em> upon an <em>imperative basis</em>, and
<em>allow easy access to the underlying machinery</em></p>
<p><strong>DSL</strong>s are helpful in this context: they can &ldquo;hide&rdquo; imperativity without ruling it out</p>
<p>Still, many challenges remain open:</p>
<ul>
<li>How to reuse the build logic?
<ul>
<li>within a project, and among projects</li>
</ul>
</li>
<li>How to structure multiple logical and interdependent parts?</li>
</ul>
</section><section>
<h1 id="gradle">Gradle</h1>
<p>A paradigmatic example of a hybrid automator:</p>
<ul>
<li>Written mostly in Java</li>
<li>with an outer Groovy DSL</li>
<li>&hellip;and, more recently, a Kotlin DSL</li>
</ul>
<h3 id="our-approach-to-gradle">Our approach to Gradle</h3>
<ul>
<li>We are <strong>not</strong> going to learn &ldquo;how to use Gradle&rdquo;</li>
<li>We are going to <em>learn Gradle</em></li>
</ul>
</section><section>
<h2 id="gradle-main-concepts">Gradle: main concepts</h2>
<ul>
<li><strong>Project</strong> &ndash; A collection of files comprising the software
<ul>
<li>A project can contain another project:</li>
<li>the container project is the <strong>root project</strong></li>
<li>the contained projects are <strong>subproject</strong>s</li>
</ul>
</li>
<li><strong>Build file</strong> &ndash; A special file, situated in the root directory of a project,
instructing Gradle on the actual organization of the project projects</li>
<li><strong>Dependency</strong> &ndash; A resource required by some operation.
<ul>
<li>May have dependencies itself</li>
<li>Dependencies of dependencies are called <em>transitive</em> dependencies</li>
</ul>
</li>
<li><strong>Configuration</strong> &ndash; A group of dependencies with <em>three roles</em>:
<ol>
<li><em>Declare</em> dependencies</li>
<li><em>Resolve</em> dependency declarations to actual artifacts/resources</li>
<li><em>Present</em> the dependencies to consumer in a suitable format</li>
</ol>
</li>
<li><strong>Task</strong> &ndash; An atomic operation on the project, which can
<ul>
<li>have input and output files</li>
<li>depend on other tasks (can be executed only if those are completed)</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="gradle-from-scratch-empty-project">Gradle from scratch: empty project</h2>
<p>Let&rsquo;s start as empty as possible, just point your terminal to an empty folder and:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle tasks
</code></pre></div><p>Stuff happens: if nothing is specified,
<br>
<em>Gradle considers the folder where it is invoked as a project</em>
<br>
<em>The project name matches the folder name</em></p>
<p>Let&rsquo;s understand what:
<br></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>Welcome to Gradle &lt;version&gt;!

Here are the highlights of this release:
 - Blah blah blah

Starting a Gradle Daemon (subsequent builds will be faster)
</code></pre></div><p>Up to there, it&rsquo;s just performance stuff:
Gradle uses a background service to speed up cacheable operations</p>
</section><section>
<h2 id="gradle-from-scratch-empty-project-1">Gradle from scratch: empty project</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>&gt; Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.
</code></pre></div><p>Some tasks exist already!
They are built-in.
Let&rsquo;s ignore them for now.</p>
</section><section>
<h2 id="gradle-from-scratch-empty-project-2">Gradle from scratch: empty project</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
components - Displays the components produced by root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>. [incubating]
dependencies - Displays all dependencies declared in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
dependencyInsight - Displays the insight into a specific dependency in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
dependentComponents - Displays the dependent components of components in root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>. [incubating]
<span style="color:#038">help</span> - Displays a <span style="color:#038">help</span> message.
model - Displays the configuration model of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>. [incubating]
outgoingVariants - Displays the outgoing variants of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
projects - Displays the sub-projects of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
properties - Displays the properties of root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
tasks - Displays the tasks runnable from root project <span style="color:#d20;background-color:#fff0f0">&#39;00-empty&#39;</span>.
</code></pre></div><p>Informational tasks. Among them, the <code>tasks</code> task we just invoked</p>
</section><section>
<h2 id="gradle-configuration-vs-execution">Gradle: configuration vs execution</h2>
<p>It is time to create our first <em>task</em>
<br>
Create a <code>build.gradle.kts</code> file as follows:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;brokenTask&#34;</span>) { <span style="color:#888">// creates a new task
</span><span style="color:#888"></span>    println(<span style="color:#d20;background-color:#fff0f0">&#34;this is executed at CONFIGURATION time!&#34;</span>)
}
</code></pre></div><p>Now launch gradle with <code>gradle brokenTask</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle broken
this is executed at CONFIGURATION time!

BUILD SUCCESSFUL in 378ms
</code></pre></div><p>Looks ok, but it&rsquo;s <strong>utterly broken</strong></p>
</section><section>
<h2 id="gradle-configuration-vs-execution-1">Gradle: configuration vs execution</h2>
<p>Try launching <code>gradle tasks</code></p>
<ul>
<li>We do not expect our task to run, we are launching something else</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>❯ gradle tasks

&gt; Task :tasks

------------------------------------------------------------
Tasks runnable from root project
------------------------------------------------------------

this is executed at CONFIGURATION time!
Build Setup tasks
</code></pre></div><p><strong>Ouch!</strong></p>
<p><strong>Reason</strong>: the build script executes when Gradle is invoked, and <em>configures</em> tasks and dependencies.
<br>
Only later, when a task is invoked, it is <em>actually executed</em></p>
</section><section>
<h2 id="gradle-configuration-vs-execution-2">Gradle: configuration vs execution</h2>
<p>Let&rsquo;s write a <em>correct</em> task</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;helloWorld&#34;</span>) {
    doLast { <span style="color:#888">// This method takes as argument a Task.() -&gt; Unit
</span><span style="color:#888"></span>        println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, World!&#34;</span>)
    }
}
</code></pre></div><p>Execution with <code>gradle helloWorld</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle helloWorld

&gt; Task :helloWorld
Hello, World!
</code></pre></div></section><section>
<h2 id="gradle-configuration-vs-execution-3">Gradle: configuration vs execution</h2>
<h3 id="why-two-separate-phases">Why two separate phases?</h3>
<p>Delaying the actual execution allows for a more <em>fine grained configuration</em>
<br>
This will be especially useful when <em>modifying existing behavior</em></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;helloWorld&#34;</span>) {
    doLast { println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, World!&#34;</span>) }
}

tasks.<span style="color:#369">getByName</span>(<span style="color:#d20;background-color:#fff0f0">&#34;helloWorld&#34;</span>) { <span style="color:#888">// let&#39;s find an existing task 
</span><span style="color:#888"></span>    doFirst { <span style="color:#888">// Similar to doLast, but adds operations in head
</span><span style="color:#888"></span>        println(<span style="color:#d20;background-color:#fff0f0">&#34;Configured later, executed first.&#34;</span>)
    }  
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle helloWorld

&gt; Task :helloWorld
Configured later, executed first.
Hello, World!
</code></pre></div></section><section>
<h2 id="gradle-task-types">Gradle: task types</h2>
<p>Gradle offers some facilities to make it writing new tasks easier
<br>
An example is the <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/Exec.html"><code>org.gradle.api.Exec</code></a> task type, representing a command to be executed on the underlying command line</p>
<p>At task registration time, it is possible to specify the task type.
<br>
Any <code>open class</code> implementing <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html"><code>org.gradle.api.Task</code></a> can be instanced</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.gradle.internal.jvm.Jvm</span> <span style="color:#888">// Jvm is part of the Gradle API
</span><span style="color:#888"></span>tasks.<span style="color:#369">register</span>&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;printJavaVersion&#34;</span>) { <span style="color:#888">// Do you Recognize this? inline function with reified type!
</span><span style="color:#888"></span>    <span style="color:#888">// Configuration action is of type T.() -&gt; Unit, in this case Exec.T() -&gt; Unit
</span><span style="color:#888"></span>    val javaExecutable = Jvm.<span style="color:#369">current</span>().<span style="color:#369">javaExecutable</span>.<span style="color:#369">absolutePath</span> 
    commandLine( <span style="color:#888">// this is a method of class org.gradle.api.Exec
</span><span style="color:#888"></span>        javaExecutable, <span style="color:#d20;background-color:#fff0f0">&#34;-version&#34;</span>
    )
    <span style="color:#888">// There is no need of doLast / doFirst, actions are already configured
</span><span style="color:#888"></span>    <span style="color:#888">// Still, we may want to do something before or after the task has been executed
</span><span style="color:#888"></span>    doLast { println(<span style="color:#d20;background-color:#fff0f0">&#34;$javaExecutable invocation complete&#34;</span>) }
    doFirst { println(<span style="color:#d20;background-color:#fff0f0">&#34;Ready to invoke $javaExecutable&#34;</span>) }
}
</code></pre></div><pre><code>&gt; Task :printJavaVersion
Ready to invoke /usr/lib/jvm/java-11-openjdk/bin/java
openjdk version &quot;11.0.8&quot; 2020-07-14
OpenJDK Runtime Environment (build 11.0.8+10)
OpenJDK 64-Bit Server VM (build 11.0.8+10, mixed mode)
/usr/lib/jvm/java-11-openjdk/bin/java invocation complete
</code></pre></section><section>
<h2 id="gradle-principle-of-automation">Gradle: principle of automation</h2>
<p>Let&rsquo;s try something more involved: compiling some Java source located in <code>src</code>.
<br></p>
<h4 id="principle"><strong>PRINCIPLE</strong></h4>
<blockquote>
<p><em>If you know how to do it, then you can instruct a machine to do it</em></p>
</blockquote>
<p>Compiling a Java source is just matter of invoking the <code>javac</code> compiler:</p>
<ul>
<li>Passing the files to be compiled</li>
<li>Passing an appropriate classpath where to look for dependencies</li>
<li>Passing where to put generated files</li>
</ul>
<p><em>Once you learn how some product is built, and you know how to build it by hand</em>
<br>
<strong>you have all the knowledge required to automate its construction</strong></p>
</section><section>
<h2 id="gradle-compiling-from-scratch">Gradle: compiling from scratch</h2>
<p>Let&rsquo;s compile a simple <code>src/HelloWorld.java</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">HelloWorld</span> {
    <span style="color:#080;font-weight:bold">public</span> <span style="color:#080;font-weight:bold">static</span> <span style="color:#888;font-weight:bold">void</span> <span style="color:#06b;font-weight:bold">main</span>(String... args) {
        System.<span style="color:#369">out</span>.<span style="color:#369">println</span>(<span style="color:#d20;background-color:#fff0f0">&#34;Hello, World!&#34;</span>);
    }
}
</code></pre></div><p>Build logic:</p>
<ol>
<li>Find the sources to be compiled</li>
<li>If any, find <code>javac</code></li>
<li>Invoke <code>javac -d destination &lt;files&gt;</code></li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.gradle.internal.jvm.Jvm</span>
tasks.<span style="color:#369">register</span>&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) {
    val sources = findSources() <span style="color:#888">// 
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (sources.<span style="color:#369">isNotEmpty</span>())  { <span style="color:#888">// If the folder exists and there are files
</span><span style="color:#888"></span>        val javacExecutable = Jvm.<span style="color:#369">current</span>().<span style="color:#369">javacExecutable</span>.<span style="color:#369">absolutePath</span> <span style="color:#888">// Use the current JVM&#39;s javac
</span><span style="color:#888"></span>        commandLine(
            <span style="color:#d20;background-color:#fff0f0">&#34;$javacExecutable&#34;</span>,
            <span style="color:#d20;background-color:#fff0f0">&#34;-d&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/bin&#34;</span>, <span style="color:#888">// destination folder: the output directory of Gradle, inside &#34;bin&#34;
</span><span style="color:#888"></span>            *sources
        )
    }
    <span style="color:#888">// the task&#39;s doLast is inherited from Exec
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h2 id="gradle-compiling-from-scratch-1">Gradle: compiling from scratch</h2>
<p>Here is the <code>findSources()</code> function:</p>
<ul>
<li>Pure Kotlin</li>
<li>Single expression</li>
<li>Fluent safe call chaining</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>(): Array&lt;String&gt; = projectDir <span style="color:#888">// From the project
</span><span style="color:#888"></span>    .listFiles { it: File -&gt; it.isDirectory &amp;&amp; it.name == <span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span> } <span style="color:#888">// Find a folder named &#39;src&#39;
</span><span style="color:#888"></span>    ?.firstOrNull() <span style="color:#888">// If it&#39;s not there we&#39;re done
</span><span style="color:#888"></span>    ?.walk() <span style="color:#888">// If it&#39;s there, iterate all its content (returns a Sequence&lt;File&gt;)
</span><span style="color:#888"></span>    ?.filter { it.extension == <span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span> } <span style="color:#888">// Pick all Java files
</span><span style="color:#888"></span>    ?.map { it.absolutePath } <span style="color:#888">// Map them to their absolute path
</span><span style="color:#888"></span>    ?.toList() <span style="color:#888">// Sequences can&#39;t get converted to arrays, we must go through lists
</span><span style="color:#888"></span>    ?.toTypedArray() <span style="color:#888">// Convert to Array&lt;String&gt;
</span><span style="color:#888"></span>    ?: emptyArray() <span style="color:#888">// Yeah if anything&#39;s missing there are no sources
</span></code></pre></div><p>Execution:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle compileJava

BUILD SUCCESSFUL in 693ms
</code></pre></div><p>Compiled files are in <code>build/bin</code>!</p>
</section><section>
<h2 id="gradle-dependency-management">Gradle: dependency management</h2>
<p>Dependency management in Gradle depends from two fundamental concepts:</p>
<ul>
<li><strong>Dependency</strong>, a resource of some kind, possibly having other (<em>transitive</em>) dependencies</li>
<li><strong>Configuration</strong>, a <em>resolvable</em> (mappable to actual resources) set of dependencies</li>
</ul>
<p>Let&rsquo;s see a use case: compiling a Java source with a dependency</p>
<ul>
<li>In <code>javac</code> terms, we need to feed some jars to the <code>-cp</code> flag of the compiler</li>
<li>In Gradle (automation) terms, we need:
<ul>
<li>a <em>configuration</em> representing the compile classpath</li>
<li>one <em>dependency</em> for each library we need to compile</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="gradle-dependency-management-1">Gradle: dependency management</h2>
<p>Conceptually, we want something like:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Gradle way to create a configuration
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">compileClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating <span style="color:#888">// Delegation!
</span><span style="color:#888"></span>dependencies {
    forEachLibrary { <span style="color:#888">// this function does not exist, unfortunate...
</span><span style="color:#888"></span>        compileClasspath(files(it))
    }
}
</code></pre></div><p>To be consumed by our improved compile task:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) {
    <span style="color:#888">// Resolve the classpath configuration (in general, files could be remote and need fetching)
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">classpathFiles</span> = compileClasspath.resolve()
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">sources</span> = findSources() <span style="color:#888">// Find sources
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">if</span> (sources != <span style="color:#080;font-weight:bold">null</span>)  {
        <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">javacExecutable</span> = Jvm.current().javacExecutable.absolutePath
        <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">separator</span> = <span style="color:#080;font-weight:bold">if</span> (Os.isFamily(Os.FAMILY_WINDOWS)) <span style="color:#d20;background-color:#fff0f0">&#34;;&#34;</span> <span style="color:#080;font-weight:bold">else</span> <span style="color:#d20;background-color:#fff0f0">&#34;:&#34;</span> <span style="color:#888">// Deal with Windows conventions
</span><span style="color:#888"></span>        commandLine(
            <span style="color:#d20;background-color:#fff0f0">&#34;$javacExecutable&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;-cp&#34;</span>, classpathFiles.joinToString(separator = separator),
            <span style="color:#d20;background-color:#fff0f0">&#34;-d&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;bin&#34;</span>, *sources
        )
    }
}
</code></pre></div><p>We just need to write <code>forEachLibrary</code>, but that is just a Kotlin exercise&hellip;</p>
</section><section>
<h2 id="micro-exercise-in-kotlin">Micro exercise in Kotlin</h2>
<p>&hellip;not particularly difficult to solve:</p>
<ol>
<li>It&rsquo;s just something we need to do for each library</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// In the context of a DependencyHandlerScope
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">DependencyHandlerScope</span>.forEachLibrary(todo: DependencyHandlerScope.(String) -&gt; Unit) {
    findLibraries().forEach { <span style="color:#888">// For each library (function to be written)
</span><span style="color:#888"></span>        todo(it) <span style="color:#888">// this.todo(it) -&gt; invoke todo on this passing the library
</span><span style="color:#888"></span>    }
}
</code></pre></div><ol start="2">
<li><code>findLibraries()</code> is similar to <code>findSources()</code>, let&rsquo;s refactor:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span>) <span style="color:#888">// OK now we need findFiles()
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findLibraries</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;lib&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;jar&#34;</span>) <span style="color:#888">// And we also need a way to invoke withExtension
</span></code></pre></div><ol start="3">
<li>Let&rsquo;s use an intermediate class representing a search on a folder:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findFilesIn</span>(directory: String) = FinderInFolder(directory)
<span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FinderInFolder</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">directory</span>: String) {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">withExtension</span>(extension: String): Array&lt;String&gt; = TODO()
}
<span style="color:#888">// Now it compiles! We just need to write the actual method, but that&#39;s easy
</span></code></pre></div></section><section>
<h2 id="micro-exercise-in-kotlin-1">Micro exercise in Kotlin</h2>
<p>Complete solution:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FinderInFolder</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">directory</span>: String) {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">withExtension</span>(extension: String): Array&lt;String&gt; = projectDir
        .listFiles { it: File -&gt; it.isDirectory &amp;&amp; it.name == directory }
        ?.firstOrNull()
        ?.walk()
        ?.filter { it.extension == extension }
        ?.map { it.absolutePath }
        ?.toList()
        ?.toTypedArray()
        ?: emptyArray()
}
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findFilesIn</span>(directory: String) = FinderInFolder(directory)
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span>)
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findLibraries</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;lib&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;jar&#34;</span>)
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">DependencyHandlerScope</span>.forEachLibrary(todo: DependencyHandlerScope.(String) -&gt; Unit) {
    findLibraries().forEach { todo(it) }
}

</code></pre></div></section><section>
<h2 id="gradle-task-dependencies">Gradle: task dependencies</h2>
<p>Next step: we can compile, why not executing the program as well?</p>
<ol>
<li>Let&rsquo;s define a <code>runtimeClasspath</code> configuration
<ul>
<li>&ldquo;inherits&rdquo; from <code>compileClasspath</code></li>
<li>includes the output folder</li>
<li>In general we may need stuff at runtime that we don&rsquo;t need at compile time
<ul>
<li>E.g. stuff loaded via reflection</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">runtimeClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating {
    extendsFrom(compileClasspath) <span style="color:#888">// Built-in machinery to say that one configuration is another &#34;plus stuff&#34;
</span><span style="color:#888"></span>}
dependencies {
    ...
    runtimeClasspath(files(<span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/bin&#34;</span>))
}
</code></pre></div><ol start="2">
<li>Let&rsquo;s write the task</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;runJava&#34;</span>) {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">classpathFiles</span> = runtimeClasspath.resolve()
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">mainClass</span> = <span style="color:#d20;background-color:#fff0f0">&#34;PrintException&#34;</span> <span style="color:#888">// Horribly hardcoded, we must do something
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">javaExecutable</span> = Jvm.current().javaExecutable.absolutePath
    commandLine(javaExecutable, <span style="color:#d20;background-color:#fff0f0">&#34;-cp&#34;</span>, classpathFiles.joinToString(separator = separator), mainClass)
}
</code></pre></div></section><section>
<h2 id="gradle-task-dependencies-1">Gradle: task dependencies</h2>
<p>Let&rsquo;s run it!</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>❯ gradle runJava

&gt; Task :runJava FAILED
Error: Could not find or load main class PrintException
Caused by: java.lang.ClassNotFoundException: PrintException

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed <span style="color:#080;font-weight:bold">for</span> task <span style="color:#d20;background-color:#fff0f0">&#39;:runJava&#39;</span>.
&gt; Process <span style="color:#d20;background-color:#fff0f0">&#39;command &#39;</span>/usr/lib/jvm/java-11-openjdk/bin/java<span style="color:#d20;background-color:#fff0f0">&#39;&#39;</span> finished with non-zero <span style="color:#038">exit</span> value <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><p>$\Rightarrow$ The code was not compiled!</p>
<ul>
<li>We need <code>runJava</code> to run after <code>compileJava</code></li>
<li>One task depends on another!</li>
</ul>
</section><section>
<h2 id="gradle-task-dependencies-2">Gradle: task dependencies</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Let&#39;s get a reference to the task
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">compileJava</span> = tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) {
    ...
}
tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;runJava&#34;</span>) {
    ...
    dependsOn(compileJava) <span style="color:#888">// runJava can run only if compileJava has been run
</span><span style="color:#888"></span>}

</code></pre></div><p>Run now:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#369">TERM</span>=dumb gradle runJava
&gt; Task :compileJava

&gt; Task :runJava
java.lang.IllegalStateException
        at PrintException.main(PrintException.java:5)

Just printed a stacktrace, I<span style="color:#a61717;background-color:#e3d2d2">&#39;</span>m fine actually

BUILD SUCCESSFUL in 775ms
<span style="color:#00d;font-weight:bold">2</span> actionable tasks: <span style="color:#00d;font-weight:bold">2</span> executed
</code></pre></div></section><section>
<h2 id="build-automation-dependencies-everywhere">Build automation: dependencies everywhere</h2>
<p>Dependencies permeate the world of build automation.</p>
<ul>
<li>At the <em>&ldquo;task&rdquo;</em> level
<ul>
<li>Compile dependencies</li>
<li>Runtime dependencies</li>
</ul>
</li>
<li>At the <em>&ldquo;build&rdquo;</em> level
<ul>
<li>Phases of the lifecycle (<em>configurations</em> in Gradle) depend on other phases</li>
<li><em>Tasks</em> depend on other tasks</li>
</ul>
</li>
</ul>
<p>$\Rightarrow$ <em>at the <strong>global</strong> level as well!</em></p>
<p><em>no guarantee</em>  that automation written with some tool at version <code>X</code>, will work at version <code>Y</code>!</p>
</section><section>
<h2 id="the-gradle-wrapper">The Gradle wrapper</h2>
<ul>
<li>A global dependency on the build tool is <strong>hard to capture</strong></li>
<li>Often, it becomes a <em>prerequisite expressed in natural language</em>
<ul>
<li>e.g., &ldquo;you need Maven 3.6.1 to build this software&rdquo;</li>
</ul>
</li>
<li><em>Critical</em> issues when different pieces of the same system depend on different build tool versions</li>
</ul>
<p>Gradle proposes a (partial) solution with the so-called <em>Gradle wrapper</em></p>
<ul>
<li><em>A minimal program</em> that simply downloads the version of gradle written in a configuration file</li>
<li><em>Generable</em> with the built-in task <code>wrapper</code>
<ul>
<li><code>gradle wrapper --gradle-version=&lt;VERSION&gt;</code></li>
</ul>
</li>
<li>Prepares scripts for bash and cmd to run Gradle at the specified version
<ul>
<li><code>gradlew</code></li>
<li><code>gradlew.bat</code></li>
</ul>
</li>
</ul>
<p>The Gradle wrapper is <em>the correct way</em> to use gradle, and we&rsquo;ll be using it from now on.</p>
</section><section>
<h2 id="cleaning-up">Cleaning up</h2>
<p>A source of failures when building is <em>dirty status</em>.
<br>
For istance, in the previous example, before we introduced a dependency between tasks:</p>
<ul>
<li>clean execution fails</li>
<li>execution after a <em>manual</em> execution of compile works
<ul>
<li><strong>false positive!</strong></li>
</ul>
</li>
</ul>
<p>We need a way to start clean.
<br>
This usually involves cleaning up the build directory - not so hard in our example</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.register(<span style="color:#d20;background-color:#fff0f0">&#34;clean&#34;</span>) { <span style="color:#888">// A generic task is fine
</span><span style="color:#888"></span>    doLast {
        <span style="color:#080;font-weight:bold">if</span> (!buildDir.deleteRecursively()) {
            <span style="color:#080;font-weight:bold">throw</span> IllegalStateException(<span style="color:#d20;background-color:#fff0f0">&#34;Cannot delete $buildDir&#34;</span>)
        }
    }
}
</code></pre></div></section><section>
<h2 id="build-hierarchies">Build hierarchies</h2>
<p>Sometimes projects are <em>modular</em>
<br>
Where a module is a sub-project with a clear identity, possibly reusable elsewhere</p>
<p>Examples:</p>
<ul>
<li>A smartphone application with:
<ul>
<li>A common library</li>
<li>A software that uses such library for the actual app</li>
</ul>
</li>
<li>Bluetooth control software comprising:
<ul>
<li>Platform-specific drivers</li>
<li>A platform-agnostic bluetooth API and service</li>
<li>A CLI interface to the library</li>
<li>A Graphical interface</li>
</ul>
</li>
</ul>
<p>Modular software <em>simplifies maintenance</em> and <em>improves understandability</em>
<br>
Modules may <strong>depend</strong> on other modules
<br>
Some build tasks of some module may require build tasks <em>of other modules</em> to be complete before execution</p>
</section><section>
<h2 id="hierarchial-project">Hierarchial project</h2>
<p>Let us split our project into two components:</p>
<ul>
<li>A base library</li>
<li>A stand-alone application using the library</li>
</ul>
<p>We need to reorganize the build logic to something similar to</p>
<pre><code>hierarchial-project
|__:library
\__:app
</code></pre><p>Desiderata:</p>
<ul>
<li>We can compile any of the two projects from the root</li>
<li>We can run the app from the root</li>
<li>Calling a run of the app implies a compilation of the library</li>
<li>We can clean both projects</li>
</ul>
</section><section>
<h2 id="authoring-subprojects-in-gradle">Authoring subprojects in Gradle</h2>
<p>Gradle (as many other build automators)
offers built-in support for <em>hierarchial projects</em>.
<br>
Gradle is limited to <em>two levels</em>, other products such as Maven have no limitation</p>
<p>Subprojects are listed in a <code>settings.gradle.kts</code> file
<br>
Incidentally, it&rsquo;s the same place where the project name can be specified</p>
<p>Subprojects <em>must have their own</em> <code>build.gradle.kts</code>
<br>
They can also have their own <code>settings.gradle.kts</code>, e.g. for selecting a name different than their folder</p>
</section><section>
<h2 id="authoring-subprojects-in-gradle-1">Authoring subprojects in Gradle</h2>
<ol>
<li>Create a settings.gradle.kts and declare your modules:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>rootProject.<span style="color:#369">name</span> = <span style="color:#d20;background-color:#fff0f0">&#34;project-with-hierarchy&#34;</span>

include(<span style="color:#d20;background-color:#fff0f0">&#34;:library&#34;</span>) <span style="color:#888">// There must be a folder named &#34;library&#34;
</span><span style="color:#888"></span>include(<span style="color:#d20;background-color:#fff0f0">&#34;:app&#34;</span>) <span style="color:#888">// There must be a folder named &#34;app&#34;
</span></code></pre></div><ol start="2">
<li>In the root project, configure the part common to <strong>all</strong> projects in a <code>allprojects</code> block
<ul>
<li>e.g., in our case, the <code>clean</code> task should be available for each project</li>
</ul>
</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>allprojects {
    tasks.<span style="color:#369">register</span>(<span style="color:#d20;background-color:#fff0f0">&#34;clean&#34;</span>) { <span style="color:#888">// A generic task is fine
</span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">if</span> (!buildDir.<span style="color:#369">deleteRecursively</span>()) {
            <span style="color:#080;font-weight:bold">throw</span> <span style="color:#06b;font-weight:bold">IllegalStateException</span>(<span style="color:#d20;background-color:#fff0f0">&#34;Cannot delete $buildDir&#34;</span>)
        }
    }
}
</code></pre></div></section><section>
<h2 id="authoring-subprojects-in-gradle-2">Authoring subprojects in Gradle</h2>
<ol start="3">
<li>Put the part shared by <em>solely the sub-projects</em> into a <code>subprojects</code> block
<ul>
<li>e.g., in our case, the <code>compileJava</code> task and the related utilities</li>
</ul>
</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>subprojects {
    <span style="color:#888">// This must be there, as projectDir must refer to the *current* project
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FinderInFolder</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">directory</span>: String) ...
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findFilesIn</span>(directory: String) = FinderInFolder(directory)
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findSources</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;src&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span>)
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">findLibraries</span>() = findFilesIn(<span style="color:#d20;background-color:#fff0f0">&#34;lib&#34;</span>).withExtension(<span style="color:#d20;background-color:#fff0f0">&#34;jar&#34;</span>)
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">DependencyHandlerScope</span>.forEachLibrary(todo: DependencyHandlerScope.(String) -&gt; Unit) ...
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">compileClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">runtimeClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating { extendsFrom(compileClasspath) }
    dependencies { ... }
    tasks.register&lt;Exec&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>) { ... }
}
</code></pre></div></section><section>
<h2 id="authoring-subprojects-in-gradle-3">Authoring subprojects in Gradle</h2>
<ol start="4">
<li>In each subproject&rsquo;s <code>build.gradle.kts</code>, add further customization as necessary
<ul>
<li>e.g., in our case, the <code>runJava</code> task can live in the <code>:app</code> subroject</li>
</ul>
</li>
<li>Connect configurations to each other using dependencies
<ul>
<li>in <code>app</code>'s <code>build.gradle.kts</code>, for instance:</li>
</ul>
</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>dependencies {
    compileClasspath(project(<span style="color:#d20;background-color:#fff0f0">&#34;:library&#34;</span>)) { <span style="color:#888">// My compileClasspath configuration depends on project library
</span><span style="color:#888"></span>        targetConfiguration = <span style="color:#d20;background-color:#fff0f0">&#34;runtimeClasspath&#34;</span> <span style="color:#888">// Specifically, from its runtime
</span><span style="color:#888"></span>    }
}
</code></pre></div><ol start="6">
<li>Declare inter-subproject task dependencies
<ul>
<li>Tasks may fail if ran out of order!</li>
<li>Compiling <code>app</code> requires <code>library</code> to be compiled!</li>
<li>inside <code>app</code>'s <code>build.gradle.kts</code>:</li>
</ul>
</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.<span style="color:#369">compileJava</span> { dependsOn(project(<span style="color:#d20;background-color:#fff0f0">&#34;:library&#34;</span>).<span style="color:#369">tasks</span>.<span style="color:#369">compileJava</span>) }
</code></pre></div><p><em>Note</em>: <code>library</code>'s <code>build.gradle.kts</code> is actually empty at the end of the process</p>
</section><section>
<h2 id="mixed-imperativity-and-declarativity">Mixed imperativity and declarativity</h2>
<p>At the moment, we have part of the project that&rsquo;s declarative, and part that&rsquo;s imperative:</p>
<ul>
<li><strong>Declarative</strong>
<ul>
<li>configurations and their relationships</li>
<li>dependencies</li>
<li>task dependencies</li>
<li>project hierarchy definition</li>
<li>some parts of the task configuration</li>
</ul>
</li>
<li><strong>Imperative</strong>
<ul>
<li>Operations on the file system</li>
<li>some of the actual task logics</li>
<li>resolution of configurations</li>
</ul>
</li>
</ul>
<p>The <em>declarative</em> part is the one <em>for which we had a built-in API for</em>!</p>
</section><section>
<h2 id="unavoidability-of-imperativity">Unavoidability of imperativity</h2>
<h3 id="and-its-isolation">(and its isolation)</h3>
<p>The base mechanism at work here is <em>hiding imperativity under a clean, declarative API</em>.</p>
<p>Also <em>&ldquo;purely declarative&rdquo;</em> build systems, such as Maven, which are driven with markup files, <em>hide</em> their imperativity behind a curtain (in the case of Maven, plugins that are configured in the <code>pom.xml</code>, but implemented elsewhere).</p>
<p><em>Usability</em>, <em>understandability</em>, and, ultimately, <em>maintability</em>, get increased when:</p>
<ul>
<li><em>Imperativity</em> gets <em>hidden</em> under the hood</li>
<li>Most (if not all) the operations can be <em>configured</em> rather than <em>written</em></li>
<li>Configuration can be <em>minimal for common tasks</em>
<ul>
<li><strong>Convention over configuration</strong>, we&rsquo;ll get back to this</li>
</ul>
</li>
<li>Users can <em>resort to imperativity</em> in case of need</li>
</ul>
</section><section>
<h2 id="isolation-of-imperativity">Isolation of imperativity</h2>
<h3 id="task-type-definition">Task type definition</h3>
<p>Let&rsquo;s begin our operation of isolation of imperativity by refactoring our hierarchy of operations.</p>
<ul>
<li>We have a number of &ldquo;Java-related&rdquo; tasks.</li>
<li>All of them have a classpath</li>
<li>One has an output directory</li>
<li>One has a &ldquo;main class&rdquo;</li>
</ul>


  
    
  


<figure>
  <img
    src='https://g.gravizo.com/svg?%0a%40startuml%0ainterface%20Exec%0ainterface%20JavaTask%20extends%20Exec%20%7b%0a%20%20%20%20classpath%20%3a%20Set%3cFile%3e%0a%20%20%20%20javaExecutable%20%3a%20File%0a%7d%0ainterface%20JavaCompile%20extends%20JavaTask%20%7b%0a%20%20%20%20outputDirectory%20%3a%20File%0a%7d%0ainterface%20JavaExecute%20extends%20JavaTask%20%7b%0a%20%20%20%20mainClass%20%3a%20String%0a%7d%0a%40enduml%0a'
    alt='We can use Kotlin to extend the base Gradle API and impleent our own stuff'
    />
    <figcaption>We can use Kotlin to extend the base Gradle API and impleent our own stuff</figcaption>
</figure>

</section><section>
<h2 id="creating-a-new-task-type-in-gradle">Creating a new Task type in Gradle</h2>
<p>Gradle supports the definition of new task types:</p>
<ul>
<li>New tasks <em>must implement</em> the <code>Task</code> interface
<ul>
<li>They <em>usually inherit</em> from <code>DefaultTask</code></li>
</ul>
</li>
<li>They must be <em>extensible</em> (<code>open</code>)
<ul>
<li>At runtime, Gradle creates subclasses on the fly</li>
</ul>
</li>
<li>They must have <em>a parameterless constructor annotated</em> with <code>@Inject</code>
<ul>
<li>Costruction of tasks happens via dependency injection</li>
</ul>
</li>
<li>A public method can be marked as <code>@TaskAction</code>, and will get invoked to execute the task</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Clean</span> @Inject <span style="color:#080;font-weight:bold">constructor</span>() : DefaultTask() {
    @TaskAction
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">clean</span>() {
        <span style="color:#080;font-weight:bold">if</span> (!project.buildDir.deleteRecursively()) {
            <span style="color:#080;font-weight:bold">throw</span> IllegalStateException(<span style="color:#d20;background-color:#fff0f0">&#34;Cannot delete ${project.buildDir}&#34;</span>)
        }
    }
}
</code></pre></div></section><section>
<h3 id="input-output-caching-and-continuous-build-mode">Input, output, caching, and continuous build mode</h3>
<p>In general, it is a good practice (that will become mandatory in future gradle releases)
to <em>annotate every public property</em> of a task with a marker annotation that determines whether it is an <em>input</em> or an <em>output</em>.</p>
<ul>
<li><code>@Input</code>, <code>@InputFile</code>, <code>@InputFiles</code>, <code>@InputDirectory</code>, <code>@InputDirectories</code></li>
<li><code>@OutputFile</code>, <code>@OutputFiles</code>, <code>@OutputDirectory</code>, <code>@OutputDirectories</code>
<ul>
<li><code>@Internal</code> marks some property that is used as output <em>internally</em> (not reified on the file system)</li>
</ul>
</li>
</ul>
<h4 id="why">Why?</h4>
<ol>
<li><strong>Performance</strong>
<ul>
<li>Gradle caches intermediate build results, using input and output markers to undersand whether or not some task is <em>up to date</em></li>
<li>This allows for <em>much</em> faster builds while working on large projects
<ul>
<li>Time to build completion can decrease from tens on minutes to seconds!</li>
</ul>
</li>
</ul>
</li>
<li><strong>Continuous build</strong>
<ul>
<li>When launched with the <code>-t</code> option, Gradle re-runs the requested tasks every time <em>something changes</em></li>
<li>(In/Out)put markers are used to understand <em>what</em> to actually run again</li>
</ul>
</li>
</ol>
</section><section>
<h2 id="isolation-of-imperativity-1">Isolation of imperativity</h2>
<h3 id="idea">Idea</h3>
<p>In our main <code>build.gradle.kts</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Imperative part
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#06b;font-weight:bold">JavaTask</span>(<span style="color:#369;font-style:italic">javaExecutable:</span> File = Jvm.<span style="color:#369">current</span>().<span style="color:#369">javaExecutable</span>) : Exec() { ... }sub
open <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">CompileJava</span> <span style="color:#555">@javax.inject.Inject</span> constructor() : JavaTask(Jvm.<span style="color:#369">current</span>().<span style="color:#369">javacExecutable</span>) { ... }
open <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">RunJava</span> <span style="color:#555">@javax.inject.Inject</span> constructor() : JavaTask() { ... }

<span style="color:#888">// Declarative part
</span><span style="color:#888"></span>allprojects { tasks.<span style="color:#369">register</span>&lt;Clean&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;clean&#34;</span>) }
subprojects {
    val compileClasspath by configurations.<span style="color:#369">creating</span>
    val runtimeClasspath by configurations.<span style="color:#369">creating</span> { extendsFrom(compileClasspath) }
    dependencies {
        findLibraries().<span style="color:#369">forEach</span> { compileClasspath(files(it)) }
        runtimeClasspath(files(<span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/bin&#34;</span>))
    }
    tasks.<span style="color:#369">register</span>&lt;CompileJava&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>)
}
</code></pre></div><p>In subprojects, only have the declarative part</p>
<p>Unfortunately, <em>subprojects have no access to the root&rsquo;s defined types</em></p>
<ul>
<li>Fragile access only via reflection</li>
<li>Enormous <strong>code duplication</strong></li>
</ul>
</section><section>
<h2 id="isolation-of-imperativity-2">Isolation of imperativity</h2>
<h3 id="project-wise-api-extension-plugin">Project-wise API extension (plugin)</h3>
<p>Gradle provides the functionality we need (project-global type definitions) using a special <code>buildSrc</code> folder</p>
<ul>
<li>Requires a Gradle configuration file
<ul>
<li>What it actually does will be clearer in future</li>
</ul>
</li>
<li>Requires a peculiar directory structure</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>├── build.gradle.kts
├── buildSrc
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── kotlin
│               └── OurImperativeCode.kt
└── settings.gradle.kts
</code></pre></div><ul>
<li>Allows imperative code to get <em>isolated</em> and <em>shared</em> among subprojects!</li>
</ul>
</section><section>
<h2 id="isolation-of-imperativity-3">Isolation of imperativity</h2>
<h3 id="project-wise-api-extension-plugin-1">Project-wise API extension (plugin)</h3>
<p>inside <code>buildSrc/build.gradle.kts</code> (clearer in future):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    <span style="color:#a61717;background-color:#e3d2d2">`</span>kotlin-dsl<span style="color:#a61717;background-color:#e3d2d2">`</span>
}
repositories {
    mavenCentral()
}
</code></pre></div><p>excerpt of <code>buildSrc/src/main/kotlin/JavaOperations.kt</code> (full code in the repo)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Clean</span> @Inject <span style="color:#080;font-weight:bold">constructor</span>() : DefaultTask() { ... }
<span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">JavaTask</span>(javaExecutable: File = Jvm.current().javaExecutable) : Exec() { ... }
<span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">CompileJava</span> @javax.inject.Inject <span style="color:#080;font-weight:bold">constructor</span>() : JavaTask(Jvm.current().javacExecutable) {
    @OutputDirectory <span style="color:#888">// Marks this property as an output
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">outputFolder</span>: String = <span style="color:#d20;background-color:#fff0f0">&#34;${project.buildDir}/bin/&#34;</span>
    ...
}
<span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">RunJava</span> @javax.inject.Inject <span style="color:#080;font-weight:bold">constructor</span>() : JavaTask() {
    @Input <span style="color:#888">// Marks this property as an Input
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">mainClass</span>: String = <span style="color:#d20;background-color:#fff0f0">&#34;Main&#34;</span>
    ...
}
</code></pre></div></section><section>
<h2 id="isolation-of-imperativity-4">Isolation of imperativity</h2>
<h3 id="project-wise-api-extension-plugin-2">Project-wise API extension (plugin)</h3>
<p>Our Project&rsquo;s <code>build.gradle.kts</code> (full):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>allprojects {
    tasks.register(<span style="color:#d20;background-color:#fff0f0">&#34;clean&#34;</span>) { <span style="color:#888">// A generic task is fine
</span><span style="color:#888"></span>        doLast {
            <span style="color:#080;font-weight:bold">if</span> (!buildDir.deleteRecursively()) {
                <span style="color:#080;font-weight:bold">throw</span> IllegalStateException(<span style="color:#d20;background-color:#fff0f0">&#34;Cannot delete $buildDir&#34;</span>)
            }
        }
    }
}
subprojects {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">compileClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">runtimeClasspath</span> <span style="color:#080;font-weight:bold">by</span> configurations.creating { extendsFrom(compileClasspath) }
    dependencies {
        findLibraries().forEach { compileClasspath(files(it)) }
        runtimeClasspath(files(<span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/bin&#34;</span>))
    }
    tasks.register&lt;CompileJava&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;compileJava&#34;</span>)
}

</code></pre></div><p><strong>Purely declarative, yay!</strong></p>
</section><section>
<h2 id="isolation-of-imperativity-5">Isolation of imperativity</h2>
<h3 id="project-wise-api-extension-plugin-3">Project-wise API extension (plugin)</h3>
<p>Our <code>app</code> suproject&rsquo;s <code>build.gradle.kts</code> (full):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>dependencies {
    compileClasspath(project(<span style="color:#d20;background-color:#fff0f0">&#34;:library&#34;</span>)) { targetConfiguration = <span style="color:#d20;background-color:#fff0f0">&#34;runtimeClasspath&#34;</span> }
}
tasks.<span style="color:#369">compileJava</span> {
    dependsOn(project(<span style="color:#d20;background-color:#fff0f0">&#34;:library&#34;</span>).<span style="color:#369">tasks</span>.<span style="color:#369">compileJava</span>)
    fromConfiguration(configurations.<span style="color:#369">compileClasspath</span>.<span style="color:#369">get</span>())
}
tasks.<span style="color:#369">register</span>&lt;RunJava&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;runJava&#34;</span>) {
    fromConfiguration(configurations.<span style="color:#369">runtimeClasspath</span>.<span style="color:#369">get</span>())
    mainClass = <span style="color:#d20;background-color:#fff0f0">&#34;PrintException&#34;</span>
}
</code></pre></div><p><strong>Purely declarative, yay!</strong></p>
</section><section>
<h2 id="divide-conquer-encapsulate-adorn">Divide, conquer, encapsulate, adorn</h2>
<p>General approach to a <em>new</em> build automation problem:</p>
<p><strong>Divide</strong></p>
<ul>
<li>Identify the <em>base steps</em>, they could become your task
<ul>
<li>Or any concept your build system exposes to model an atomic operation</li>
</ul>
</li>
</ul>
<p><strong>Conquer</strong></p>
<ul>
<li>Clearly express the <em>dependencies</em> among them
<ul>
<li>Build a <em>pipeline</em></li>
</ul>
</li>
<li>Implement them</li>
<li>Provide a clean API</li>
</ul>
<p><strong>Encapsulate</strong></p>
<ul>
<li>Confine imperative logic, make it an <em>implementation detail</em></li>
</ul>
<p><strong>Adorn</strong></p>
<ul>
<li>Provide expressive, easy, immedate access to the API via <em>DSL</em>!</li>
</ul>
<p><em>Not very different than what&rsquo;s usually done in (good) software development</em></p>
</section><section>
<h2 id="reusability-across-multiple-projects">Reusability across multiple projects</h2>
<p>We now have a rudimental infrastructure for building and running Java projects
<br>
What if we want to reuse it?</p>
<p>Of course, copy/pasting the same file across projects is to be avoided whenever possible</p>
<h2 id="the-concept-of-plugin">The concept of plugin</h2>
<p>Gradle (as many other build systems) allow extensibility via <em>plugins</em>
<br>
A <em>plugin</em> is a software component that <em>extends the API</em> of the base system
<br>
It usually includes:</p>
<ul>
<li>A set of <code>Task</code>s</li>
<li>An <code>Extension</code> &ndash; An object incapsulating the global configuration options
<ul>
<li>this is where the DSL capabilities get usually leveraged</li>
</ul>
</li>
<li>A <code>Plugin</code> object, implementing an <code>apply(Project)</code> function
<ul>
<li>Application must create the extension, the tasks, and the rest of the imperative stuff</li>
</ul>
</li>
<li>A <strong>manifest</strong> file declaring which of the classes implementing <code>Plugin</code> is the entry point of the declared plugin
<ul>
<li>located in <code>META-INF/gradle-plugins/&lt;plugin-name&gt;.properties</code></li>
</ul>
</li>
</ul>
</section><section>
<h2 id="using-a-plugin">Using a plugin</h2>
<ul>
<li>Plugins are loaded from the <em>build environment</em>
<ul>
<li>the <em>classpath</em> used for such tasks can be explored with the built-in task <code>buildEnvironment</code></li>
<li>if a plugin is not found, then if a version for it is available it&rsquo;s <em>fetched from remote repositories</em>
<ul>
<li>by default the <a href="https://plugins.gradle.org/">Gradle plugin portal</a></li>
</ul>
</li>
</ul>
</li>
<li>Plugin need to be <strong>applied</strong>
<ul>
<li>Which actually translates to calling the <code>apply(Project)</code> function</li>
<li>Application for <em>hierarchial</em> projects is <em>not automatic</em>
<ul>
<li>You might want your plugin to be applied only in some subprojects!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Example code</strong></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    pluginName <span style="color:#888">// Loads a plugin from the &#34;buildEnvironment&#34; classpath
</span><span style="color:#888"></span>    <span style="color:#a61717;background-color:#e3d2d2">`</span>plugin-name<span style="color:#a61717;background-color:#e3d2d2">`</span> <span style="color:#888">// Syntax for non Kotlin-compliant plugin names
</span><span style="color:#888"></span>    id(<span style="color:#d20;background-color:#fff0f0">&#34;plugin2-name&#34;</span>) <span style="color:#888">// Alternative to the former
</span><span style="color:#888"></span>    id(<span style="color:#d20;background-color:#fff0f0">&#34;some-custom-plugin&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;1.2.3&#34;</span> <span style="color:#888">// if not found locally, gets fetched from the Gradle plugin portal
</span><span style="color:#888"></span>}
<span style="color:#888">// In case of non-hierarchial projects, plugins are also &#34;applied&#34;
</span><span style="color:#888">// Otherwise, they need to get applied manually, e.g.:
</span><span style="color:#888"></span>allprojects {
    apply(plugin = <span style="color:#d20;background-color:#fff0f0">&#34;pluginName&#34;</span>)
}
</code></pre></div></section><section>
<h2 id="built-in-gradle-plugins">Built-in Gradle plugins</h2>
<p>The default Gradle distribution includes a large number of plugins, e.g.:</p>
<ul>
<li><code>java</code> plugin, for Java written applications
<ul>
<li>a full fledged version of the custom local plugin we created!</li>
</ul>
</li>
<li><code>java-library</code> plugin, for Java libraries (with no main class)</li>
<li><code>scala</code> plugin</li>
<li><code>cpp</code> plugin, for C++</li>
<li><code>kotlin</code> plugin, supporting Kotlin with multiple targets (JVM, Javascript, native)</li>
</ul>
<p>We are going to use the Kotlin JVM plugin to build our first standalone plugin!
<br>
(yes we already did write our first one: code in <code>buildSrc</code> is <em>project-local plugin code</em>)</p>
</section><section>
<h2 id="a-greeting-plugin">A Greeting plugin</h2>
<p>A very simple plugin that greets the user</p>
<p><strong>Desiderata</strong></p>
<ul>
<li>adds a <code>greet</code> task that prints a greeting</li>
<li>the default output should be configurable with something like:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    id(<span style="color:#d20;background-color:#fff0f0">&#34;it.unibo.lss.greetings&#34;</span>)
}
greetings {
    greetWith { <span style="color:#d20;background-color:#fff0f0">&#34;Ciao da&#34;</span> }
}
</code></pre></div></section><section>
<h2 id="setting-up-a-kotlin-build">Setting up a Kotlin build</h2>
<p>First step: we need to set up a Kotlin build, we&rsquo;ll write our plugin in Kotlin</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    <span style="color:#888">// No magic: calls a method running behind the scenes the same of id(&#34;org.jetbrains.kotlin-&#34; + &#34;jvm&#34;)
</span><span style="color:#888"></span>    kotlin(<span style="color:#d20;background-color:#fff0f0">&#34;jvm&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;1.4.10&#34;</span> <span style="color:#888">// version is necessary
</span><span style="color:#888"></span>}
</code></pre></div><p>The Kotlin plugin introduces:</p>
<ul>
<li>Several <em>tasks</em>, among which:
<ul>
<li><code>compileJava</code></li>
<li><code>compileKotlin</code></li>
</ul>
</li>
<li>A number of <em>configurations</em>
<ul>
<li><code>api</code>: available both at compile- and run- time, <em>exported to consumers</em></li>
<li><code>implementation</code>: available both at compile- and run- time, <em>not exported to consumers</em>
<ul>
<li>internal logic, implementation details</li>
</ul>
</li>
<li><code>compileOnly</code>: available at <em>compile time only</em> (e.g. compile time annotations)</li>
<li><code>runtimeOnly</code>: available at <em>runtime only</em></li>
</ul>
</li>
</ul>
</section><section>
<h2 id="importing-the-standard-library">Importing the standard library</h2>
<p>Libraries can be imported in Gradle from <code>repositories</code></p>
<ul>
<li>Several packaging formats supported, among wich Maven repositories</li>
<li>Maven repositories are a de-facto standard for shipping JVM libraries</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Configuration of software sources
</span><span style="color:#888"></span>repositories {
    jcenter() <span style="color:#888">// points to JCenter Bintray
</span><span style="color:#888"></span>    <span style="color:#888">// mavenCentral() // points to Maven Central instead or additionally
</span><span style="color:#888"></span>}

dependencies {
     <span style="color:#888">// &#34;implementation&#34; is a configuration created by by the Kotlin plugin
</span><span style="color:#888"></span>    implementation(kotlin(<span style="color:#d20;background-color:#fff0f0">&#34;stdlib-jdk8&#34;</span>)) <span style="color:#888">// &#34;kotlin&#34; is an extension method of DependencyHandler
</span><span style="color:#888"></span>    <span style="color:#888">// The call to &#34;kotlin&#34; passing `module`, returns a String &#34;org.jetbrains.kotlin:kotlin-$module:&lt;KotlinVersion&gt;&#34;
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h2 id="importing-the-gradle-api">Importing the Gradle API</h2>
<p>In order to develop a plugin, we need the Gradle API</p>
<ul>
<li>Otherwise, we can&rsquo;t manipulate any Gradle entity&hellip;</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>dependencies {
    implementation(kotlin(<span style="color:#d20;background-color:#fff0f0">&#34;stdlib-jdk8&#34;</span>))
    implementation(gradleApi()) <span style="color:#888">// Built-in method, returns a `Dependency` to the current Gradle version
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h2 id="plugin-name-and-entry-point">Plugin name and entry point</h2>
<p>Gradle expects the plugin entry point (the class implementing the <code>Plugin</code> interface) to be specified in a <strong>manifest file</strong></p>
<ul>
<li>in a <em>property file</em></li>
<li>located in <code>META-INF/gradle-plugins</code></li>
<li>whose file name is <code>&lt;plugin-name&gt;.properties</code></li>
</ul>
<p>The name is usually a &ldquo;reverse url&rdquo;, similarly to Java packages.
<br>
e.g., <code>it.unibo.lss.greetings</code></p>
<p>The file content is just a pointer to the class implementing <code>Plugin</code>, in our case:</p>
<pre><code class="nohighlight" data-noescape>implementation-class=it.unibo.lss.firstplugin.GreetingPlugin
</code></pre></section><section>
<h2 id="plugin-implementation">Plugin implementation</h2>
<p>Usually, composed by:</p>
<ul>
<li>A <em>clean API</em>, if the controlled system is not trivial</li>
<li>A set of <em>tasks</em> incapuslating the imperative logic</li>
<li>An <em>extension</em> containing the DSL for configuring the plugin</li>
<li>A <em>plugin</em>
<ul>
<li>Creates the extension</li>
<li>Creates the tasks</li>
<li>Links tasks and extension</li>
</ul>
</li>
</ul>
</section><section>
<h2 id="lazy-configuration-in-gradle">Lazy configuration in Gradle</h2>
<p>Some properties need to be <em>lazy</em>:</p>
<ol>
<li>Wire together Gradle components without worrying about values, just knowing their <em>provider</em>.
<ul>
<li>Configuration happens <em>before</em> execution, some values be unknown</li>
<li>yet their provider is known at configuration time</li>
</ul>
</li>
<li>Automatic dependency discovery:
<ul>
<li>if an output property is an input for another task, the dependency creation is automatic</li>
</ul>
</li>
<li>Performance: resource intensive work is not in the configuration phase</li>
</ol>
<h4 id="in-the-gradle-api">In the gradle API</h4>
<p><code>Provider</code> &ndash; a value that can only be queried and cannot be changed</p>
<ul>
<li>Transformable with a <code>map</code> method!</li>
</ul>
<p><code>Property</code> &ndash; a value that can be queried and also changed</p>
<ul>
<li>Subtype of Provider</li>
<li>Allows to be directly <code>set</code> or to be <code>set</code> passing a <code>Provider</code> instance</li>
</ul>
</section><section>
<h2 id="the-greetingtask-task-type">The <code>GreetingTask</code> task type</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">GreetingTask</span> : DefaultTask() {

    @Input
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">greeting</span>: Property&lt;String&gt; = project.objects.property&lt;String&gt;(String::<span style="color:#080;font-weight:bold">class</span>.java) <span style="color:#888">// Lazy property creation
</span><span style="color:#888"></span>
    @Internal <span style="color:#888">// Read-only property calculated from `greeting`
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">message</span>: Provider&lt;String&gt; = greeting.map { <span style="color:#d20;background-color:#fff0f0">&#34;$it Gradle&#34;</span> }

    @TaskAction
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">printMessage</span>() {
        <span style="color:#888">// &#34;logger&#34; is a property of DefaultTask
</span><span style="color:#888"></span>        logger.quiet(message.<span style="color:#080;font-weight:bold">get</span>())
    }
}
</code></pre></div><p>Properties are created via <code>project</code> (a property of <code>DefaultTask</code> of type <code>Project</code>)</p>
</section><section>
<h2 id="the-greetingextension-extension-type">The <code>GreetingExtension</code> extension type</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">GreetingExtension</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">project</span>: Project) {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">defaultGreeting</span>: Property&lt;String&gt; = project.objects.property(String::<span style="color:#080;font-weight:bold">class</span>.java)
        .apply { convention(<span style="color:#d20;background-color:#fff0f0">&#34;Hello from&#34;</span>) } <span style="color:#888">// Set a conventional value
</span><span style="color:#888"></span>
    <span style="color:#888">// A DSL would go there
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">greetWith</span>(greeting: () -&gt; String) = defaultGreeting.<span style="color:#080;font-weight:bold">set</span>(greeting())
}
</code></pre></div><p>Extensions can be seen as global configuration containers
<br>
If the plugin can be driven with a DSL, the extension is a good place for the entry point</p>
</section><section>
<h2 id="the-greetingplugin">The <code>GreetingPlugin</code></h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">GreetingPlugin</span> : Plugin&lt;Project&gt; {
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">apply</span>(target: Project) {
        <span style="color:#888">// Create the extension
</span><span style="color:#888"></span>        <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">extension</span> = target.extensions.create(<span style="color:#d20;background-color:#fff0f0">&#34;greetings&#34;</span>, GreetingExtension::<span style="color:#080;font-weight:bold">class</span>.java, target)
        <span style="color:#888">// Create the task
</span><span style="color:#888"></span>        target.tasks.register(<span style="color:#d20;background-color:#fff0f0">&#34;greet&#34;</span>, GreetingTask::<span style="color:#080;font-weight:bold">class</span>.java).<span style="color:#080;font-weight:bold">get</span>().run {
            <span style="color:#888">// Set the default greeting to be the one configured in the extension
</span><span style="color:#888"></span>            greeting.<span style="color:#080;font-weight:bold">set</span>(extension.defaultGreeting)
            <span style="color:#888">// Configuration per-task can still be changed manually by users
</span><span style="color:#888"></span>        }
    }
}
</code></pre></div><ul>
<li>Extensions are created via a <code>Project</code> object</li>
<li>The <code>Plugin</code> configures the project as needed for the tasks and the extension to work</li>
<li>Plugins can forcibly <em>apply</em> other plugins
<ul>
<li>e.g., the Kotlin plugin applies the <code>java-library</code> plugin behind the scenes</li>
</ul>
</li>
<li>Plugins can <em>react</em> to the application of other plugins
<ul>
<li>e.g., enable additional features or provide compatibility</li>
<li>doing so is possible by the <code>plugins</code> property of <code>Project</code>, e.g.:</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>project.plugins.withType(JavaPlugin::<span style="color:#080;font-weight:bold">class</span>.java) {
    <span style="color:#888">// Stuff you want to do only if someone enables the Java plugin for the current project
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h2 id="testing-a-plugin">Testing a plugin</h2>
<p>We got a plugin, we don&rsquo;t know yet how to use it though.
<br>
First step is: <em>testing it to see if it works</em></p>
<ol>
<li>Create a modified <em>version of Gradle including the plugin</em>
<ul>
<li>Or simply, add the plugin to the build classpath</li>
</ul>
</li>
<li>Prepare a Gradle <em>workspace</em></li>
<li><em>Launch the tasks</em> of interest</li>
<li><em>Verify</em> the task success (or failure, if expected), or the program output</li>
</ol>
<p><strong>Tools to be used</strong></p>
<ol>
<li>The <strong>Gradle test kit</strong>, for programmatically launching Gradle and ispecting the execution results</li>
<li><a href="https://github.com/kotest/kotest">Kotest</a>, a test framework for Kotlin
<ul>
<li>could be done with JUnit or other systems, but Kotest is more idiomatic</li>
</ul>
</li>
<li>A pinch of <em>manual Gradle automation</em> to prepare the classpath</li>
</ol>
</section><section>
<h2 id="importing-gradle-test-kit-and-kotest">Importing Gradle test kit and Kotest</h2>
<p>It&rsquo;s just matter of pulling the right dependencies</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>dependencies {
    implementation(gradleApi())
    testImplementation(gradleTestKit()) <span style="color:#888">// Test implementation: available for testing compile and runtime
</span><span style="color:#888"></span>    testImplementation(<span style="color:#d20;background-color:#fff0f0">&#34;io.kotest:kotest-runner-junit5:4.2.5&#34;</span>) <span style="color:#888">// for kotest framework
</span><span style="color:#888"></span>    testImplementation(<span style="color:#d20;background-color:#fff0f0">&#34;io.kotest:kotest-assertions-core:4.2.5&#34;</span>) <span style="color:#888">// for kotest core assertions
</span><span style="color:#888"></span>    testImplementation(<span style="color:#d20;background-color:#fff0f0">&#34;io.kotest:kotest-assertions-core-jvm:4.2.5&#34;</span>) <span style="color:#888">// for kotest core jvm assertions
</span><span style="color:#888"></span>}
</code></pre></div><p>Kotest leverages Junit 5 / Jupiter for execution, we need to enable it</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.withType&lt;Test&gt; { <span style="color:#888">// The task type is defined in the Java plugin
</span><span style="color:#888"></span>    useJUnitPlatform() <span style="color:#888">// Use JUnit 5 engine
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h2 id="exploiting-configuration-options">Exploiting configuration options</h2>
<p>In general, our automation process may and should be <strong>informative</strong>
<br>
We can exploit the API of any Gradle plugin at our advantage
<br>
(Of course it depends <em>whether or not</em> configuration options are available)</p>
<p>Let&rsquo;s add information to our testing system:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.withType&lt;Test&gt; {
    useJUnitPlatform() <span style="color:#888">// Use JUnit 5 engine
</span><span style="color:#888"></span>    testLogging.showStandardStreams = <span style="color:#080;font-weight:bold">true</span>
    testLogging {
        showCauses = <span style="color:#080;font-weight:bold">true</span>
        showStackTraces = <span style="color:#080;font-weight:bold">true</span>
        showStandardStreams = <span style="color:#080;font-weight:bold">true</span>
        events(*org.gradle.api.tasks.testing.logging.TestLogEvent.values())
        exceptionFormat = org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL
    }
}
</code></pre></div><p>In general <em>explore the API and use it your advantage</em></p>
</section><section>
<h2 id="plugin-classpath-injection">Plugin Classpath injection</h2>
<p>By default, the Gradle test kit just runs Gradle.
We want to inject our plugin into the distribution.</p>
<p><strong>Strategy</strong></p>
<ol>
<li>Create the list of files composing our <em>runtime classpath</em></li>
<li>Make sure that the list is always up to date and ready before test execution</li>
<li>Use such list as our classpath for running Gradle</li>
</ol>
</section><section>
<h2 id="plugin-classpath-preparation">Plugin Classpath preparation</h2>
<p>It&rsquo;s easy enough to write a task writing our classpath in output:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// This task creates a file with a classpath descriptor, to be used in tests
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">createClasspathManifest</span> <span style="color:#080;font-weight:bold">by</span> tasks.registering { <span style="color:#888">// This delegate uses the variable name as task name
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">outputDir</span> = file(<span style="color:#d20;background-color:#fff0f0">&#34;$buildDir/$name&#34;</span>) <span style="color:#888">// We will write in this folder
</span><span style="color:#888"></span>    inputs.files(sourceSets.main.<span style="color:#080;font-weight:bold">get</span>().runtimeClasspath) <span style="color:#888">// Our input is a ready runtime classpath
</span><span style="color:#888"></span>    <span style="color:#888">// Note: due to the line above, this task implicitly requires our plugin to be compiled!
</span><span style="color:#888"></span>    outputs.dir(outputDir) <span style="color:#888">// we register the output directory as an output of the task
</span><span style="color:#888"></span>    doLast { <span style="color:#888">// This is the task the action will execute
</span><span style="color:#888"></span>        outputDir.mkdirs() <span style="color:#888">// Create the directory infrastructure
</span><span style="color:#888"></span>        <span style="color:#888">// Write a file with one classpath entry per line
</span><span style="color:#888"></span>        file(<span style="color:#d20;background-color:#fff0f0">&#34;$outputDir/plugin-classpath.txt&#34;</span>).writeText(sourceSets.main.<span style="color:#080;font-weight:bold">get</span>().runtimeClasspath.joinToString(<span style="color:#d20;background-color:#fff0f0">&#34;\n&#34;</span>))
    }
}
</code></pre></div><p>Finally, we say that for tests to run all files from <code>createClasspathManifest</code> must be ready</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>dependencies {
    <span style="color:#888">// This way &#34;createClasspathManifest&#34; is always executed before the tests!
</span><span style="color:#888"></span>    <span style="color:#888">// Gradle auto-resolves dependencies if there are dependencies on inputs/outputs
</span><span style="color:#888"></span>    testRuntimeOnly(files(createClasspathManifest))
}
</code></pre></div></section><section>
<h2 id="kotest">Kotest</h2>
<p>Kotest is a testing framework fro Kotlin, inspired by <a href="https://www.scalatest.org/">Scalatest</a> and <a href="https://cucumber.io/">Cucumber</a></p>
<ul>
<li>Supports <a href="https://github.com/kotest/kotest/blob/master/doc/styles.md">several styles</a></li>
<li>We will use <code>FreeSpec</code> (Scalatest inspired), similar to <code>StringSpec</code> (Kotest original)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">PluginTest</span> : FreeSpec({
    <span style="color:#888">// Arbitrarily nested test levels
</span><span style="color:#888"></span>    <span style="color:#d20;background-color:#fff0f0">&#34;whenever a Formula 1 championship&#34;</span> - {
        <span style="color:#d20;background-color:#fff0f0">&#34;begins testing&#34;</span> - {
            <span style="color:#d20;background-color:#fff0f0">&#34;Ferrari and Mercedes are favorites&#34;</span> {
                <span style="color:#888">// Test code for
</span><span style="color:#888"></span>                <span style="color:#888">// &#34;whenever a Formula 1 championship begins testing Ferrari and Mercedes are favorites&#34;
</span><span style="color:#888"></span>            }
        }
        <span style="color:#d20;background-color:#fff0f0">&#34;reaches mid-season&#34;</span> - {
            <span style="color:#d20;background-color:#fff0f0">&#34;Vettel spins repeatedly&#34;</span> { <span style="color:#888">/* Test code */</span> }
            <span style="color:#d20;background-color:#fff0f0">&#34;Ferrari&#34;</span> {
                <span style="color:#d20;background-color:#fff0f0">&#34;lags behind with development&#34;</span>  { <span style="color:#888">/* Test code */</span> }
                <span style="color:#d20;background-color:#fff0f0">&#34;wins next year&#34;</span> { <span style="color:#888">/* Test code */</span> }
            }
        }

    } 
})
</code></pre></div></section><section>
<h2 id="preparing-the-test-infrastructure">Preparing the test infrastructure</h2>
<p>We now need to read the classpath configuration from our file, and feed it to the Gradle runner</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Find the file
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">pluginClasspathResource</span> = ClassLoader.getSystemClassLoader().getResource(<span style="color:#d20;background-color:#fff0f0">&#34;plugin-classpath.txt&#34;</span>)
    ?: <span style="color:#080;font-weight:bold">throw</span> IllegalStateException(<span style="color:#d20;background-color:#fff0f0">&#34;Did not find the plugin classpath descriptor.&#34;</span>)
<span style="color:#888">// Extract the content
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">classpath</span> = pluginClasspathResource.openStream().bufferedReader().use { reader -&gt;
    reader.readLines().map { File(it) } <span style="color:#888">// Convert each line to a file
</span><span style="color:#888"></span>}
<span style="color:#888">// Configure a Gradle runner
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">runner</span> = GradleRunner.create()
    .withProjectDir(testFolder.root)
    .withPluginClasspath(classpath)
    .withArguments(<span style="color:#d20;background-color:#fff0f0">&#34;:tasks&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;:you&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;:need&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;:to&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;:run:&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;--and&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;--cli&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;--options&#34;</span>)
    .build() <span style="color:#888">// This actually runs Gradle
</span><span style="color:#888">// Inspect results
</span><span style="color:#888"></span>runner.task(<span style="color:#d20;background-color:#fff0f0">&#34;:someExistingTask&#34;</span>)?.outcome shouldBe TaskOutcome.SUCCESS
runner.output shouldContain <span style="color:#d20;background-color:#fff0f0">&#34;Hello from Gradle&#34;</span>
</code></pre></div><p>Final result in the <a href="https://github.com/DanySK/Course-Laboratory-of-Software-Systems/blob/master/code/automation/10-greetings-plugin/src/test/kotlin/PluginTest.kt">attached code</a>!</p>
</section><section>
<h2 id="making-the-plugin-available">Making the plugin available</h2>
<p>We now know how to run the plugin,
<br>
yet manual classpath modification is not the way we want to run our plugin</p>
<p>We want something like:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    id(<span style="color:#d20;background-color:#fff0f0">&#34;it.unibo.lss.greetings&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;0.1.0&#34;</span>
}
</code></pre></div><p>To do so, we need to ship our plugin to the <a href="https://plugins.gradle.org/">Gradle plugin portal</a>
<br>
Gradle provides <a href="https://plugins.gradle.org/docs/publish-plugin">a plugin publishing plugin</a> to simplify delivery</p>
<p>&hellip;but before, we need to learn how to</p>
<ol>
<li>
<p>click $\Rightarrow{}$ <a href="../05-version-selection"><strong>pick a version number</strong></a> $\Leftarrow{}$ click</p>
</li>
<li>
<p>click $\Rightarrow{}$ <a href="../06-licenses"><strong>select a software license</strong></a>! $\Leftarrow{}$ click</p>
</li>
</ol>
</section><section>
<h1 id="setting-a-version">Setting a version</h1>
<p>The project version can be specified in Gradle by simply setting the <code>version</code> property of the project:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>version = <span style="color:#d20;background-color:#fff0f0">&#34;0.1.0&#34;</span>
</code></pre></div><ul>
<li>Drawback: <em>manual management</em>!</li>
</ul>
<p>It would be better to <em>rely on the underlying DVCS</em>
<br>
to compute a Semantic Versioning compatible version!</p>
</section><section>
<h2 id="dvcs-based-automatic-semantic-versioning">DVCS-based Automatic semantic versioning</h2>
<p>There are a number of plugins that do so
<br>
including <a href="https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin">one I&rsquo;ve developed</a></p>
<p>Minimal configuration:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    id (<span style="color:#d20;background-color:#fff0f0">&#34;org.danilopianini.git-sensitive-semantic-versioning&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;0.2.2&#34;</span>
}
gitSemVer {
    version = computeGitSemVer()
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape> ./gradlew printGitSemVer
&gt; Task :printGitSemVer
Version computed by GitSemVer: 0.1.0-archeo+cf5b4c0
</code></pre></div><p>Another possibility is <em>writing a plugin yourself</em>
<br>
But at the moment we are stuck: we don&rsquo;t know yet how to expose plugins to other builds</p>
</section><section>
<h1 id="selecting-a-license">Selecting a license</h1>
<p>There&rsquo;s not really much I want to protect in this example, so I&rsquo;m going to pick one of the most open licenses: MIT (BSD would have been a good alternative)</p>
<ol>
<li>Create a LICENSE file</li>
<li>Copy the text from the MIT license</li>
<li>If needed, edit details</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>Copyright 2020 Danilo Pianini

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the &#34;Software&#34;), to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre></div></section><section>
<h1 id="maven-style-packaging">Maven style packaging</h1>
<p>JVM artifacts are normally shipped in form of jar archives
<br>
the de-facto convention is <em>inherited from Maven</em>:</p>
<ul>
<li>Each distribution has a <strong>groupId</strong>, an <strong>artifactId</strong>, and a <strong>version</strong>
<ul>
<li>e.g. <code>com.google.guava:guava:29.0-jre</code>
<ul>
<li>groupId: <code>com.google.guava</code></li>
<li>artifactId: <code>guava</code></li>
<li>version: <code>29.0-jre</code></li>
</ul>
</li>
</ul>
</li>
<li>Further <strong>metadata</strong> is stored in a <code>pom.xml</code> file</li>
<li>Multiple artifacts in the same distributions are identified by a <strong>classifier</strong>
<ul>
<li>e.g., a project having executables, sources, and javadoc, may have:
<ul>
<li><code>guava-29.0-jre.jar</code></li>
<li><code>guava-29.0-jre-javadoc.jar</code></li>
<li><code>guava-29.0-jre-sources.jar</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="setting-the-details">Setting the details</h1>
<p>In order to create Maven-compatible artifacts, we need first to set the <strong>groupId</strong>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>group = <span style="color:#d20;background-color:#fff0f0">&#34;it.unibo.lss2020&#34;</span>
</code></pre></div><p>Many repositories require to register the group and associate developer identities to it</p>
<p>The project name set in <code>settings.gradle.kts</code> is usually used as <strong>artifactId</strong></p>
</section><section>
<h2 id="preparing-the-plugin-publication">Preparing the plugin publication</h2>
<p>Gradle provides two plugins to simplify the assembly and upload of plugins</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
  <span style="color:#a61717;background-color:#e3d2d2">`</span>java-gradle-plugin<span style="color:#a61717;background-color:#e3d2d2">`</span>
  id(<span style="color:#d20;background-color:#fff0f0">&#34;com.gradle.plugin-publish&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;0.12.0&#34;</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>pluginBundle { <span style="color:#888">// These settings are set for the whole plugin bundle
</span><span style="color:#888"></span>    website = <span style="color:#d20;background-color:#fff0f0">&#34;https://danysk.github.io/Course-Laboratory-of-Software-Systems/&#34;</span>
    vcsUrl = <span style="color:#d20;background-color:#fff0f0">&#34;https://github.com/DanySK/Course-Laboratory-of-Software-Systems&#34;</span>
    tags = listOf(<span style="color:#d20;background-color:#fff0f0">&#34;example&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;greetings&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;lss&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;unibo&#34;</span>)
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradlePlugin {
    plugins {
        create(<span style="color:#d20;background-color:#fff0f0">&#34;GradleLatex&#34;</span>) { <span style="color:#888">// One entry per plugin
</span><span style="color:#888"></span>            id = <span style="color:#d20;background-color:#fff0f0">&#34;${project.group}.${project.name}&#34;</span>
            displayName = <span style="color:#d20;background-color:#fff0f0">&#34;LSS Greeting plugin&#34;</span>
            description = <span style="color:#d20;background-color:#fff0f0">&#34;Example plugin for the LSS course&#34;</span>
            implementationClass = <span style="color:#d20;background-color:#fff0f0">&#34;it.unibo.lss.firstplugin.GreetingPlugin&#34;</span>
        }
    }
}
</code></pre></div><p>They add the <code>publishPlugins</code> task</p>
</section><section>
<h2 id="credentials">Credentials</h2>
<p>In order to publish on the Gradle Plugin Portal (but it is true for any repository) users need to be <em>authenticated</em>
<br>
This is most frequently done via authentication tokens, and more rarely by username and password.</p>
<p>It is first required to <a href="https://plugins.gradle.org/user/register">register</a>,
once done, an <strong>API Key</strong> will be available from the web interface, along with a <strong>secret</strong>.</p>
<p>These data is required to be able to publish, and can be fed to Gradle in two ways:</p>
<ol>
<li>By editing the <code>~/.gradle/gradle.properties</code> file, adding:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>gradle.publish.key=YOUR_KEY
gradle.publish.secret=YOUR_SECRET
</code></pre></div><ol start="2">
<li>Via command line, using <code>-P</code> flags:</li>
</ol>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>./gradlew -Pgradle.publish.key=&lt;key&gt; -Pgradle.publish.secret=&lt;secret&gt; publishPlugins
</code></pre></div></section><section>
<h1 id="actual-publication">Actual publication</h1>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>❯ ./gradlew publishPlugins
&gt; Task :publishPlugins
Publishing plugin it.unibo.lss2020.greetings-plugin version 0.1.0-archeo+ea6b9d7
Publishing artifact build/libs/greetings-plugin-0.1.0-archeo+ea6b9d7.jar
Publishing artifact build/libs/greetings-plugin-0.1.0-archeo+ea6b9d7-sources.jar
Publishing artifact build/libs/greetings-plugin-0.1.0-archeo+ea6b9d7-javadoc.jar
Publishing artifact build/publish-generated-resources/pom.xml
Activating plugin it.unibo.lss2020.greetings-plugin version 0.1.0-archeo+ea6b9d7
</code></pre></div><p><a href="https://plugins.gradle.org/plugin/it.unibo.lss2020.greetings-plugin">The result is a published plugin</a></p>
</section><section>
<h1 id="quality-control">Quality control</h1>
<p>It is a good practice to set up some tools to validate the quality of the source code and testing.</p>
<p>In the case of Kotlin, there are three useful tools:</p>
<ol>
<li>Setting the <strong>compiler</strong> into a &ldquo;<em>warnings as errors</em>&rdquo; mode</li>
<li>Enabling a <em>coverage</em> tool such as <strong>Jacoco</strong></li>
<li>Configuring <strong>Ktlint</strong>, a Pinterest-made tool similar to Checkstyle</li>
<li>Configuring <strong>Detekt</strong>, a <em>static code analysis</em> tool similar to PMD</li>
</ol>
<ul>
<li>All quality control tasks are dependencies of the <code>check</code> task</li>
</ul>
<p>Moreover, we need a way to <em>inspect the results</em> of executing these controls, besides of course failing if too many things go wrong.</p>
<p>(note: under Kotlin and Scala, I do not recommend to use Spotbugs: even though it works, it generates <em>way</em> too many false positives)</p>
</section><section>
<h2 id="build-reports-in-gradle">Build reports in Gradle</h2>
<p>Tasks with a report module usually publish their results under <code>$buildDir/reports/$reportName</code></p>
<ul>
<li>For instance, <em>test results</em> are published in <code>$buildDir/reports/tests</code></li>
<li>Other tools follow the same convention</li>
<li>If you want to write a reporting task, extend from <code>AbstractReportTask</code></li>
</ul>
</section><section>
<h2 id="using-jacoco-with-kotest">Using Jacoco with Kotest</h2>
<p>Jacoco works with Kotest out of the box</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    <span style="color:#888">// Some plugins
</span><span style="color:#888"></span>    jacoco
    <span style="color:#888">// Some plugins
</span><span style="color:#888"></span>}
</code></pre></div><p>The plugin introduces two tasks:</p>
<ul>
<li><code>jacocoTestCoverageVerification</code></li>
<li><code>jacocoTestReport</code></li>
</ul>
<p>The latter must be configured to produce readable reports:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.jacocoTestReport {
    reports {
        <span style="color:#888">// xml.isEnabled = true // Useful for processing results automatically
</span><span style="color:#888"></span>        html.isEnabled = <span style="color:#080;font-weight:bold">true</span> <span style="color:#888">// Useful for human inspection
</span><span style="color:#888"></span>    }
}
</code></pre></div><p>Note: Jacoco does not work with the Gradle test kit, but <a href="https://github.com/koral--/jacoco-gradle-testkit-plugin">there are plugins</a> to work this around.</p>
</section><section>
<h2 id="aggressive-compiler-settings">Aggressive compiler settings</h2>
<p>Can be configured for every <code>KotlinCompile</code> task</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>tasks.withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt; {
    kotlinOptions {
        allWarningsAsErrors = <span style="color:#080;font-weight:bold">true</span>
    }
}
</code></pre></div></section><section>
<h1 id="ktlint">Ktlint</h1>
<ul>
<li>Linter with <em>minimal configuration</em> options</li>
<li>Configuration happens in a <code>.editorconfig</code> file</li>
<li>Also <em>checks build files</em></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    id(<span style="color:#d20;background-color:#fff0f0">&#34;org.jlleitschuh.gradle.ktlint&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;9.4.1&#34;</span>
}
</code></pre></div><p>Adds the following tasks:</p>
<ul>
<li><code>ktlintApplyToIdea</code>, <code>ktlintApplyToIdeaGlobally</code> &ndash; Change the IntelliJ Idea configuration to adhere to the rules</li>
<li><code>ktlintCheck</code>, <code>ktlintKotlinScriptCheck</code>, <code>ktlint&lt;SourceSetName&gt;SourceSetCheck</code>, &ndash; Apply rules and report errors</li>
<li><code>ktlintFormat</code>, <code>ktlintKotlinScriptFormat</code>, <code>ktlint&lt;SourceSetName&gt;SourceSetFormat</code> &ndash; Lint code automatically</li>
</ul>
</section><section>
<h1 id="detekt">Detekt</h1>
<ul>
<li>Configurable static source code analyzer</li>
<li>Requires an external module <em>not found on Maven Central</em>
<ul>
<li>If you are using JCenter, no worries</li>
<li>Otherwise, you need to add it and whitelist the <code>detekt</code> configuration</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    id(<span style="color:#d20;background-color:#fff0f0">&#34;io.gitlab.arturbosch.detekt&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;1.14.1&#34;</span>
}
repositories {
    jcenter { content { onlyForConfigurations(<span style="color:#d20;background-color:#fff0f0">&#34;detekt&#34;</span>) } } <span style="color:#888">// configuration-based content filtering
</span><span style="color:#888"></span>}
dependencies {
    <span style="color:#888">// Adds a configuration &#34;detektPlugins&#34;
</span><span style="color:#888"></span>    detektPlugins(<span style="color:#d20;background-color:#fff0f0">&#34;io.gitlab.arturbosch.detekt:detekt-formatting:1.14.1&#34;</span>)
}
detekt {
    failFast = <span style="color:#080;font-weight:bold">true</span> <span style="color:#888">// fail build on any finding
</span><span style="color:#888"></span>    buildUponDefaultConfig = <span style="color:#080;font-weight:bold">true</span> <span style="color:#888">// preconfigure defaults
</span><span style="color:#888"></span>    config = files(<span style="color:#d20;background-color:#fff0f0">&#34;$projectDir/config/detekt.yml&#34;</span>) <span style="color:#888">// Custom additional rules
</span><span style="color:#888"></span>}
</code></pre></div><p>Adds the <code>detekt</code> task, failing in case of violation</p>
</section><section>
<h1 id="detekt-1">Detekt</h1>
<h2 id="recommended-configuration">Recommended configuration</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">comments</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">EndOfSentenceFormat</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">UndocumentedPublicClass</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">UndocumentedPublicFunction</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">UndocumentedPublicProperty</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">complexity</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">LongMethod</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">LongParameterList</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">NestedBlockDepth</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">threshold</span>:<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">5</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">TooManyFunctions</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">ignoreDeprecated</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">ignorePrivate</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">ignoreOverridden</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">true</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">thresholdInInterfaces</span>:<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">20</span><span style="color:#bbb">
</span></code></pre></div></section><section>
<h1 id="detekt-2">Detekt</h1>
<h2 id="recommended-configuration-1">Recommended configuration</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">naming</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">MemberNameEqualsClassName</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">performance</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">SpreadOperator</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">active</span>:<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">false</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">style</span>:<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">MagicNumber</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">ignoreNumbers</span>:<span style="color:#bbb"> </span>[<span style="color:#d20;background-color:#fff0f0">&#39;-2&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;-1&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;0&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;0.5&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;1&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;2&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;3&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;4&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;10&#39;</span>,<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;360.0&#39;</span>]<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#080;font-weight:bold">ForbiddenComment</span>:<span style="color:#bbb">
</span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">allowedPatterns</span>:<span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#39;TODO:&#39;</span><span style="color:#bbb">
</span></code></pre></div></section><section>
<h1 id="code-documentation">Code documentation</h1>
<p>It is a good practice to automate the generation of the API documentation.</p>
<ul>
<li>The <code>java[-library]</code> plugin adds a <code>javadoc</code> task for the Javadoc</li>
<li>The <code>scala</code> plugin includes a task of type <code>ScalaDoc</code></li>
<li>Documentation for Kotlin is generated by using the <strong>Dokka</strong> tool
<ul>
<li>Jetbrains provides a plugin!</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins { id(<span style="color:#d20;background-color:#fff0f0">&#34;org.jetbrains.dokka&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;1.4.10&#34;</span> }
</code></pre></div><p>Adds four tasks:</p>
<ul>
<li><code>dokkaGfm</code>, <code>dokkaHtml</code>, <code>dokkaJavadoc</code>, <code>dokkaJekyll</code></li>
<li>They differ by kind of documentation they generate</li>
</ul>
</section><section>
<h1 id="creating-artifacts">Creating artifacts</h1>
<p>The <code>java-library</code> and <code>java</code> plugins (applied behind the scenes by the <code>kotlin-jvm</code> plugin as well) automatically create an <code>assemble</code> task which generates a task of type <code>Jar</code> creating a non-executable jar with the project contents.</p>
<ul>
<li>Further tasks of the same type can be defined for other archives
<ul>
<li>e.g., containing sources or documentation</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">javadocJar</span> <span style="color:#080;font-weight:bold">by</span> tasks.registering(Jar::<span style="color:#080;font-weight:bold">class</span>) {
    archiveClassifier.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;javadoc&#34;</span>)
    from(tasks.dokkaJavadoc.<span style="color:#080;font-weight:bold">get</span>().outputDirectory) <span style="color:#888">// Automatically makes it depend on dokkaJavadoc
</span><span style="color:#888"></span>}
</code></pre></div><p>generates a jar file with classifier <code>javadoc</code> inside the <code>build/libs</code> folder</p>
</section><section>
<h2 id="signing-artifacts">Signing artifacts</h2>
<p>Many repositories require artifacts to be <strong>signed</strong> in order for them to be delivered/deployed</p>
<ul>
<li>e.g. Bintray, Maven Central</li>
</ul>
<p>If you do not have a signature yet, <a href="https://central.sonatype.org/pages/working-with-pgp-signatures.html">time to create one</a></p>
<ul>
<li>Creation: <code>gpg --gen-key</code></li>
<li>List: <code>gpg --list-keys</code></li>
<li>Distribution: <code>gpg --keyserver hkp://pool.sks-keyservers.net --send-keys</code></li>
</ul>
<p>Once you have a key, you can use the <code>signing</code> plugin to have Gradle generate artifact signatures</p>
</section><section>
<h2 id="maven-central-and-other-software-repositories">Maven Central and other software repositories</h2>
<p><a href="https://search.maven.org/">Maven Central</a> is one of the de-facto standard repositories for JVM (artifacts)</p>
<ul>
<li>It actually hosts any artifact compatible with the Maven conventional format</li>
<li><strong>No-retract policy</strong>
<ul>
<li><strong>Errors</strong> <a href="https://search.maven.org/artifact/commons-io/commons-io">stay there forever</a></li>
</ul>
</li>
<li><em>Requires</em> both <em>sources</em> and <em>Javadoc</em> artifacts to get shipped</li>
<li>Artifacts on Central should only depend from other artifacts on Central</li>
<li>&ldquo;Old&rdquo; deployment management, requires some machinery</li>
</ul>
<p>Other notable repositories:</p>
<ul>
<li><em>Bintray JCenter</em>: superset of Maven Central</li>
<li><em>Jitpack</em>: code hosting with (semi-)automatic packaging</li>
<li><em>NPM</em>: for Javascript code</li>
<li><em>Pypy</em>: for Python code</li>
<li><em>RubyGems.org</em>: for Ruby code</li>
</ul>
</section><section>
<h2 id="publishing-artifacts-on-maven-central">Publishing artifacts on Maven Central</h2>
<p><strong>Requirements</strong></p>
<ul>
<li>A valid public signature</li>
<li>A registered <strong>groupId</strong>
<ul>
<li>Registration is handled manually, <a href="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134">open an issue</a></li>
<li>You could register <code>io.github.yourghusername</code> as group id</li>
</ul>
</li>
<li>Complete project metadata in a <code>pom.xml</code> file
<ul>
<li>Including developers, urls, project description, etc.</li>
</ul>
</li>
</ul>
<p><strong>Procedure</strong></p>
<ul>
<li><em>Sign</em> artifacts with your registered signature</li>
<li><em>Upload</em> them to <code>oss.sonatype.org</code></li>
<li><em>Close</em> the repository
<ul>
<li>Automatically checks contents, structure, and signatures</li>
</ul>
</li>
<li>Double check and then <em>Release</em>
<ul>
<li>There is <em>no turning back</em> after a mistake!</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="the-gradle-publish-plugin">The Gradle publish plugin</h1>
<p>Gradle provides a <code>maven-publish</code> <em>plugin for automated delivery</em> to Maven repositories
<br>
Requires some manual configuration:</p>
<ul>
<li>Generation of sources and javadoc jars</li>
<li>Configuration of the <code>pom.xml</code> metadata</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins { <span style="color:#a61717;background-color:#e3d2d2">`</span>maven-publish<span style="color:#a61717;background-color:#e3d2d2">`</span> }
publishing {
    repositories { maven { url = uri(<span style="color:#d20;background-color:#fff0f0">&#34;https://oss.sonatype.org&#34;</span> } }
    publications {
        create&lt;MavenPublication&gt;(<span style="color:#d20;background-color:#fff0f0">&#34;publicationName&#34;</span>) {
            from(components[<span style="color:#d20;background-color:#fff0f0">&#34;java&#34;</span>])
            name.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;My Library&#34;</span>)
            description.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;A concise description of my library&#34;</span>)
            url.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;http://www.example.com/library&#34;</span>)
            licenses { ... }
            developers { ... }
            scm { ... }
        }
    }
}
</code></pre></div><p>Adds:</p>
<ul>
<li><code>publish&lt;PubName&gt;PublicationTo&lt;RepoName&gt;Repository</code></li>
<li><code>publish&lt;PubName&gt;PublicationToMavenLocal</code></li>
</ul>
</section><section>
<h2 id="preconfigured-central-publication">Preconfigured Central publication</h2>
<p>I produced a plugin that pre-configures <code>maven-publish</code> to point to Maven Central</p>
<ul>
<li>Reacts to the application of <code>java</code>, <code>maven-publish</code>, and <code>signing</code> plugins</li>
<li>Defines task types <code>SourcesJar</code> and <code>JavadocJar</code>
<ul>
<li>Supports both Javadoc and Dokka</li>
</ul>
</li>
<li>Creates tasks to create the archives before delivery</li>
<li>Requires credentials to be set as environment variables
<ul>
<li><code>MAVEN_CENTRAL_USERNAME</code></li>
<li><code>MAVEN_CENTRAL_PASSWORD</code></li>
</ul>
</li>
</ul>
</section><section>
<h2 id="preconfigured-central-publication-1">Preconfigured Central publication</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>plugins {
    `java`
    <span style="color:#a61717;background-color:#e3d2d2">`</span>maven-publish<span style="color:#a61717;background-color:#e3d2d2">`</span>
    `signing`
    id (<span style="color:#d20;background-color:#fff0f0">&#34;org.danilopianini.publish-on-central&#34;</span>) version <span style="color:#d20;background-color:#fff0f0">&#34;0.3.0&#34;</span>
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>group = <span style="color:#d20;background-color:#fff0f0">&#34;your.group.id&#34;</span> <span style="color:#888">// This must be configured for the generated pom.xml to work correctly
</span><span style="color:#888"></span>publishOnCentral {
    projectDescription.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;description&#34;</span>) <span style="color:#888">// Defaults to &#34;No description provided&#34;
</span><span style="color:#888"></span>    projectLongName.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;full project name&#34;</span>) <span style="color:#888">// Defaults to the project name
</span><span style="color:#888"></span>    licenseName.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;your license&#34;</span>) <span style="color:#888">// Default &#34;Apache License, Version 2.0&#34;
</span><span style="color:#888"></span>    licenseUrl.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;link to your license&#34;</span>) <span style="color:#888">// Default http://www.apache.org/licenses/LICENSE-2.0
</span><span style="color:#888"></span>    projectUrl.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;website url&#34;</span>) <span style="color:#888">// Default &#34;https://github.com/DanySK/${project.name}&#34;
</span><span style="color:#888"></span>    scmConnection.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;git:git@github.com:youruser/yourrepo&#34;</span>) <span style="color:#888">// Default &#34;git:git@github.com:DanySK/${project.name}&#34;
</span><span style="color:#888"></span>}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>publishing {
    publications { withType&lt;MavenPublication&gt; { pom { developers {
        developer {
            name.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;Danilo Pianini&#34;</span>)
            email.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;danilo.pianini@gmail.com&#34;</span>)
            url.<span style="color:#080;font-weight:bold">set</span>(<span style="color:#d20;background-color:#fff0f0">&#34;http://www.danilopianini.org/&#34;</span>)
        }
    }}}}
}
</code></pre></div></section><section>
<h1 id="semiautomatic-updates">(Semi)Automatic updates</h1>
<p>We automated everything from source writing to delivery!
<br>
Yet there is a missing piece: we need to <em>fetch library updates manually</em>
<br>
Also, version numbers are strings scattered around our build file</p>
<p><strong>Possible solution</strong></p>
<p>A plugin that stores versions in a properties file, and fetches updates automatically: <a href="https://github.com/jmfayard/refreshVersions/">refreshVersions</a></p>
<ul>
<li>The plugin is applied project-wise to the <code>settings.gradle.kts</code></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">de.fayard.refreshVersions.bootstrapRefreshVersions</span>
buildscript {
    repositories { gradlePluginPortal() }
    dependencies { classpath(<span style="color:#d20;background-color:#fff0f0">&#34;de.fayard.refreshVersions:refreshVersions:0.9.5&#34;</span>) }
}
bootstrapRefreshVersions()
</code></pre></div><ul>
<li>Hardcoded versions can get substitued with <code>_</code></li>
<li>Hardcoded plugin versions can be removed</li>
<li>Adds task <code>refreshVersions</code> to update versions in <code>versions.properties</code></li>
<li><em>Note</em>: this plugin is <em>still in development</em>, your mileage may vary</li>
</ul>
</section><section>
<h1 id="inspecting-dependencies">Inspecting dependencies</h1>
<p>In rich projects, most of the build-related issues are due to pesky stuff going on with <em>dependencies</em></p>
<ul>
<li>Transitive conflicts
<ul>
<li>dependency A requires B at version 1, dependency C requires B at version 2</li>
</ul>
</li>
<li>Multiple names for the same artifact</li>
<li>Unexpected differences between configurations</li>
</ul>
<p>Gradle allows for <strong>inspection</strong> of the dependencies:</p>
<ul>
<li><code>./gradlew dependencies</code> prints the dependency trees for each configuration</li>
</ul>
<p>Inspecting multiple large trees can be difficult</p>
<ul>
<li>A single dependency inspection is available</li>
<li><code>./gradlew dependencyInsight --dependency &lt;DepName&gt; </code>
<ul>
<li>Optionally, fiterable by configuration: <code>--configuration &lt;ConfName&gt;</code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="build-reporting">Build reporting</h1>
<ul>
<li>Builds can get complicated when automation is pushed forward
<ul>
<li>Performance issues may arise</li>
<li>Some tests may run anomalously slow</li>
<li>Dependency trees may get hard to analyze in a terminal</li>
<li>Plugin behaviour could be different than expected</li>
</ul>
</li>
</ul>
<p>Gradle supports a reporting system called <em>Gradle build scans</em></p>
<ul>
<li>Executable by appending <code>--scan</code> to the build</li>
<li>Requires terminal interaction (or use of the <a href="https://docs.gradle.com/enterprise/gradle-plugin/">enterprise plugin</a>)</li>
</ul>
<p>Example scans:</p>
<ul>
<li><a href="https://scans.gradle.com/s/5i6ai7gz6qzmc">https://scans.gradle.com/s/5i6ai7gz6qzmc</a></li>
<li><a href="https://scans.gradle.com/s/5jmd7avh2gnvi">https://scans.gradle.com/s/5jmd7avh2gnvi</a></li>
</ul>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/Course-Laboratory-of-Software-Systems/reveal-hugo/object-assign.js></script>

<a href="/Course-Laboratory-of-Software-Systems/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"height":"100%","pdfseparatefragments":false,"theme":"white","width":"100%"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"custom_theme_options":{"enablesourcemap":true,"targetpath":"css/custom-theme.css"},"transition":"slide","transition_speed":"fast"}</script>

<script src="/Course-Laboratory-of-Software-Systems/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/notes/notes.js"></script>



    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>

<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

    
  </body>
</html>
