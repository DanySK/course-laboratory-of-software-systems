<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>Kotlin (for Scala developers)</title>
<meta name="description" content="A fast Kotlin primer for people who already know Java and Scala">
<meta name="author" content="Danilo Pianini">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reset.css">
<link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/reveal-js/css/reveal.css">
  <link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/css/custom-theme.min.1e2604bf0c24e445faa3ae7d68b2f0146c34bc9e7b9bd6aee2b7187115560e96.css" id="theme"><link rel="stylesheet" href="/Course-Laboratory-of-Software-Systems/highlight-js/default.min.css">
    
<link rel="stylesheet" href="https://gitcdn.link/repo/DanySK/css-blur-animation/master/blur.css">
<link href='https://fonts.googleapis.com/css?family=Roboto Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Oxygen Mono' rel='stylesheet'>
<link href='https://fonts.googleapis.com/css?family=Ubuntu Mono' rel='stylesheet'>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="hahahugoshortcode-s0-hbhb">Laboratory of Software Systems</h1>
<h2 id="kotlin-for-scala-developers">Kotlin (for Scala developers)</h2>
<h3 id="danilo-pianinimailtodanilopianiniuniboit"><a href="mailto:danilo.pianini@unibo.it">Danilo Pianini</a></h3>
2020-10-05

</section><section>
<h1 id="why-kotlin">Why Kotlin</h1>
<p>JetBrains-made modern programming language</p>
<ul>
<li>Focused on &ldquo;practical use&rdquo; (whatever that means)</li>
</ul>
<p>Gaining momentum since Google adopted is as <em>official Android language</em> (along with Java and C++)</p>
<p>Clearly inspired by a mixture of Java, C#, Scala, and Groovy</p>
<p><strong>In this course</strong> &ndash; we&rsquo;ll need it for Gradle and <em>internal</em> domain specific languages</p>
</section><section>
<h1 id="philosophy-kotlin-vs-scala">Philosophy: Kotlin vs. Scala</h1>
<p><strong>Sca</strong><em>la</em> is a <strong>scalable</strong> <em>language</em></p>
<ul>
<li>Few core constructs that enable a huge variety of programming patterns</li>
<li>Born in academia</li>
<li>State of the art type checker with advanced features
<ul>
<li>Higher Kinded Types</li>
<li>Type lambdas</li>
<li>Enough to do type programming&hellip;</li>
</ul>
</li>
</ul>
<p><strong>Kotlin</strong> is somewhat <em>a better java</em></p>
<ul>
<li>Born in industry, for the industry</li>
<li>Many more &ldquo;core&rdquo; constructs and keywords than Scala</li>
<li>Focused on getting productive quickly and reducing programming errors</li>
<li>Focus on multi-target (can compile towards JVM, JavaScript, and native)
<ul>
<li>Scala can as well by the way</li>
<li>Kotlin puts more care into bidirectional compatibility</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101">Kotlin 101</h1>
<h2 id="defining-functions-constant-variables">Defining functions, constant, variables</h2>
<p>Similar to Scala. The keyword <code>def</code> is replaced by <code>fun</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">x</span> = <span style="color:#00d;font-weight:bold">10</span> <span style="color:#888">// constant
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">y</span> = <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// variable, can be reassigned
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// function definition, single expression
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">bar</span>(): Int { <span style="color:#888">// same as above with multiple expression
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00d;font-weight:bold">20</span> <span style="color:#888">// requires a return in this form...
</span><span style="color:#888"></span>}
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baz</span>() { } <span style="color:#888">// Unless it returns Unit
</span><span style="color:#888"></span>
</code></pre></div></section><section>
<h1 id="kotlin-101-1">Kotlin 101</h1>
<h2 id="function-parameters-and-return-types">Function parameters and return types</h2>
<p>Much like Scala:</p>
<ul>
<li>All parameters are named, but can be invoked positionally as well</li>
<li>Parameters can have defaults</li>
<li>Types are annotated after the parameter name</li>
<li>Invocation can be positional or by name, with the rule that once a named parameter is used, subsequent parameters must be named as well</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>(a: Int = <span style="color:#00d;font-weight:bold">0</span>, b: String = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>): Int = TODO() <span style="color:#888">// TODO() is a builtin function throwing a `NotImplementedError`
</span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>, <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, positional
</span><span style="color:#888"></span>foo(a = <span style="color:#00d;font-weight:bold">1</span>, b = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, named
</span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>, b = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, hybrid
</span><span style="color:#888"></span>foo(a = <span style="color:#00d;font-weight:bold">1</span>, <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// error: no value passed for parameter &#39;b&#39;
</span><span style="color:#888"></span>foo() <span style="color:#888">// OK, both defaults
</span><span style="color:#888"></span>foo(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#888">// OK, same as foo(1, &#34;foo&#34;)
</span><span style="color:#888"></span>foo(<span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// error: type mismatch: inferred type is String but Int was expected
</span><span style="color:#888"></span>foo(b = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>) <span style="color:#888">// OK, same as foo(0, &#34;bar&#34;)
</span></code></pre></div></section><section>
<h1 id="kotlin-101-2">Kotlin 101</h1>
<h2 id="top-level-functions">Top level functions</h2>
<p>Kotlin supports top level functions</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() {
    ...
}
</code></pre></div><p>By contrast, Scala requires to put them in an <code>object</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">Foo</span> {
    <span style="color:#080;font-weight:bold">def</span> foo() {
        ...
    }
}
</code></pre></div><p>When targeting the JVM, Kotlin simply generates a <code>FileNameKt</code> class behind the scenes where the function is stored.
The behaviour can be controlled via annotations.</p>
</section><section>
<h1 id="kotlin-101-3">Kotlin 101</h1>
<h2 id="program-entry-point">Program entry point</h2>
<p>Naming a function <code>main</code> makes it a valid entry point:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>() = println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello World&#34;</span>) <span style="color:#888">// Valid entry point
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>(arguments: Array&lt;String&gt;) = println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello World&#34;</span>) <span style="color:#888">// Valid entry point
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">main</span>(arguments: Array&lt;String&gt;) {
    println(<span style="color:#d20;background-color:#fff0f0">&#34;Hello World&#34;</span>) <span style="color:#888">// Return type is Unit, no need to return
</span><span style="color:#888"></span>} 
</code></pre></div></section><section>
<h1 id="kotlin-101-4">Kotlin 101</h1>
<h2 id="nullable-types">Nullable types</h2>
<p>Every Kotlin type exists in two forms: normal, and nullable (likely inspired by Ceylon).
<br/>
Nullable types are suffixed by a <code>?</code> and require special handling
<br/>
<code>null</code> can&rsquo;t be assigned to non nullable types!</p>
<ul>
<li>Nullables are the Kotlin way to deal with <code>Option</code> types</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">foo</span> = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span> <span style="color:#888">// Okay, type is String
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = foo <span style="color:#888">// Okay, normal types can be assigned to nullables
</span><span style="color:#888"></span>foo = baz <span style="color:#888">// error: type mismatch: inferred type is String? but String was expected
</span><span style="color:#888"></span>foo = <span style="color:#080;font-weight:bold">null</span> <span style="color:#888">// error: null can not be a value of a non-null type String
</span></code></pre></div></section><section>
<h1 id="kotlin-101-5">Kotlin 101</h1>
<h2 id="accessing-nullable-types">Accessing nullable types</h2>
<p>Nullable types memebers can&rsquo;t be accessed by <code>.</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz.length <span style="color:#888">// error: only safe (?.) or non-null asserted (!!.) calls are allowed...
</span><span style="color:#888">// on a nullable receiver of type String?
</span></code></pre></div><h3 id="safe-call-operator-">Safe call operator <code>?.</code></h3>
<p>Performs runtime access to a member of a nullable object if it&rsquo;s not <code>null</code>, otherwise returns <code>null</code></p>
<ul>
<li>Somewhat similar to Scala&rsquo;s <code>Option</code>'s <code>map</code> (but no monad involved)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz?.length <span style="color:#888">// returns 3, return type is &#34;Int?&#34;, in fact...
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: Int = baz?.length <span style="color:#888">// ...error: type mismatch: inferred type is Int? but Int was expected
</span><span style="color:#888"></span>baz = <span style="color:#080;font-weight:bold">null</span>
baz?.length <span style="color:#888">// returns null, return type is still &#34;Int?&#34;
</span></code></pre></div></section><section>
<h1 id="kotlin-101-6">Kotlin 101</h1>
<h3 id="non-null-assertion-">Non-null assertion <code>!!</code></h3>
<p>Also known as: <em>I want my code to break badly at runtime</em>
<br/></p>
<ul>
<li>Invalidates the whole point of having nullable types by asserting that the nullable object is not <code>null</code> at runtime</li>
<li>It should be <strong>never</strong> used
<ul>
<li>In fact its ugly syntax is so <em>ugly by purpose</em></li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz!!<span class='fragment '  style="color: #888;"> // Returns &#39;foo&#39;, type String (non nullable)</span>
baz!!.length<span class='fragment '  style="color: #888;"> // returns 3, return type is Int</span>
baz = <span style="color:#080;font-weight:bold">null</span>
baz!!<span class='fragment '  style="color: #888;"> // throws a KotlinNullPointerException, like the good ol&#39;times!</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-7">Kotlin 101</h1>
<h3 id="elvis-operator-">Elvis operator <code>?:</code></h3>
<p>Yeah it&rsquo;s actually named after Elvis Presley due to his haircut ðŸ˜‰
<br/></p>
<ul>
<li>Returns the left operand if it&rsquo;s not <code>null</code>, otherwise the right one</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
baz ?: <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span> <span style="color:#888">// Returns &#34;foo&#34;, type String
</span><span style="color:#888"></span>baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// returns 3, return type is Int
</span><span style="color:#888"></span>baz = <span style="color:#080;font-weight:bold">null</span>
baz ?: <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span> <span style="color:#888">// Returns &#34;bar&#34;, type String
</span><span style="color:#888"></span>baz?.length ?: <span style="color:#00d;font-weight:bold">0</span> <span style="color:#888">// returns 0, return type is Int
</span></code></pre></div></section><section>
<h1 id="kotlin-101-8">Kotlin 101</h1>
<h2 id="platform-types">Platform types</h2>
<p>Kotlin targets the JVM, JavaScript, and native code
<br/>
<em>None of them has nullable types!</em></p>
<p>Nullability is unknown for types coming from the target platform, how to deal with them?</p>
<ol>
<li><span class='fragment '
  >
  Always consider them nullable (safe, but very unpleasant)
</span></li>
<li><span class='fragment '
  >
  Always consider them non nullable (code is lightweight and nice, but unsafe)
</span></li>
</ol>
</section><section>
<h1 id="kotlin-101-9">Kotlin 101</h1>
<h2 id="platform-types-1">Platform types</h2>
<p>Kotlin considers all foreign values whose nullability is unknown as <em>platform types</em></p>
<ul>
<li>Their type is suffixed by <code>!</code> (e.g., <code>java.util.Date!</code>)</li>
<li>At first use, their type is <em>implicitly disambiguated</em> (either nullable or non-nullable)
<ul>
<li>Namely, platform types can be used as non-nullable&hellip;</li>
</ul>
</li>
<li>Runtime nullability checks are put in place by the compiler (<em>fail fast!</em>)
<ul>
<li>&hellip;but their actual nullablity is checked at use-site</li>
</ul>
</li>
<li>Platform types <em>can&rsquo;t be created</em> in Kotlin! They only come from interaction with &ldquo;platform code&rdquo;</li>
<li>If the target platform offers some way to assert nullability, Kotlin tries to use it
<ul>
<li>e.g., if a Java method/parameter is annotated with <code>@NotNull</code> (or similar common alternatives) it will be interpreted as a non-nullable type</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-10">Kotlin 101</h1>
<h2 id="type-hierarchy">Type hierarchy</h2>
<ul>
<li>In Java
<ul>
<li>top type: <code>Object</code></li>
<li>bottom type: no bottom type</li>
</ul>
</li>
<li>In Scala
<ul>
<li>top type: <code>Any</code></li>
<li>bottom type: <code>Nothing</code></li>
</ul>
</li>
<li>In Kotlin:
<ul>
<li>top type: <code><span class='fragment '
  >
  Any
</span></code></li>
<li>bottom type:</li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-11">Kotlin 101</h1>
<h2 id="type-hierarchy-1">Type hierarchy</h2>
<ul>
<li>In Java
<ul>
<li>top type: <code>Object</code></li>
<li>bottom type: no bottom type</li>
</ul>
</li>
<li>In Scala
<ul>
<li>top type: <code>Any</code></li>
<li>bottom type: <code>Nothing</code></li>
</ul>
</li>
<li>In Kotlin:
<ul>
<li>top type: <del><code>Any</code></del> <code><span class='fragment '
  >
  Any?
</span></code></li>
<li>bottom type: <code><span class='fragment '
  >
  Nothing
</span></code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-101-12">Kotlin 101</h1>
<h2 id="booleans"><code>Boolean</code>s</h2>
<p>Exactly as Java/Scala, but with nullability:</p>
<ul>
<li><code>Boolean</code>: <code>true</code>/<code>false</code></li>
<li><code>Boolean?</code>: <code>true</code>/<code>false</code>/<code>null</code></li>
<li><code>&amp;&amp;</code>, <code>!!</code>, and <code>!</code> operators work for <em>non-nullable</em> <code>Boolean</code>s.</li>
</ul>
<p>Likewise Scala, boxing under the JVM is dealt with by the compiler
<br/>
<code>Boolean?</code> are always boxed (to be able to account for <code>null</code>)</p>
</section><section>
<h1 id="kotlin-101-13">Kotlin 101</h1>
<h2 id="numeric-types">Numeric types</h2>
<p>Same as Scala, +nullability, +<em>unsigned experimental types</em>:</p>
<ul>
<li><code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>
<ul>
<li>And nullable equivalents, always boxed under the JVM</li>
</ul>
</li>
<li><code>UByte</code>, <code>UShort</code>, <code>UInt</code>, <code>ULong</code></li>
</ul>
</section><section>
<h1 id="kotlin-101-14">Kotlin 101</h1>
<h2 id="issues-of-implicit-numeric-types-conversion">Issues of implicit numeric types conversion</h2>
<p>Implicit type conversion to &ldquo;bigger&rdquo; types is source of nasty errors when automatic boxing is involved.
<br/>
Consider the following Scala code:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> == <span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> <span style="color:#888">// false, OK, as every sane language
</span><span style="color:#888"></span><span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> equals <span style="color:#b06;font-weight:bold">Double</span>.<span style="color:#b06;font-weight:bold">NaN</span> <span style="color:#888">// true! Boxing + Singleton make equality inconsistent!
</span></code></pre></div><p>Another example:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> a<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Int</span> = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> b<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Long</span> = a
a == b <span style="color:#888">// true
</span><span style="color:#888"></span>a equals b <span style="color:#888">// false
</span></code></pre></div><p>This causes a chain of issues, as <code>==</code> and <code>equals</code> do a different job, as do <code>##</code> and <code>hashCode</code>: <code>Map</code>s can become very surprising!</p>
</section><section>
<h1 id="kotlin-101-15">Kotlin 101</h1>
<h2 id="numeric-type-conversions-in-kotlin">Numeric type conversions in Kotlin</h2>
<p>Kotlin numeric types are converted manually to prevent these issues:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">i</span>: Int = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = i<span class='fragment '  style="color: #888;"> // error: type mismatch: inferred type is Int but Long was expected</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">l</span>: Long = i.toLong()<span class='fragment '  style="color: #888;"> // OK</span>
i + l<span class='fragment '  style="color: #888;"> // OK, operators are overloaded</span>
l + i<span class='fragment '  style="color: #888;"> // OK, operators are overloaded</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-16">Kotlin 101</h1>
<h2 id="numeric-literals">Numeric literals</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1234567</span> <span style="color:#888">// Literal Int
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1</span>_234_567 <span style="color:#888">// Literal Int, underscored syntax (preferable)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">123L</span> <span style="color:#888">// Literal Long
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1.0</span> <span style="color:#888">// Literal Double
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">123</span>e4 <span style="color:#888">// Literal Double in scientific notation
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1</span>d <span style="color:#888">// Nope :)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1f</span> <span style="color:#888">// Literal Float
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1u</span> <span style="color:#888">// Literal UInt
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0123</span> <span style="color:#888">// error: unsupported [literal prefixes and suffixes] (no octal)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xCAFE</span> <span style="color:#888">// Hex literal Int
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xCAFEBABE</span> <span style="color:#888">// Hex literal Long (automatic, as it does not fit an Int)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0x0000000</span> <span style="color:#888">// Hex literal Int, even it&#39;d fit a Byte
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b1111111_11111111_11111111_11111111 <span style="color:#888">// Binary Int (Integer.MAX_INT)
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b11111111_11111111_11111111_11111111 <span style="color:#888">// Binary Long
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0</span>b11111111_11111111_11111111_11111111u <span style="color:#888">// Binary UInt!
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">0xFFFF</span>_FFFF_FFFFu <span style="color:#888">// ULong
</span></code></pre></div></section><section>
<h1 id="kotlin-101-17">Kotlin 101</h1>
<h2 id="strings-and-templating">Strings and templating</h2>
<p>Spiced up version of Java strings, Groovy-style templating:</p>
<ul>
<li><code>$</code> begins a template expression</li>
<li>Curly brackets must be used to disambiguate in case of calls inside the template: <code>${}</code></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">batman</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Batman&#34;</span>
<span style="color:#888">// Groovy templating and Java-style concatenation both work
</span><span style="color:#888"></span><span style="color:#d20;background-color:#fff0f0">&#34;${Double.NaN}&#34;</span>.repeat(<span style="color:#00d;font-weight:bold">10</span>) + <span style="color:#d20;background-color:#fff0f0">&#34; $batman!&#34;</span><span class='fragment '  style="color: #888;"> // NaNNaNNaNNaNNaNNaNNaNNaNNaNaN Batman!</span>
<span style="color:#d20;background-color:#fff0f0">&#34;Batman is $batman.length characters long&#34;</span><span class='fragment '  style="color: #888;"> // Batman is Batman.length characters long</span>
<span style="color:#d20;background-color:#fff0f0">&#34;Batman is ${batman.length} characters long&#34;</span><span class='fragment '  style="color: #888;"> // Batman is 6 characters long</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-18">Kotlin 101</h1>
<h2 id="raw-strings">Raw Strings</h2>
<p>Triple-double-quoted strings are considered <em>raw strings</em></p>
<ul>
<li><code>\</code> is a normal character</li>
<li>newlines are intended as part of the string</li>
<li>Very handy for writing regular expressions</li>
<li><code>$</code>-templating still works
<ul>
<li>writing a dollar symbols requires some tricks</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">dante</span> = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;&#34;
</span><span style="color:#d20;background-color:#fff0f0">    Tanto gentile e tanto onesta pare
</span><span style="color:#d20;background-color:#fff0f0">    la donna mia quand&#39;ella altrui saluta,
</span><span style="color:#d20;background-color:#fff0f0">    ch&#39;ogne lingua devÃ¨n, tremando, muta
</span><span style="color:#d20;background-color:#fff0f0">    e li occhi non l&#39;ardiscon di guardare.
</span><span style="color:#d20;background-color:#fff0f0">    &#34;&#34;&#34;</span>.trimIndent() <span style="color:#888">// Indentation can be trimmed
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">finalWordsEndingInA</span> = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;&#34;\W*(\w*a)\W*${&#39;$&#39;}&#34;&#34;&#34;</span>.toRegex(RegexOption.MULTILINE) <span style="color:#888">// See how $ must be escaped
</span><span style="color:#888"></span>finalWordsEndingInA.findAll(dante).map { it.groups[<span style="color:#00d;font-weight:bold">1</span>]?.value }.toList() <span class='fragment '  style="color: #888;"> // [saluta, muta]</span>
</code></pre></div></section><section>
<h1 id="kotlin-101-19">Kotlin 101</h1>
<h2 id="packages-and-imports">Packages and imports</h2>
<p>Same as Java, plus aliasing.
<br/>
Imports go at the top of file, no locally scoped imports as in Scala</p>
<ul>
<li>There are no <code>implicit</code>s in Kotlin, the <code>import</code> statement does not modify context</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">package</span> <span style="color:#b06;font-weight:bold">it.unibo.lss.experiments</span>
<span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">it.unibo.lss.ddd.Entity</span> <span style="color:#888">// Available as Entity locally
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">org.company.someproduct.Entity</span> <span style="color:#080;font-weight:bold">as</span> SomeProductEntity <span style="color:#888">// Aliasing, accessible as SomeProductEntity
</span></code></pre></div></section><section>
<h1 id="kotlin-101-20">Kotlin 101</h1>
<h2 id="varargs">Varargs</h2>
<p>Functions can have a parameter marked as <code>vararg </code>, accepting multiple entries</p>
<ul>
<li>Typically the last one (but not mandatorily as in Java)</li>
<li>Maps to an `Array<out ></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">printall</span>(<span style="color:#080;font-weight:bold">vararg</span> strings: String) {
    strings.forEach { println(it) } <span style="color:#888">// We&#39;ll discuss this syntax later...
</span><span style="color:#888"></span>}
printall(<span style="color:#d20;background-color:#fff0f0">&#34;Lorem&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;ipsum&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;dolor&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;sit&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;amet&#34;</span>)
</code></pre></div></section><section>
<h1 id="kotlin-101-21">Kotlin 101</h1>
<h2 id="naming-in-kotlin">Naming in Kotlin</h2>
<p>Kotlin is less permissive than Scala:</p>
<ul>
<li>Arbitrary symbols are not accepted as valid function names</li>
<li>&hellip;unless you explicitly surround them with backtics</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">def</span> ##<span style="color:#a61717;background-color:#e3d2d2">Â°</span>@??%&amp;@^^() <span style="color:#080;font-weight:bold">=</span> <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// Super ok for Scala: def $hash$hash$u00B0$at$qmark$qmark$percent$amp$at$up$up(): Int
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">`##Â°@??%&amp;@^^`() = 1 // </span><span style="color:#06b;font-weight:bold">OK</span>
<span style="color:#a61717;background-color:#e3d2d2">`##Â°@</span>??%&amp;<span style="color:#a61717;background-color:#e3d2d2">@</span>^^<span style="color:#a61717;background-color:#e3d2d2">`</span>() <span style="color:#888">// 1. Must be invoked with backticks!
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`val`</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Hey look I can name things with keywords!&#34;</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`names can also contain spaces`</span> = <span style="color:#00d;font-weight:bold">1</span>
</code></pre></div><ul>
<li>General rule: <strong>avoid it</strong></li>
<li>It might be needed for interoperability with other languages, e.g. if a Java field is named <code>val</code></li>
<li>Tolerated in tests with Junit (but Kotlin-native suites as Kotest do not need it)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">JunitTest</span> {
    @Test
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">`404 </span><span style="color:#06b;font-weight:bold">errors</span> should cause a wait and retry<span style="color:#a61717;background-color:#e3d2d2">`</span>() { <span style="color:#888">// Nice and very clear name
</span><span style="color:#888"></span>        TODO()
    }
}
</code></pre></div></section><section>
<h1 id="kotlin-101-22">Kotlin 101</h1>
<h2 id="local-functions">Local functions</h2>
<p>Functions can contain other functions (as in Scala)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">factorial</span>(n: UInt): ULong {
    <span style="color:#888">// tailrec forces optimization of tail recursion (and blocks compilation if recursion is non-tail)
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">tailrec</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">factorialWithAccumulator</span>(current: UInt, accumulator: ULong): ULong = <span style="color:#080;font-weight:bold">when</span> {
        current &gt;= n -&gt; accumulator * current
        <span style="color:#080;font-weight:bold">else</span> -&gt; factorialWithAccumulator(current + <span style="color:#00d;font-weight:bold">1u</span>, accumulator * current)
    }
    <span style="color:#080;font-weight:bold">return</span> factorialWithAccumulator(<span style="color:#00d;font-weight:bold">1u</span>, <span style="color:#00d;font-weight:bold">1u</span>)
}
</code></pre></div><p>Warning: local functions often hinder clarity</p>
</section><section>
<h1 id="kotlin-101----flow-control">Kotlin 101 &ndash; Flow control</h1>
<h2 id="if"><code>if</code></h2>
<ul>
<li><code>if</code>/<code>else</code> is an expression and works just as in Scala</li>
<li>No ternary operator</li>
<li><code>if</code> alone is not an expression</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-1">Kotlin 101 &ndash; Flow control</h1>
<h3 id="for"><code>for</code></h3>
<ul>
<li><strong>No classic</strong> <code>for(init; condition; then) { block }</code> loop</li>
<li>Only available as <code>for</code>/<code>in</code>: <code>for (element in collection) { block }</code></li>
<li><strong>Not a powerful combinator</strong> like Scala&rsquo;s <code>for</code></li>
<li><em>Rarely used</em> (I think I might have used it twice in my career)</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-2">Kotlin 101 &ndash; Flow control</h1>
<h3 id="while-and-dowhile"><code>while</code> and <code>do</code>/<code>while</code></h3>
<ul>
<li>Same as Java, but with <em>visibility of variables defined in the <code>do</code>-block</em></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">import</span> <span style="color:#b06;font-weight:bold">kotlin.random.Random</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">lucky</span> = <span style="color:#00d;font-weight:bold">6</span>
<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">attempts</span> = <span style="color:#00d;font-weight:bold">0</span>
<span style="color:#080;font-weight:bold">do</span> {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">draw</span> = Random.nextInt(lucky + <span style="color:#00d;font-weight:bold">1</span>)
    attempts++
} <span style="color:#080;font-weight:bold">while</span> (draw != lucky) <span style="color:#888">// draw is visible here
</span><span style="color:#888"></span>println(<span style="color:#d20;background-color:#fff0f0">&#34;Launched $attempts dice before a lucky shot&#34;</span>)
</code></pre></div></section><section>
<h1 id="kotlin-101----flow-control-3">Kotlin 101 &ndash; Flow control</h1>
<h3 id="when"><code>when</code></h3>
<p>Kotlin <em>does not support pattern matching</em> as Scala does (unfortunately)
<br/>
The <code>when</code> block is somewhat a mild surrogate, more similar to a <code>switch</code> on steroids
<br/>
The base version (without subject) is a more elegant &ldquo;<code>if</code>/<code>else if</code>/<code>else</code>&rdquo; chain</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">countBatmans</span>(subject: String) = <span style="color:#080;font-weight:bold">when</span> {
    subject.length &lt; <span style="color:#d20;background-color:#fff0f0">&#34;batman&#34;</span>.length -&gt; <span style="color:#00d;font-weight:bold">0</span>
    subject.length &lt; <span style="color:#00d;font-weight:bold">2</span> * <span style="color:#d20;background-color:#fff0f0">&#34;batman&#34;</span>.length &amp;&amp; subject.contains(<span style="color:#d20;background-color:#fff0f0">&#34;batman&#34;</span>) -&gt; <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;.*?(batman)&#34;</span>.toRegex().findAll(subject).count().toInt()
}
</code></pre></div><ul>
<li><code>when</code> is an expression in any case</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-4">Kotlin 101 &ndash; Flow control</h1>
<h3 id="when-subject"><code>when (subject)</code></h3>
<p>Checks if the value of subjects is the same of the expression on the right</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baseForSingleDigitOrNull</span>(digit: UInt) = <span style="color:#080;font-weight:bold">when</span>(digit) {
    <span style="color:#00d;font-weight:bold">0u</span>, <span style="color:#00d;font-weight:bold">1u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;binary&#34;</span>
    <span style="color:#00d;font-weight:bold">2u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;ternary&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">7u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;octal&#34;</span> <span style="color:#888">// This is a range!
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">15u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;hexadecimal&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">36u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;base36&#34;</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#080;font-weight:bold">null</span>
}
</code></pre></div><ul>
<li><code>when</code> with subject can be used to elegantly check for subtypes</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">splitAnything</span>(input: Any) = <span style="color:#080;font-weight:bold">when</span>(input) {
    <span style="color:#080;font-weight:bold">is</span> Int -&gt; input / <span style="color:#00d;font-weight:bold">2</span> <span style="color:#888">// No need to cast! The compiler infers type automatically (smart cast)
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">is</span> String -&gt; input.substring(input.length / <span style="color:#00d;font-weight:bold">2</span>)
    <span style="color:#080;font-weight:bold">is</span> Double -&gt; input / <span style="color:#00d;font-weight:bold">2</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; TODO()
}
</code></pre></div></section><section>
<h1 id="kotlin-101----flow-control-5">Kotlin 101 &ndash; Flow control</h1>
<h3 id="when-1"><code>when</code></h3>
<p>Checks if the value of subjects is the same of the expression on the right</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">baseForSingleDigitOrNull</span>(digit: UInt) = <span style="color:#080;font-weight:bold">when</span>(digit) {
    <span style="color:#00d;font-weight:bold">0u</span>, <span style="color:#00d;font-weight:bold">1u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;binary&#34;</span>
    <span style="color:#00d;font-weight:bold">2u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;ternary&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">7u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;octal&#34;</span> <span style="color:#888">// This is a range!
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">15u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;hexadecimal&#34;</span>
    <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">0u</span>..<span style="color:#00d;font-weight:bold">36u</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;base36&#34;</span>
    <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#080;font-weight:bold">null</span>
}
</code></pre></div><ul>
<li><code>when</code> is an expression in any case</li>
</ul>
</section><section>
<h1 id="kotlin-101----flow-control-6">Kotlin 101 &ndash; Flow control</h1>
<h3 id="jumping">Jumping</h3>
<p><strong>Jumping is awful, imperative, and you should not use it</strong>
<br/>
&hellip;but someone might and you must be able to understand it&hellip;</p>
<ul>
<li><code>break</code> and <code>continue</code> work as in Java</li>
<li><code>return</code> does not, as we will see when discussing higher order functions&hellip;</li>
</ul>
<h4 id="labeling">labeling</h4>
<ul>
<li>Any expression can be labeled: <code>label@ 1</code> is a valid expression</li>
<li><code>break</code>, <code>continue</code>, and <code>return</code> can be <em>qualified</em> with a label</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>outerloop<span style="color:#a61717;background-color:#e3d2d2">@</span> <span style="color:#080;font-weight:bold">for</span> (i <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">100</span>) {
    <span style="color:#080;font-weight:bold">for</span> (j <span style="color:#080;font-weight:bold">in</span> <span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">100</span>) {
        <span style="color:#080;font-weight:bold">if</span> (i * j == i + j) {
            println(<span style="color:#d20;background-color:#fff0f0">&#34;$i * $j equals $i + $j&#34;</span>)
            <span style="color:#080;font-weight:bold">break</span>@outerloop <span style="color:#888">// Qualified break
</span><span style="color:#888"></span>        }
    }
}
</code></pre></div></section><section>
<h1 id="kotlin-102----oop">Kotlin 102 &ndash; OOP</h1>
<h2 id="classes">Classes</h2>
<ul>
<li>Similar to Scala, the keyword <code>class</code> introduces a class definition</li>
<li>Object construction does not require <code>new</code>
<ul>
<li><code>new</code> is not a Kotlin keyword at all</li>
</ul>
</li>
<li>Objecs get built from classes by just invoking the class name:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>
Foo() <span style="color:#888">// a new Foo is created, no new keyword
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-1">Kotlin 102 &ndash; OOP</h1>
<h2 id="classes-and-members">Classes and members</h2>
<p>Kotlin classes have two types of members: <strong>methods</strong> and <strong>properties</strong></p>
<table>
<thead>
<tr>
<th>Language / Member Type</th>
<th align="center">Fields</th>
<th>Methods</th>
<th>Properties</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java</td>
<td align="center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td>Scala</td>
<td align="center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><strong>No</strong></td>
</tr>
<tr>
<td>Kotlin</td>
<td align="center"><strong>No</strong> (Hidden)</td>
<td><em>Yes</em></td>
<td><em>Yes</em></td>
</tr>
<tr>
<td>C#</td>
<td align="center"><em>Yes</em></td>
<td><em>Yes</em></td>
<td><em>Yes</em></td>
</tr>
</tbody>
</table>
<p>In Scala, at the caller site, methods and fields are hard to distinguish, as parentheses for 0-ary method calls are optional</p>
<p>In Kotlin, methods/functions (except when defined <code>infix</code>) are invoked with mandatory parentheses
<br/>
properties are instead invoked without parentheses</p>
</section><section>
<h1 id="kotlin-102----oop-2">Kotlin 102 &ndash; OOP</h1>
<h2 id="properties-vs-fields">Properties vs. fields</h2>
<p>Properties and fields are conceptually different</p>
<ul>
<li><em>fields</em> <strong>are</strong> the object&rsquo;s state</li>
<li><em>properties</em> are a way to <strong>access/change</strong> the object&rsquo;s state</li>
</ul>
<p>It&rsquo;s considered a good practice in languages without properties (Java in particular) to hide (<em>incapsulate</em>) fields (Object&rsquo;s actual state)
and provide access only via <code>get</code>/<code>set</code> methods: the actual state representation may change with no change to the API.</p>
<p>In Kotlin, fields are entirely hidden, and cannot be exposed in any way, enforcing the aforementioned convention at the language level.</p>
</section><section>
<h1 id="kotlin-102----oop-3">Kotlin 102 &ndash; OOP</h1>
<h2 id="defining-properties-for-classes">Defining properties for classes</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span> {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span> = <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: String? = <span style="color:#080;font-weight:bold">null</span>
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bazLength</span>: Int
        <span style="color:#080;font-weight:bold">get</span>() = baz?.length ?: <span style="color:#00d;font-weight:bold">0</span>
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">stringRepresentation</span>: String = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>
        <span style="color:#080;font-weight:bold">get</span>() = baz ?: field
        <span style="color:#080;font-weight:bold">set</span>(value) {
            field = <span style="color:#d20;background-color:#fff0f0">&#34;custom: $value&#34;</span>
        }

}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">foo</span> = Foo()
foo.bar = <span style="color:#00d;font-weight:bold">3</span><span class='fragment '  style="color: #888;"> // error: val cannot be reassigned</span>
foo.stringRepresentation<span class='fragment '  style="color: #888;"> // empty string</span>
foo.stringRepresentation = <span style="color:#d20;background-color:#fff0f0">&#34;zed&#34;</span><span class='fragment '  style="color: #888;"> // &#39;custom: zed&#39;</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-4">Kotlin 102 &ndash; OOP</h1>
<h2 id="backing-fields">Backing fields</h2>
<p>The keyword <code>field</code> allows access to a backing field of a property
<br/>
<strong>in case it is present</strong></p>
<p>The Kotlin compiler, in fact, generates backing fields only where it&rsquo;s needed</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span> {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">id</span>: String? = <span style="color:#080;font-weight:bold">null</span> <span style="color:#888">// Backing field generated
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">identifier</span>: String = <span style="color:#d20;background-color:#fff0f0">&#34;Student[${id ?: &#34;</span>unknown<span style="color:#d20;background-color:#fff0f0">&#34;}]&#34;</span> <span style="color:#888">// No backing field
</span><span style="color:#888"></span>}
</code></pre></div><p>When designing with Kotlin, you must consider methods and properties, and forget about fields.</p>
</section><section>
<h1 id="kotlin-102----oop-5">Kotlin 102 &ndash; OOP</h1>
<h2 id="defining-methods">Defining methods</h2>
<p>Methods are defined as <code>fun</code>ctions within the scope of a class</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutableComplex</span> {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">real</span>: Double = <span style="color:#00d;font-weight:bold">0.0</span>
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">imaginary</span>: Double = <span style="color:#00d;font-weight:bold">0.0</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: MutableComplex): MutableComplex = MutableComplex().also {
        it.real = real + other.real
        it.imaginary = imaginary + other.imaginary
    }
}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">foo</span> = MutableComplex()
foo.real = <span style="color:#00d;font-weight:bold">1.0</span>
foo.imaginary = <span style="color:#00d;font-weight:bold">2.0</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span> = MutableComplex()
bar.real = <span style="color:#00d;font-weight:bold">4.1</span>
bar.imaginary = <span style="color:#00d;font-weight:bold">0.1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">baz</span> = foo.plus(bar)
<span style="color:#d20;background-color:#fff0f0">&#34;${baz.real}+${baz.imaginary}i&#34;</span><span class='fragment '  style="color: #888;"> // 5.1&#43;2.1i</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-6">Kotlin 102 &ndash; OOP</h1>
<h2 id="interfaces">Interfaces</h2>
<ul>
<li>Similar to Java 8+</li>
<li>Methods can be implemented</li>
<li>Can host properties
<ul>
<li>And their accessors can be implemented</li>
<li>Properties in interfaces <em>do not have backing fields</em></li>
</ul>
</li>
<li>Both properties and methods can be implemented there</li>
<li>Scala-like mixins not supported
<ul>
<li>A Kotlin <code>interface</code> cannot be a subclass of a Kotlin <code>class</code></li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">trait</span> <span style="color:#b06;font-weight:bold">B</span> <span style="color:#080;font-weight:bold">extends</span> A <span style="color:#888">// All fine in Scala
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">B</span> : A <span style="color:#888">// error: an interface cannot inherit from a class
</span></code></pre></div><p>So, no mixins</p>
</section><section>
<h1 id="kotlin-102----oop-7">Kotlin 102 &ndash; OOP</h1>
<h2 id="implementing-interfaces">Implementing interfaces</h2>
<p>Much like Java. Subtyping keyword is <code>:</code>, overrides must be marked with <code>override</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Shape</span> {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">area</span>: Double
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">perimeter</span>: Double
}
<span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Shrinkable</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">shrink</span>(): Unit
}
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutableCircle</span> : Shape, Shrinkable {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">radius</span> = <span style="color:#00d;font-weight:bold">1.0</span>
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">area</span> <span style="color:#080;font-weight:bold">get</span>() = Math.PI * radius * radius
    <span style="color:#888">// What if we remove &#34;get()&#34;?
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">perimeter</span> <span style="color:#080;font-weight:bold">get</span>() = <span style="color:#00d;font-weight:bold">2</span> * Math.PI * radius
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">shrink</span>() {
        radius /= <span style="color:#00d;font-weight:bold">2</span>
    }
}
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-8">Kotlin 102 &ndash; OOP</h1>
<h2 id="superclass-disambiguation">Superclass disambiguation</h2>
<p>A call to <code>super</code> can be qualified to disambiguate between conflincting interface declarations:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">A</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#d20;background-color:#fff0f0">&#34;foo&#34;</span>
}
<span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">B</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>
}
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">C</span> : A, B {
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">foo</span>() = <span style="color:#080;font-weight:bold">super</span>&lt;A&gt;.foo() + <span style="color:#080;font-weight:bold">super</span>&lt;B&gt;.foo()
}
C().foo()<span class='fragment '  style="color: #888;"> // foobar</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-9">Kotlin 102 &ndash; OOP</h1>
<h2 id="primary-constructors-and-init">Primary constructors and <code>init</code></h2>
<p>Similar to Scala, but code in the class body is not part of a constructor
<br/>
Primary constructor code (if any) must be in an <code>init</code> block</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>(
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String, <span style="color:#888">// This is a val property of the class
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">baz</span>: Int, <span style="color:#888">// This is a var property of the class
</span><span style="color:#888"></span>    greeting: String = <span style="color:#d20;background-color:#fff0f0">&#34;Hello from constructor&#34;</span> <span style="color:#888">// Constructor parameter, not a property. Default values allowed.
</span><span style="color:#888"></span>) {
    init {
        println(greeting)
    }
}
Foo(<span style="color:#d20;background-color:#fff0f0">&#34;bar&#34;</span>, <span style="color:#00d;font-weight:bold">0</span>)
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-10">Kotlin 102 &ndash; OOP</h1>
<h2 id="secondary-constructors">Secondary <code>constructor</code>s</h2>
<p>More constructors can be added to a class, but them:</p>
<ol>
<li>Must call another constructor</li>
<li>The primary constructor must be in its <em>delegation calls chain</em></li>
</ol>
<p>Call to another constructor is performed using <code>:</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String) {
    <span style="color:#080;font-weight:bold">constructor</span>(longBar: Long) : <span style="color:#080;font-weight:bold">this</span>(<span style="color:#d20;background-color:#fff0f0">&#34;number ${longBar.toString()}&#34;</span>)
    <span style="color:#080;font-weight:bold">constructor</span>(intBar: Int) : <span style="color:#080;font-weight:bold">this</span>(intBar.toLong())
}
Foo(<span style="color:#00d;font-weight:bold">1</span>).bar <span style="color:#888">// number 1
</span></code></pre></div><p>The primary constructor can be written in a longer form with the <code>constructor</code> keyword as well</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span> <span style="color:#080;font-weight:bold">constructor</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">bar</span>: String) <span style="color:#888">// OK
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-11">Kotlin 102 &ndash; OOP</h1>
<h2 id="nullability-and-lateinit">Nullability and <code>lateinit</code></h2>
<p>It is possible that some <code>var</code> property needs to get initialized after the object construction:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span>: Father)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span>(<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son) <span style="color:#888">// Impossible to build either
</span></code></pre></div><p>Solution 1: allow nullability (<strong>BAD</strong>)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span>: Father)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span>(<span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son? = <span style="color:#080;font-weight:bold">null</span>)
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span> = Father()
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">son</span> = Son(father)
father.son = son
father.son.father <span style="color:#888">// error, needs ?.
</span></code></pre></div><p>Solution 1: take responsibility from the compiler (<em>less bad</em>)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Son</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span>: Father)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Father</span> { <span style="color:#080;font-weight:bold">lateinit</span> <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">son</span>: Son } <span style="color:#888">// lateinit: I will initialize it later, stay cool
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">father</span> = Father()
father.son <span style="color:#888">// UninitializedPropertyAccessException: lateinit property son has not been initialized
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">son</span> = Son(father)
father.son = son
father.son.father <span style="color:#888">// OK!
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-12">Kotlin 102 &ndash; OOP</h1>
<blockquote>
<p><strong>Design and document for inheritance or else prohibit it</strong><br/>
<em>J. Bloch, Effective Java, Item 17</em></p>
</blockquote>
<h2 id="closed-hierarchies-and-open">Closed hierarchies and <code>open</code></h2>
<p>Kotlin enforces EJ-17 by design: all classes are final if the keyword <code>open</code> is not specified</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// error: this type is final, so it cannot be inherited from
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// OK
</span></code></pre></div><p>As in Scala, <em>the constructor of the superclass must be called at extension site</em>
<br/>
Differently than Scala, such invocatin <em>always requires parentheses</em></p>
</section><section>
<h1 id="kotlin-102----oop-13">Kotlin 102 &ndash; OOP</h1>
<h2 id="abstract-vs-open"><code>abstract</code> vs. <code>open</code></h2>
<p>The same effect of <code>open</code> can be achieved with <code>abstract</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">B</span> : A() <span style="color:#888">// Perfectly fine
</span></code></pre></div><p>With abstract, however, the superclass cannot be created
<br/>
(and it should have actual <code>abstract</code> memebers anyway)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">open</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Open</span>
<span style="color:#080;font-weight:bold">abstract</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Abstract</span>
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FromOpen</span> : Open()
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">FromAbstract</span> : Abstract()
FromAbstract() <span style="color:#888">// OK
</span><span style="color:#888"></span>FromOpen() <span style="color:#888">// OK
</span><span style="color:#888"></span>Open() <span style="color:#888">// OK
</span><span style="color:#888"></span>Abstract() <span style="color:#888">// error: cannot create an instance of an abstract class
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-14">Kotlin 102 &ndash; OOP</h1>
<h2 id="singleton-objects">Singleton <code>object</code>s</h2>
<p>Same as Scala, but with explicit <code>companion</code>s
<br/>
In Scala</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span>
<span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">A</span> <span style="color:#888">// Same file and same name identify a companion
</span></code></pre></div><p>In Kotlin</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> {
    <span style="color:#080;font-weight:bold">companion</span> <span style="color:#080;font-weight:bold">object</span> <span style="color:#888">// Companions are inner to classes 
</span><span style="color:#888"></span>}
A <span style="color:#888">// refers to A.Companion
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">A</span> <span style="color:#888">// This is an independent object
</span><span style="color:#888"></span>A <span style="color:#888">// refers to the previously defined object
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-15">Kotlin 102 &ndash; OOP</h1>
<h2 id="information-hiding">Information hiding</h2>
<p>Simpler than Scala, more coherent than Java</p>
<ul>
<li><code>public</code> &ndash; default visibility, visible everywhere (API)</li>
<li><code>internal</code> &ndash; visible to everything in this <em>&ldquo;module&rdquo;</em>
<ul>
<li>module $\Rightarrow$ a set of Kotlin files compiled together</li>
</ul>
</li>
<li><code>protected</code> &ndash; visible to subclasses (but <em>not</em> to other members of the package)</li>
<li><code>private</code> &ndash; visible inside this class and its members</li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-16">Kotlin 102 &ndash; OOP</h1>
<h2 id="visibility-control">Visibility control</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Visibility</span> <span style="color:#080;font-weight:bold">internal</span> <span style="color:#080;font-weight:bold">constructor</span>( <span style="color:#888">// constructor is required to apply visibility restrictionss
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: Int <span style="color:#888">// Same as Scala
</span><span style="color:#888"></span>) { 
    <span style="color:#080;font-weight:bold">protected</span> <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">state</span> = <span style="color:#00d;font-weight:bold">0</span>
        <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">set</span> <span style="color:#888">// visibility restriction for properties in get/set methods
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="equality-hashing-string-version">Equality, hashing, string version</h2>
<p>Same as Java, but for equality:</p>
<ul>
<li><code>==</code> calls <code>equals</code></li>
<li>Java&rsquo;s stack variable comparison (<code>==</code>) is Kotlin&rsquo;s <code>===</code></li>
</ul>
<p>Kotlin does not suffer of Scala&rsquo;s equality issues
(no automatic conversion of types)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> a<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Int</span> = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> b<span style="color:#080;font-weight:bold">:</span> <span style="color:#888;font-weight:bold">Long</span> = a
a == b <span style="color:#888">// true
</span><span style="color:#888"></span>a equals b <span style="color:#888">// false O_O
</span></code></pre></div><p>Kotlin:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">a</span>: Int = <span style="color:#00d;font-weight:bold">1</span>
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">b</span>: Long = a <span style="color:#888">// error: type mismatch: inferred type is Int but Long was expected
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">b</span>: Long = a.toLong()
a == b <span style="color:#888">// error: operator &#39;==&#39; cannot be applied to &#39;Int&#39; and &#39;Long&#39;
</span><span style="color:#888"></span>a.toLong() == b <span style="color:#888">// true
</span><span style="color:#888"></span>a == b.toInt() <span style="color:#888">// true
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-1">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="infix-calls"><code>infix</code> calls</h2>
<p>Kotlin is less permissive than scala:</p>
<ul>
<li>In Scala, every instance method with a single parameter can be invoked as infix operator:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1</span> equals <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// infix invocation of 1.equals(1)
</span></code></pre></div><ul>
<li>In Kotlin, this is not allowed:</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1</span> equals <span style="color:#00d;font-weight:bold">1</span> <span style="color:#888">// error: &#39;infix&#39; modifier is required on &#39;equals&#39; in &#39;kotlin.Int&#39;
</span></code></pre></div><ul>
<li>Kotlin requires that the <code>infix</code> keyword for a method to be usable as infix</li>
<li><code>infix</code> functions have <em>lower precedence</em> than operators</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Infix</span> {
    <span style="color:#080;font-weight:bold">infix</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">with</span>(s: String) = <span style="color:#d20;background-color:#fff0f0">&#34;in... $s ...fix!&#34;</span>
}
Infix() with <span style="color:#d20;background-color:#fff0f0">&#34;Foo&#34;</span> <span style="color:#888">// in... Foo ...fix!
</span><span style="color:#888"></span>Infix() with <span style="color:#d20;background-color:#fff0f0">&#34;Foo&#34;</span> + <span style="color:#d20;background-color:#fff0f0">&#34;Bar&#34;</span> <span class='fragment '  style="color: #888;"> // in... FooBar ...fix</span>
Infix() with <span style="color:#d20;background-color:#fff0f0">&#34;Foo&#34;</span> + <span style="color:#d20;background-color:#fff0f0">&#34;Bar&#34;</span> + Infix() with <span style="color:#d20;background-color:#fff0f0">&#34;Baz&#34;</span> <span class='fragment '  style="color: #888;"> // error: unresolved reference: with (searched in String)</span>
</code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-2">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="operator-creation">Operator creation</h2>
<p>In Scala, operator names are valid method names, and prefix and infix calls are automatic:</p>
<ul>
<li>Very much the whole language philosophy: few concepts, high scalability</li>
<li>Easy to abuse, degenerating to esoteric operators
<ul>
<li>Especially when software is written by people with different background</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>executer(<span style="color:#080;font-weight:bold">:</span><span style="color:#888;font-weight:bold">/</span>(<span style="color:#888;font-weight:bold">host</span>, <span style="color:#888;font-weight:bold">port</span>) / target &lt;&lt; reqBody &gt;- { fromRespStr }) <span style="color:#888">// Using Databinder Dispatch
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> graph <span style="color:#080;font-weight:bold">=</span> <span style="color:#b06;font-weight:bold">Graph</span>((jfc ~+#&gt; fra)(<span style="color:#b06;font-weight:bold">Any</span>()), (fra ~+#&gt; dme)(<span style="color:#b06;font-weight:bold">Any</span>()) <span style="color:#888">// Using ScalaGraph
</span></code></pre></div><p>Operators are succint, but cryptic, and their meaning changes with context</p>
<p>This has been a source of cricism, Kotlin <strong>does not allow to define custom operators</strong></p>
<ul>
<li>At most, back-ticked names, but some characters are disallowed (<code>&gt;</code>, <code>/</code>, <code>:</code>, etc.)</li>
<li>Clumsy, defies the reason why one would use them (terse and succint code)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> { <span style="color:#080;font-weight:bold">infix</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">`~+#-`(</span><span style="color:#06b;font-weight:bold">other</span>: A) = <span style="color:#d20;background-color:#fff0f0">&#34;I&#39;m an arcane operator&#34;</span> }
A() <span style="color:#a61717;background-color:#e3d2d2">`</span>~+<span style="color:#a61717;background-color:#e3d2d2">#</span>-<span style="color:#a61717;background-color:#e3d2d2">`</span> A() <span style="color:#888">// I&#39;m an arcane operator
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-3">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="operator-overloading">Operator overloading</h2>
<p>Kotlin allows for a limited set of operators to be defined/overloaded</p>
<ul>
<li>Method names must match a convention</li>
<li>Methods must be annotated with the <code>operator</code> keyword</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Complex</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">real</span>: Double, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">imaginary</span>: Double) {
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: Complex) = Complex(real + other.real, imaginary + other.imaginary)
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">plus</span>(other: Double) = plus(Complex(other, <span style="color:#00d;font-weight:bold">0.0</span>))
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = real.toString() + <span style="color:#080;font-weight:bold">when</span> {
        imaginary == <span style="color:#00d;font-weight:bold">0.0</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>
        imaginary &gt; <span style="color:#00d;font-weight:bold">0.0</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;+${imaginary}i&#34;</span>
        <span style="color:#080;font-weight:bold">else</span> -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;${imaginary}i&#34;</span>
    }
}
Complex(<span style="color:#00d;font-weight:bold">1.0</span>, <span style="color:#00d;font-weight:bold">1.0</span>) + <span style="color:#00d;font-weight:bold">3.4</span> <span style="color:#888">// 4.4+1.0i
</span></code></pre></div></section><section>
<h1 id="kotlin-102----oop-conventions-4">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="unary-operator-overloading-table">Unary Operator overloading table</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+x</code></td>
<td align="center"><code>unaryPlus</code></td>
<td><code>x.unaryPlus()</code></td>
</tr>
<tr>
<td><code>-x</code></td>
<td align="center"><code>unaryMinus</code></td>
<td><code>x.unaryMinus()</code></td>
</tr>
<tr>
<td><code>++x</code></td>
<td align="center"><code>inc</code></td>
<td><code>x.inc().also { x = it }</code></td>
</tr>
<tr>
<td><code>x++</code></td>
<td align="center"><code>inc</code></td>
<td><code>x.also { x = it.inc() }</code></td>
</tr>
<tr>
<td><code>--x</code></td>
<td align="center"><code>dec</code></td>
<td><code>x.dec().also { x = it }</code></td>
</tr>
<tr>
<td><code>x--</code></td>
<td align="center"><code>dec</code></td>
<td><code>x.also { x = it.dec() }</code></td>
</tr>
<tr>
<td><code>!x</code></td>
<td align="center"><code>not</code></td>
<td><code>x.not()</code></td>
</tr>
<tr>
<td><code>x()</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke()</code></td>
</tr>
</tbody>
</table>
<p>Function invocation is an operator and can be overloaded!
<br/>
This will turn useful in future&hellip;</p>
</section><section>
<h1 id="kotlin-102----oop-conventions-5">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-arithmetic">Binary Operator overloading: arithmetic</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x + y</code></td>
<td align="center"><code>plus</code></td>
<td><code>x.plus(y)</code></td>
</tr>
<tr>
<td><code>x - y</code></td>
<td align="center"><code>minus</code></td>
<td><code>x.minus(y)</code></td>
</tr>
<tr>
<td><code>x * y</code></td>
<td align="center"><code>times</code></td>
<td><code>x.times(y)</code></td>
</tr>
<tr>
<td><code>x / y</code></td>
<td align="center"><code>div</code></td>
<td><code>x.div(y)</code></td>
</tr>
<tr>
<td><code>x % y</code></td>
<td align="center"><code>rem</code></td>
<td><code>x.rem(y)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-6">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-assignment">Binary Operator overloading: assignment</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x += y</code></td>
<td align="center"><code>plusAssign</code></td>
<td><code>x.plusAssign(y)</code></td>
</tr>
<tr>
<td><code>x -= y</code></td>
<td align="center"><code>minusAssign</code></td>
<td><code>x.minusAssign(y)</code></td>
</tr>
<tr>
<td><code>x *= y</code></td>
<td align="center"><code>timesAssign</code></td>
<td><code>x.timesAssign(y)</code></td>
</tr>
<tr>
<td><code>x /= y</code></td>
<td align="center"><code>divAssign</code></td>
<td><code>x.divAssign(y)</code></td>
</tr>
<tr>
<td><code>x %= y</code></td>
<td align="center"><code>remAssign</code></td>
<td><code>x.remAssign(y)</code></td>
</tr>
</tbody>
</table>
<ul>
<li>Assignment functions <em>can be defined only if their arithmetic equivalent is undefined</em>.</li>
<li>If an aritmetic operator <code>op</code> is defined, the compiler infers the assign version as:
<ul>
<li><code>a op= b</code> $\Rightarrow$ <code>a = a op b</code></li>
</ul>
</li>
</ul>
</section><section>
<h1 id="kotlin-102----oop-conventions-7">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-comparison">Binary Operator overloading: comparison</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x == y</code></td>
<td align="center"><code>equals</code></td>
<td><code>x?.equals(y) ?: (b === null)</code></td>
</tr>
<tr>
<td><code>x != y</code></td>
<td align="center"><code>equals</code></td>
<td><code>!(x?.equals(y) ?: (b === null))</code></td>
</tr>
<tr>
<td><code>x &gt; y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &gt; 0</code></td>
</tr>
<tr>
<td><code>x &lt; y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &lt; 0</code></td>
</tr>
<tr>
<td><code>x &gt;= y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &gt;= 0</code></td>
</tr>
<tr>
<td><code>x &lt;= y</code></td>
<td align="center"><code>compareTo</code></td>
<td><code>x.compareTo(y) &lt;= 0</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-8">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="binary-operator-overloading-others">Binary Operator overloading: others</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x..y</code></td>
<td align="center"><code>rangeTo</code></td>
<td><code>x.rangeTo(y)</code></td>
</tr>
<tr>
<td><code>x in y</code></td>
<td align="center"><code>contains</code></td>
<td><code>y.contains(x)</code></td>
</tr>
<tr>
<td><code>x !in y</code></td>
<td align="center"><code>contains</code></td>
<td><code>!y.contains(x)</code></td>
</tr>
<tr>
<td><code>x[y]</code></td>
<td align="center"><code>get</code></td>
<td><code>x.get(y)</code></td>
</tr>
<tr>
<td><code>x(y)</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke(y)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-9">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="ternary-operator-overloading">Ternary Operator overloading</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[y, z]</code></td>
<td align="center"><code>get</code></td>
<td><code>x.get(y, z)</code></td>
</tr>
<tr>
<td><code>x[y] = z</code></td>
<td align="center"><code>set</code></td>
<td><code>x.set(y) = z</code></td>
</tr>
<tr>
<td><code>x(y, z)</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke(y, z)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-102----oop-conventions-10">Kotlin 102 &ndash; OOP Conventions</h1>
<h2 id="n-ary-operator-overloading">n-ary Operator overloading</h2>
<table>
<thead>
<tr>
<th>Expression</th>
<th align="center">Method Name</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x[y, ..., z]</code></td>
<td align="center"><code>get</code></td>
<td><code>x.get(y, ..., z)</code></td>
</tr>
<tr>
<td><code>x[y, ..., z] = a</code></td>
<td align="center"><code>set</code></td>
<td><code>x.set(y, ..., z) = a</code></td>
</tr>
<tr>
<td><code>x(y, ..., z)</code></td>
<td align="center"><code>invoke</code></td>
<td><code>x.invoke(y, ..., z)</code></td>
</tr>
</tbody>
</table>
</section><section>
<h1 id="kotlin-103----generics">Kotlin 103 &ndash; Generics</h1>
<h2 id="compared-with-java-and-scala">Compared with Java and Scala</h2>
<p>Kotlin&rsquo;s type system supports generics</p>
<ul>
<li>Handier than Java&rsquo;s</li>
<li><strong>way</strong> less powerful than Scala&rsquo;s</li>
<li>No higher kinded types (they are in Scala)</li>
<li>No type lambdas (they are in Scala)</li>
<li>Declaration-site variance (absent in Java)</li>
<li>Generic type reification via inlining (not found in Java nor Scala)</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">trait</span> <span style="color:#b06;font-weight:bold">Functor</span>[<span style="color:#888;font-weight:bold">F</span>[<span style="color:#080;font-weight:bold">_</span>]] <span style="color:#888">// There is no Kotlin equivalent for these lines
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">MapFunctor</span> = <span style="color:#b06;font-weight:bold">Functor</span>[({ <span style="color:#080;font-weight:bold">type</span> <span style="color:#888;font-weight:bold">T</span>[<span style="color:#888;font-weight:bold">A</span>] <span style="color:#888;font-weight:bold">=</span> <span style="color:#888;font-weight:bold">Map</span>[<span style="color:#888;font-weight:bold">Int</span>, <span style="color:#888;font-weight:bold">A</span>] })<span style="color:#080;font-weight:bold">#</span><span style="color:#888;font-weight:bold">T</span>]
</code></pre></div></section><section>
<h1 id="kotlin-103----generics-1">Kotlin 103 &ndash; Generics</h1>
<h2 id="base-syntax">Base syntax</h2>
<p>Syntax similar to Java generics</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Foo</span>&lt;A, B : CharSequence&gt;
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#a61717;background-color:#e3d2d2">&lt;</span><span style="color:#06b;font-weight:bold">T</span> : Comparable&lt;T&gt;&gt; maxOf3(first: T, second: T, third: T): T = <span style="color:#080;font-weight:bold">when</span> {
    first &gt;= second &amp;&amp; first &gt;= third -&gt; first
    second &gt;= third -&gt; second
    <span style="color:#080;font-weight:bold">else</span> -&gt; third
}
</code></pre></div><ul>
<li>type upper bounds can be specified with <code>:</code></li>
<li>if no bound is specified, the generic is <em>nullable</em>!</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> &lt;T&gt; <span style="color:#06b;font-weight:bold">className</span>(receiver: T) = receiver::<span style="color:#080;font-weight:bold">class</span>.simpleName
<span style="color:#888">// error: expression in a class literal has a nullable type &#39;T&#39;, use !! to make the type non-nullable
</span></code></pre></div></section><section>
<h1 id="kotlin-103----generics-2">Kotlin 103 &ndash; Generics</h1>
<h2 id="where"><code>where</code></h2>
<p>In case multiple bounds are present, the definition can become cumbersome
<br/>
Kotlin provides a <code>where</code> keyword to specify type bounds separately from the rest of the signature</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// From an actual Alchemist interface
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">NavigationStrategy</span>&lt;T, P, A, L, R, N, E&gt;
    <span style="color:#080;font-weight:bold">where</span> P : Position&lt;P&gt;, P : Vector&lt;P&gt;,
          A : GeometricTransformation&lt;P&gt;,
          L : ConvexGeometricShape&lt;P, A&gt;,
          N : ConvexGeometricShape&lt;P, A&gt; {
<span style="color:#888">// Interface content, if any
</span><span style="color:#888"></span>}

<span style="color:#888">// Function syntax
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;T, P, A, L, R, N, E&gt; <span style="color:#06b;font-weight:bold">navigationStrategy</span>()
    <span style="color:#080;font-weight:bold">where</span> P : Position&lt;P&gt;, P : Vector&lt;P&gt;,
          A : GeometricTransformation&lt;P&gt;,
          L : ConvexGeometricShape&lt;P, A&gt;,
          N : ConvexGeometricShape&lt;P, A&gt; = TODO()
</code></pre></div></section><section>
<h1 id="kotlin-103----generics-3">Kotlin 103 &ndash; Generics</h1>
<h2 id="variance-and-type-projection">Variance and type projection</h2>
<p>Kotlin supports (co/contro)variance using:</p>
<ul>
<li><code>&lt;out T&gt;</code> to mark covariance (similar to Java&rsquo;s <code>&lt;? extends T&gt;</code>)</li>
<li><code>&lt;in T&gt;</code> to mark controvariance (similar to Java&rsquo;s <code>&lt;? super T&gt;</code>)</li>
<li><code>&lt;*&gt;</code> to mark that only the bound is known for the type (similar to Java&rsquo;s <code>&lt;?&gt;</code>)</li>
</ul>
<p>Type variant in Kotlin is expressed <em>at declaration site</em>!</p>
<ul>
<li>In Java type variance is only for methods</li>
<li>In Kotlin type variance is only for classes and interfaces</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">ProduceAndConsume</span>&lt;<span style="color:#080;font-weight:bold">in</span> X, <span style="color:#080;font-weight:bold">out</span> Y&gt; {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">consume</span>(x: X): Any = TODO()<span class='fragment '  style="color: #888;"> // OK</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">consume2</span>(y: Y): Any = TODO()<span class='fragment '  style="color: #888;"> // type parameter Y is declared as &#39;out&#39; but occurs in &#39;in&#39; position in type Y</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">produce</span>(): Y = TODO()<span class='fragment '  style="color: #888;"> // OK</span>
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">produce2</span>(): X = TODO()<span class='fragment '  style="color: #888;"> // error: type parameter X is declared as &#39;in&#39; but occurs in &#39;out&#39; position in type X</span>
}
</code></pre></div></section><section>
<h1 id="kotlin-103----generics-4">Kotlin 103 &ndash; Generics</h1>
<h2 id="type-reification">Type reification</h2>
<p>Generics at runtime can be dealt with two strategies:</p>
<ul>
<li><strong>erasure</strong>: generic information is used by the compiler, but it&rsquo;s discarded at runtime
<ul>
<li>Java / Scala</li>
</ul>
</li>
<li><strong>monomorphization</strong>: concrete type are emitted when generic types are actually used
<ul>
<li>Rust / C#</li>
</ul>
</li>
</ul>
<p>Delicate balance between executable size, performance, and usability</p>
<p>Kotlin uses erasure, but allows to control inlining via the <code>inline</code> keyword.
<br>
In inlined functions, <em>types can be locally monomorphized</em>!
<br>
Local monomorphization is expressed with the <code>reified</code> keyword.</p>
</section><section>
<h1 id="kotlin-103----generics-5">Kotlin 103 &ndash; Generics</h1>
<h2 id="type-reification-example">Type reification example</h2>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">inline</span> <span style="color:#080;font-weight:bold">fun</span> &lt;reified T&gt; <span style="color:#06b;font-weight:bold">checkIsType</span>(a: Any): T = a <span style="color:#080;font-weight:bold">is</span> T <span style="color:#888">// instance check on a generic!
</span><span style="color:#888"></span>checkIsType&lt;Long&gt;(<span style="color:#00d;font-weight:bold">1</span>) <span style="color:#888">// false
</span><span style="color:#888"></span>checkIsType&lt;Long&gt;(<span style="color:#00d;font-weight:bold">1L</span>) <span style="color:#888">// true
</span></code></pre></div><p>Note on Java interoperability:</p>
<ul>
<li><code>inline</code> functions get inlined if the caller is Kotlin-compiled code,
they don&rsquo;t if they are called by other bytecode-targeting compilers (<code>javac</code>, <code>scalac</code>&hellip;)</li>
<li><code>reified</code> types <em>requires</em> inlining to perform the local monorphization:
the function code is <em>copied</em> on call site, and the compiler must know how to do it</li>
</ul>
<p>$\Rightarrow$ Can&rsquo;t be used if interoperability is a concern</p>
<ul>
<li>or a wrapper must be provided</li>
</ul>
</section><section>
<h1 id="kotlin-103----collections">Kotlin 103 &ndash; Collections</h1>
<p>Similar to Scala, but based (for the JVM target) on the Java implementation</p>
<ul>
<li>No <code>toJava()</code>/<code>toScala()</code> equivalent</li>
<li><code>List</code>, <code>Set</code>, <code>Map</code> are <em>unmodifiable</em> but not guaranteed <em>immutable</em>
<ul>
<li>e.g., at runtime, <code>List</code> may be backed by an <code>ArrayList</code></li>
<li>clients calling from Java will see mutable collections</li>
<li>Under the JVM, the immutable interfaces are erased at runtime</li>
</ul>
</li>
<li>Mutable collections are available via <code>Mutable</code>(<code>List</code>/<code>Set</code>/<code>Map</code>)</li>
<li>As in Scala, invocation of functional manipulation on collections returns a new collection</li>
<li>Differently than Scala, when a collection is returned, the type is usually <code>List</code>
<ul>
<li>Type is lost, no higher kinded types in Kotlin to express it</li>
</ul>
</li>
<li><code>Sequence</code>s prevent a collection creation at each step</li>
<li><code>Flow</code>s represent collections that are processed in parallel</li>
<li>Creation usually via functions <code>flowOf</code>/<code>listOf</code>/<code>mapOf</code>/<code>sequenceOf</code>/<code>setOf</code></li>
</ul>
</section><section>
<h1 id="kotlin-201----advanced-oop">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="data-classes">Data classes</h2>
<p>Very similar to Scala&rsquo;s <code>case class</code>es:</p>
<ul>
<li>inheritance prohibited (Scala allows non-<code>case</code> classes to inherit from <code>case</code> classes)</li>
<li><code>equals</code>, <code>hashCode</code>, <code>toString</code> for free</li>
<li><code>copy</code> function, to be used to generate new immutable objects</li>
<li><code>component1</code>, <code>component2</code>, &hellip;, <code>componentN</code> functions, called in case of destructuring</li>
</ul>
<p><code>Pair</code> and <code>Triple</code> provided by the standard library
<br/>
(<code>Tuple4</code>, <code>Tuple5</code>, and so on are not in standard library as opposed as Scala)</p>
</section><section>
<h1 id="kotlin-201----advanced-oop-1">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="destructuring-declarations">Destructuring declarations</h2>
<p>If a class has <code>operator</code> functions named called <code>componentX</code> with <code>X</code> an integer from <code>1</code>,
they can be &ldquo;destructured&rdquo;.
<br>
This feature is <em>way</em> less powerful than Scala&rsquo;s pattern matching.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// to is an inline function that creates a Pair, similar to Scala&#39;s -&gt;
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">ferrari2021</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Ferrari&#34;</span> to Pair(<span style="color:#d20;background-color:#fff0f0">&#34;Sainz&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;Leclerc&#34;</span>)
<span style="color:#080;font-weight:bold">val</span> <span style="color:#a61717;background-color:#e3d2d2">(</span><span style="color:#369;font-weight:bold">team</span>, lineup) = ferrari2021
team <span style="color:#888">// &#34;Ferrari&#34;
</span><span style="color:#888"></span>lineup <span style="color:#888">// Sainz to Leclerc
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">val</span> <span style="color:#a61717;background-color:#e3d2d2">(</span><span style="color:#369;font-weight:bold">driver1</span>, driver2) = lineup
driver1 <span style="color:#888">// Sainz
</span><span style="color:#888"></span>driver2 <span style="color:#888">// Leclerc
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">A</span> {
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">component1</span>() = <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">component2</span>() = <span style="color:#00d;font-weight:bold">2</span>
    <span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">component3</span>() = <span style="color:#00d;font-weight:bold">3</span>
}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#a61717;background-color:#e3d2d2">(</span><span style="color:#369;font-weight:bold">a</span>, b, c) = A()
<span style="color:#d20;background-color:#fff0f0">&#34;$a$b$c&#34;</span>
</code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-2">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="sealed-hierarchies">Sealed hierarchies</h2>
<p>Similar to Scala&rsquo;s <code>sealed trait</code>s:</p>
<ul>
<li><code>class</code>es, not supported for <code>interface</code>s</li>
<li>subtypes must be defined inside the sealed class</li>
<li>sealed hierarchies proved <em>exhaustive checking</em> inside <code>where</code> clauses</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">sealed</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Booze</span> {
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Rum</span> : Booze()
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Whisky</span> : Booze()
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Vodka</span> : Booze()
}
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">goGetMeA</span>(beverage: Booze) = <span style="color:#080;font-weight:bold">when</span> (beverage) {
    <span style="color:#080;font-weight:bold">is</span> Booze.Rum -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;Diplomatico&#34;</span>
    <span style="color:#080;font-weight:bold">is</span> Booze.Whisky -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;Caol Ila&#34;</span>
    <span style="color:#080;font-weight:bold">is</span> Booze.Vodka -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;Zubrowka&#34;</span>
}
goGetMeA(Booze.Rum())
</code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-3">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="nested-and-inner-classes">Nested and inner classes</h2>
<ul>
<li>Nesting a class inside another does not allow access to outer members
<ul>
<li>It&rsquo;s equivalent to a Java&rsquo;s <code>static</code> inner class</li>
</ul>
</li>
<li>To create an inner class, the <code>inner</code> modifier must be explicit</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Outer</span> {
    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">readMeIfYouCan</span> = <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Nested</span> {
        init { println(readMeIfYouCan) } <span style="color:#888">// error: unresolved reference: readMeIfYouCan
</span><span style="color:#888"></span>    }
}
</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Outer</span> { <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Nested</span> }
Outer.Nested() <span style="color:#888">// OK
</span></code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Outer</span> {
    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">readMeIfYouCan</span> = <span style="color:#00d;font-weight:bold">1</span>
    <span style="color:#080;font-weight:bold">inner</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Inner</span> {
        init { println(readMeIfYouCan) } <span style="color:#888">// ok
</span><span style="color:#888"></span>    }
}
Outer.Inner() <span style="color:#888">// error: constructor of inner class Inner can be called only with receiver of containing class
</span><span style="color:#888"></span>Outer().Inner() <span style="color:#888">// OK
</span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-4">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="enum-classes">Enum classes</h2>
<p>Same as Java, with Kotlin syntax</p>
<h2 id="object-expressions">Object expressions</h2>
<p><code>object</code> expressions replace anonymous classes</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">interface</span> <span style="color:#b06;font-weight:bold">Test</span> {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">first</span>(): Unit
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">second</span>(): Unit
}
<span style="color:#080;font-weight:bold">object</span> <span style="color:#a61717;background-color:#e3d2d2">: </span><span style="color:#b06;font-weight:bold">Test</span> {
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">first</span>() { }
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">second</span>() { }
}
</code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-5">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="type-aliases">Type aliases</h2>
<ul>
<li>Types can be aliased</li>
<li>Only at the top level</li>
<li>Type aliases in kotlin <strong>are not</strong> Scala&rsquo;s <code>type</code> definitions</li>
<li>Kotlin has no equivalent of Scala&rsquo;s <code>type</code></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>typealias Drivers = Pair&lt;String, String&gt;
typealias Team = Pair&lt;String, Drivers&gt;
typealias Formula1 = Map&lt;String, Team&gt;
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">`f1 2020`</span> = mapOf(
    Team(<span style="color:#d20;background-color:#fff0f0">&#34;Ferrari&#34;</span>, Drivers(<span style="color:#d20;background-color:#fff0f0">&#34;Vettel&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;Leclerc&#34;</span>)),
    Team(<span style="color:#d20;background-color:#fff0f0">&#34;RedBull&#34;</span>, Drivers(<span style="color:#d20;background-color:#fff0f0">&#34;Versbatten&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;Albon&#34;</span>)),
    Team(<span style="color:#d20;background-color:#fff0f0">&#34;Merdeces&#34;</span>, Drivers(<span style="color:#d20;background-color:#fff0f0">&#34;Hamilton&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;Bottas&#34;</span>)),
)
<span style="color:#a61717;background-color:#e3d2d2">`</span>f1 <span style="color:#00d;font-weight:bold">2020</span><span style="color:#a61717;background-color:#e3d2d2">`</span> <span style="color:#888">// Map&lt;String, Pair&lt;String, Pair&lt;String, String&gt;&gt;&gt;
</span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-6">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="delegation">Delegation</h2>
<blockquote>
<p><strong>Favour composition over inheritance</strong><br/>
<code>A</code> should extend <code>B</code> only if <code>A</code> truly â€˜is-aâ€™ a <code>B</code>, if not, <em>use composition</em> instead, which means A should hold a reference of B and expose a simpler API.<br/>
<em>J. Bloch, Effective Java, Item 16</em></p>
</blockquote>
<p><strong>Delegation</strong> is one of the mechanisms to implement composition,
see the <a href="https://en.wikipedia.org/wiki/Delegation_pattern">delegation pattern</a>
<br/>
Delegation is often verbose and very mechanic in implementation</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">surname</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: String)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Exam</span> : MutableCollection&lt;Student&gt; {
    <span style="color:#080;font-weight:bold">private</span> <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">representation</span> = mutableListOf&lt;Student&gt;()
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">add</span>(e E) = representation.add(e)
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">addAll</span>(e E) = representation.addAll(e)
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">clear</span>() = representation.clear()
    ... <span style="color:#888">// BOOOOOOORING
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-7">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="delegation-via-by">Delegation via <code>by</code></h2>
<p>Kotlin supports delegation at the language level</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">data</span> <span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Student</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">surname</span>: String, <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">id</span>: String)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Exam</span> : MutableCollection&lt;Student&gt; <span style="color:#080;font-weight:bold">by</span> mutableListOf&lt;Student&gt;() {
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">register</span>(name: String, surname: String, id: String) = add(Student(name, surname, id))
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = toList().toString() <span style="color:#888">// No access to the delegate! Can&#39;t call toString on it!
</span><span style="color:#888"></span>}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">exam</span> = Exam()
exam.register(<span style="color:#d20;background-color:#fff0f0">&#34;Luca&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;Ghiotto&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;00000025&#34;</span>)
exam <span style="color:#888">// [Student(name=Luca, surname=Ghiotto, id=00000025)]
</span><span style="color:#888"></span>exam.clear()
exam <span style="color:#888">// []
</span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-8">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="delegated-properties-and-variables">Delegated properties and variables</h2>
<p>Properties and variables can be delegated as well
<br/>
some delegates are built-in, e.g. <code>lazy</code></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">someLazyString</span> <span style="color:#080;font-weight:bold">by</span> lazy {
    println(<span style="color:#d20;background-color:#fff0f0">&#34;I&#39;m initializing myself&#34;</span>)
    <span style="color:#d20;background-color:#fff0f0">&#34;I&#39;m intialized&#34;</span>
}
println(<span style="color:#d20;background-color:#fff0f0">&#34;Doing stuff&#34;</span>)
println(someLazyString) <span style="color:#888">// &#34;I&#39;m initializing myself&#34; gets printed here
</span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-9">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="delegation-via-maps">Delegation via maps</h2>
<p>Class properties can be stored in an appropriate <code>Map</code>
<br/>
Useful when dealing with dynamic languages or untyped serialization (e.g. JSON or YAML)</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">fromJson</span> = mapOf(<span style="color:#d20;background-color:#fff0f0">&#34;name&#34;</span> to <span style="color:#d20;background-color:#fff0f0">&#34;John Smith&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;birthYear&#34;</span> to <span style="color:#00d;font-weight:bold">2020</span>)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">Person</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">jsonRepresentation</span>: Map&lt;String, Any&gt;) {
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span> <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">birthYear</span>: Int <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = <span style="color:#d20;background-color:#fff0f0">&#34;$name born in $birthYear&#34;</span>
}
Person(fromJson)
</code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-10">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="delegation-via-maps-and-mutability">Delegation via maps and mutability</h2>
<p>In case of mutable properties, a <code>MutableMap</code> is required as delegate</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">janesJson</span>: MutableMap&lt;String, Any&gt; = mutableMapOf(<span style="color:#d20;background-color:#fff0f0">&#34;name&#34;</span> to <span style="color:#d20;background-color:#fff0f0">&#34;Jane Smith&#34;</span>, <span style="color:#d20;background-color:#fff0f0">&#34;birthYear&#34;</span> to <span style="color:#00d;font-weight:bold">1999</span>)
<span style="color:#080;font-weight:bold">class</span> <span style="color:#b06;font-weight:bold">MutablePerson</span>(<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">jsonRepresentation</span>: MutableMap&lt;String, Any&gt;) {
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">name</span> <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
    <span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">birthYear</span>: Int <span style="color:#080;font-weight:bold">by</span> jsonRepresentation
    <span style="color:#080;font-weight:bold">override</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">toString</span>() = <span style="color:#d20;background-color:#fff0f0">&#34;$name born in $birthYear&#34;</span>
}
<span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">jane</span> = MutablePerson(janesJson)
jane.toString()
jane.name = <span style="color:#d20;background-color:#fff0f0">&#34;Janet Smitherson&#34;</span>
jane.toString()
janesJson <span style="color:#888">// Does it change? <span class='fragment '  style="color: #888;">{name=Janet Smitherson, birthYear=1999} -- YES! Bidirectional</span>
</span></code></pre></div></section><section>
<h1 id="kotlin-201----advanced-oop-11">Kotlin 201 &ndash; Advanced OOP</h1>
<h2 id="custom-delegates">Custom delegates</h2>
<p>A valid delegate for a <code>val</code> is a <code>class</code> with a method:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">getValue</span>(thisRef: T, property: KProperty&lt;*&gt;): R
</code></pre></div><p>where T is the &ldquo;owner&rdquo; type, and R is the type of the property</p>
<p>A valid delegate for a <code>var</code> must also have a <code>setValue</code> method:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">operator</span> <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">setValue</span>(thisRef: T, property: KProperty&lt;*&gt;, value: P): R
</code></pre></div><p>where T and R are the same as in <code>getValue</code>, and P is a supertype of R</p>
</section><section>
<h1 id="kotlin-202----functional-kotlin">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="lambda-expressions">Lambda expressions</h2>
<p>Kotlin lambda expression&rsquo;s syntax is inspired by Groovy
<br/>
and is similar to Smalltalk / Ceylon / Xtend / Ruby as well</p>
<ul>
<li>Enclosing an expression in curly brackets creates a lambda expression</li>
<li>Parameters are listed <em>inside</em> the brackets, a <code>-&gt;</code> separates them from the body</li>
<li>If there is one single parameter, it can be unspecified and referred with the keyword <code>it</code></li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">myLambda</span> = {
    println(<span style="color:#d20;background-color:#fff0f0">&#34;Hey I&#39;m computing&#34;</span>)
}
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">whatsMyReturnType</span>() = { 
    <span style="color:#d20;background-color:#fff0f0">&#34;A string&#34;</span>
}
myLambda.invoke() <span style="color:#888">// Java-style invocation
</span><span style="color:#888"></span>myLambda() <span style="color:#888">// Decent-style invocation (invoke is an operator!)
</span><span style="color:#888"></span>myLambda()() <span style="color:#888">// Guess <span class='fragment '  style="color: #888;">error: expression &#39;myLambda()&#39; of type &#39;Unit&#39; cannot be invoked as a function.</span>
</span><span style="color:#888"></span>whatsMyReturnType() <span style="color:#888">// Guess <span class='fragment '  style="color: #888;">Subtle, but the compiler raises warnings</span>
</span><span style="color:#888"></span>whatsMyReturnType()() <span style="color:#888">// Guess <span class='fragment '  style="color: #888;">A string</span>
</span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-1">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="function-type-literals">Function type literals</h2>
<p>Just as Scala, Kotlin supports function type literals
<br/>
No need for verbose interfaces such as <code>Function&lt;T, R&gt;</code>, <code>BiConsumer&lt;T, R&gt;</code>, etc.</p>
<p>Function type literals have parameter types between parentheses, a <code>-&gt;</code>, and the result parameter</p>
<ul>
<li><code>() -&gt; Any</code> &ndash; A 0-ary function returning <code>Any</code></li>
<li><code>(String) -&gt; Any</code> &ndash; A unary function taking a <code>String</code> and returning <code>Any</code></li>
<li><code>(String, Int) -&gt; Unit</code> &ndash; A binary function taking a <code>String</code> and an <code>Int</code> and returning <code>Unit</code></li>
<li><code>(String, Int?) -&gt; Any?</code> &ndash; A binary function taking a <code>String</code> and a nullable <code>Int?</code> returning a nullable <code>Any?</code></li>
</ul>
<p>Function type literals allow for writing cleaner <em>higher-order functions</em></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> &lt;T, I, R&gt; <span style="color:#06b;font-weight:bold">compose</span>(f: (I) -&gt; R, g: (T) -&gt; I): (T) -&gt; R = { f(g(it)) }
compose({v: Int -&gt; v * v}, {v: Double -&gt; v.toInt()})(<span style="color:#00d;font-weight:bold">3.9</span>) <span style="color:#888">// 9
</span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-2">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="function-references">Function references</h2>
<p>Functions can be referred by using <code>::</code>
<br/>
the left operand is the receiver (if present)
<br/>
the right operand is the function name</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> &lt;T, I, R&gt; <span style="color:#06b;font-weight:bold">compose</span>(f: (I) -&gt; R, g: (T) -&gt; I): (T) -&gt; R = { f(g(it)) }
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">square</span>(v: Int) = v * v
<span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">floor</span>(v: Double) = v.toInt()
compose(::square, ::floor)(<span style="color:#00d;font-weight:bold">3.9</span>)
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-3">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="the-trailing-lambda-convention">The <strong>trailing lambda</strong> convention</h2>
<p>A simple special rule that enables very elegant syntactic forms:
<br/>
<em>if a lambda expression is the last parameter in a function call</em>
<br/>
<em>then it can be placed outside of the parentheses</em></p>
<p>If used correctly, feels like adding custom blocks to a language</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape> <span style="color:#888">// Java&#39;s thread + trailing lambda + SAM conversion
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">delayed</span>(delay: Long = <span style="color:#00d;font-weight:bold">1000L</span>, operation: () -&gt; Unit) = Thread {
    Thread.sleep(delay)
    operation()
}.start()
println(<span style="color:#d20;background-color:#fff0f0">&#34;Start&#34;</span>)
<span style="color:#888">// Now we have a delayed block!
</span><span style="color:#888"></span>delayed {
    println(<span style="color:#d20;background-color:#fff0f0">&#34;I was waiting&#34;</span>)
}
delayed(<span style="color:#00d;font-weight:bold">300</span>) { println(<span style="color:#d20;background-color:#fff0f0">&#34;I wait less&#34;</span>) }
println(<span style="color:#d20;background-color:#fff0f0">&#34;Finished&#34;</span>)
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-4">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="closures">Closures</h2>
<p>Closures are supoorted
<br/>
They are allowed on <code>var</code>s as well as on <code>val</code>s</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Side effecting from functional manipulation is bad though
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">var</span> <span style="color:#369;font-weight:bold">sum</span> = <span style="color:#00d;font-weight:bold">0</span>
(<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">100</span>).map {
    sum += it
    it * <span style="color:#00d;font-weight:bold">2</span>
}
sum
sum == (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">100</span>).sum()
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-5">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="flow-control-with-lambdas">Flow control with lambdas</h2>
<p>Kotlin rule: <code>return</code> returns from the closest <em>named</em> <code>fun</code>ction</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">breakingFlow</span>(): List&lt;Int&gt; = (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">10</span>).toList().map {
    <span style="color:#080;font-weight:bold">if</span> (it &gt; <span style="color:#00d;font-weight:bold">4</span>) {
        <span style="color:#080;font-weight:bold">return</span> (<span style="color:#00d;font-weight:bold">0.</span>.it).toList() <span style="color:#888">// returns from breakingFlow
</span><span style="color:#888"></span>    }
    it
}
breakingFlow()
</code></pre></div><p>A <em>qualified <code>return</code></em> can be used to return from lambdas:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">breakingFlow</span>(): List&lt;Int&gt; = (<span style="color:#00d;font-weight:bold">0.</span>.<span style="color:#00d;font-weight:bold">10</span>).toList().map {
    <span style="color:#080;font-weight:bold">if</span> (it &gt; <span style="color:#00d;font-weight:bold">4</span>) {
        <span style="color:#080;font-weight:bold">return</span>@map it * <span style="color:#00d;font-weight:bold">10</span> <span style="color:#888">// returns from the lambda
</span><span style="color:#888"></span>    }
    it
}
breakingFlow()
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-6">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="destructuring-lambda-parameters">Destructuring lambda parameters</h2>
<p>Lambda parameters can be destructured</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>mapOf(<span style="color:#00d;font-weight:bold">46</span> to <span style="color:#d20;background-color:#fff0f0">&#34;Rossi&#34;</span>, <span style="color:#00d;font-weight:bold">4</span> to <span style="color:#d20;background-color:#fff0f0">&#34;Dovizioso&#34;</span>).map { (number, rider) -&gt;
    <span style="color:#888">// destructured Pair
</span><span style="color:#888"></span>    <span style="color:#d20;background-color:#fff0f0">&#34;$rider has number $number&#34;</span>
}
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-7">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="extension-functions">Extension functions</h2>
<p>Kotlin allows to extend any type capabilities from anywhere
<br/>
via <strong>extension functions</strong></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">String</span>.containsBatman(): Boolean = <span style="color:#d20;background-color:#fff0f0">&#34;.*b.*a.*t.*m.*a.*n.*&#34;</span>.toRegex().matches(<span style="color:#080;font-weight:bold">this</span>)
<span style="color:#d20;background-color:#fff0f0">&#34;battere le mani&#34;</span>.containsBatman() <span style="color:#888">// true
</span></code></pre></div><p>Inside extension functions, the <em>receiver</em> of the method is overridden
<br/>
Any type, including nullables, can be extended
<br/>
<code>object</code>s and <code>companion</code>s can be extended as well</p>
<p><strong>IMPORTANT</strong>: calls to extension methods are resolved <em>statically</em>.
<br/>
Namely, <em>the receiver type is determined at compile time</em>.</p>
<p><strong>IMPORTANT/2</strong>: Extensions cannot shadow members,
<em>members always take priority</em></p>
</section><section>
<h1 id="kotlin-202----functional-kotlin-8">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="extension-properties">Extension properties</h2>
<p>Same as functions, but for properties</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">String</span>.containsBatman <span style="color:#080;font-weight:bold">get</span>(): Boolean = <span style="color:#d20;background-color:#fff0f0">&#34;.*b.*a.*t.*m.*a.*n.*&#34;</span>.toRegex().matches(<span style="color:#080;font-weight:bold">this</span>)
<span style="color:#d20;background-color:#fff0f0">&#34;battere le mani&#34;</span>.containsBatman <span style="color:#888">// true
</span></code></pre></div><p>Note:</p>
<ol>
<li>extension properties cannot have backing fields</li>
<li>extension properties can&rsquo;t get initialized,
their behaviour is entirely specified by <code>get</code> and <code>set</code> accessors.</li>
</ol>
</section><section>
<h1 id="kotlin-202----functional-kotlin-9">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="extension-function-type-literals">Extension function type literals</h2>
<p>Extensions functions are&hellip; functions, like any other
<br/>
as such, their type can be legally expressed by:</p>
<ul>
<li>prefixing the *receiver type</li>
<li>following by a <code>.</code></li>
<li>then list parameters and return types as for any function type literal</li>
</ul>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#888">// Extension function taking an extension function as parameter
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;T&gt; <span style="color:#06b;font-weight:bold">MutableList</span>&lt;T&gt;.configure(configuration: MutableList&lt;T&gt;.() -&gt; Unit): MutableList&lt;T&gt; {
    configuration()
    <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">this</span>
}
<span style="color:#888">// We are creating a configuration block!
</span><span style="color:#888"></span>mutableListOf&lt;String&gt;().configure {
    add(<span style="color:#d20;background-color:#fff0f0">&#34;Pippo&#34;</span>)
    add(<span style="color:#d20;background-color:#fff0f0">&#34;Pluto&#34;</span>)
    add(<span style="color:#d20;background-color:#fff0f0">&#34;Paperino&#34;</span>)
}
</code></pre></div><p>&hellip;sounds easy to write DSLs&hellip;</p>
</section><section>
<h1 id="kotlin-202----functional-kotlin-10">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="extension-members-and-implicit-receivers">Extension members and implicit receivers</h2>
<p>When extensions are defined as members, there are multiple <em>implicit recevers</em>:</p>
<ol>
<li><strong>dispatch receiver</strong>: the <code>object</code> or instance of the <code>class</code> in which the extension is declared</li>
<li><strong>extension receiver</strong> the instance of the <em>receiver type</em> of the extension is called</li>
</ol>
<p><em>Extension receivers have priority</em>, dispatch receivers access requires the <em>qualified <code>this</code></em> syntax
<br/></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">Batman</span> { <span style="color:#888">// the Batman object is the dispatch receiver
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Batman&#34;</span>
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">String</span>.Companion.intro <span style="color:#080;font-weight:bold">get</span>() = generateSequence { Double.NaN } <span style="color:#888">// String.Companion is extension receiver
</span><span style="color:#888"></span>        .take(<span style="color:#00d;font-weight:bold">10</span>)
        .joinToString(separator = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>)
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">String</span>.withBatman() = <span style="color:#d20;background-color:#fff0f0">&#34;$this ${this@Batman.name}!&#34;</span> <span style="color:#888">// Qualified this access to the dispatch receiver
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-11">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="dsl-scope-control-via-extension-members">DSL scope control via extension members</h2>
<p>Extension members are visible only when the dispatch receiver is the type where the extensions were defined
<br/>
This enables a powerful form of <em>scope control</em></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#080;font-weight:bold">object</span> <span style="color:#b06;font-weight:bold">Batman</span> { <span style="color:#888">// Batman is the dispatch receiver
</span><span style="color:#888"></span>    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">name</span> = <span style="color:#d20;background-color:#fff0f0">&#34;Batman&#34;</span>
    <span style="color:#080;font-weight:bold">val</span> <span style="color:#369;font-weight:bold">String</span>.Companion.intro <span style="color:#080;font-weight:bold">get</span>() = generateSequence { Double.NaN } <span style="color:#888">// String is extension receiver
</span><span style="color:#888"></span>        .take(<span style="color:#00d;font-weight:bold">10</span>)
        .joinToString(separator = <span style="color:#d20;background-color:#fff0f0">&#34;&#34;</span>)
    <span style="color:#080;font-weight:bold">fun</span> <span style="color:#06b;font-weight:bold">String</span>.withBatman() = <span style="color:#d20;background-color:#fff0f0">&#34;$this ${this@Batman.name}!&#34;</span> <span style="color:#888">// Qualified this access to the dispatch receiver
</span><span style="color:#888"></span>}
<span style="color:#888">// Extension members are actual members! They require a receiver!
</span><span style="color:#888"></span>String.intro.withBatman() <span style="color:#888">// error: unresolved reference: intro
</span><span style="color:#888"></span><span style="color:#080;font-weight:bold">fun</span> &lt;T, R&gt; <span style="color:#06b;font-weight:bold">insideTheScopeOf</span>(receiver: T, method: T.() -&gt; R): R = receiver.method() 
insideTheScopeOf(Batman) { <span style="color:#888">// inside this function, Batman is the dispatch receiver!
</span><span style="color:#888"></span>    String.intro.withBatman() <span style="color:#888">// OK!
</span><span style="color:#888"></span>}
</code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-12">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="scope-functions">Scope functions</h2>
<p>Kotlin provides a number of built-in functions that run a lambda expression in a custom scope:</p>
<ul>
<li>by changing the receiver (as we&rsquo;ve done with <code>insideTheScopeOf</code> in the previous slide)</li>
<li>by creating an implicit <code>it</code> parameter</li>
<li>by changing the return type</li>
</ul>
</section><section>
<h1 id="kotlin-202----functional-kotlin-13">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="scope-functions-1">Scope functions</h2>
<h4 id="let--tt---r-r"><code>let</code> : <code>T.((T) -&gt; R) R</code></h4>
<p>Can be invoked on an object, passing a lambda expression.
<br/>
The method receiver is bound to the lambda parameter
<br/>
the return type is the result of the function</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1.l</span>et { <span style="color:#d20;background-color:#fff0f0">&#34;${it + 1}1&#34;</span> } <span style="color:#888">// 21: String
</span><span style="color:#888"></span><span style="color:#00d;font-weight:bold">1.l</span>et { one -&gt; <span style="color:#d20;background-color:#fff0f0">&#34;${one + 1}1&#34;</span> } <span style="color:#888">// Same as above: it&#39;s a normal lambda
</span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-14">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="scope-functions-2">Scope functions</h2>
<h4 id="run--tt---r---r"><code>run</code> : <code>T.(T.() -&gt; R) -&gt; R</code></h4>
<p>Can be invoked on an object, passing a lambda expression.
<br/>
The method receiver is bound to the implicit receiver <code>this</code>
<br/>
the return type is the result of the function</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1.</span>run { <span style="color:#d20;background-color:#fff0f0">&#34;${this + 1}1&#34;</span> } <span style="color:#888">// 21: String
</span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-15">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="scope-functions-3">Scope functions</h2>
<h4 id="with--t---r---r"><code>with</code> : <code>(T.() -&gt; R) -&gt; R</code></h4>
<p>Non-extension version of <code>run</code>,
the context object is passed as first parameter
<br/>
The method receiver is bound to the implicit receiver <code>this</code>
<br/>
the return type is the result of the function</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape>with(<span style="color:#00d;font-weight:bold">1</span>) { <span style="color:#d20;background-color:#fff0f0">&#34;${this + 1}1&#34;</span> } <span style="color:#888">// 21: String
</span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-16">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="scope-functions-4">Scope functions</h2>
<h4 id="apply--tt---unit---t"><code>apply</code> : <code>T.(T.() -&gt; Unit) -&gt; T</code></h4>
<p>Similar to <code>run</code>,
but returns the context object
<br/>
Used to cause side effects from a specific context,
and returning the original object</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1.</span>apply { println(<span style="color:#d20;background-color:#fff0f0">&#34;${this + 1}1&#34;</span>) } <span style="color:#888">// Prints 21, returns 1
</span><span style="color:#888"></span>mutableListOf&lt;Int&gt;().apply {
    addAll((<span style="color:#00d;font-weight:bold">1.</span>.<span style="color:#00d;font-weight:bold">10</span>).toList())
} <span style="color:#888">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</span></code></pre></div></section><section>
<h1 id="kotlin-202----functional-kotlin-17">Kotlin 202 &ndash; Functional Kotlin</h1>
<h2 id="scope-functions-5">Scope functions</h2>
<h4 id="also--t---unit---t"><code>also</code> : <code>T.(() -&gt; Unit) -&gt; T</code></h4>
<p>Similar to <code>apply</code>, but does not change the context,
<br/>
the context object is bound to the first lambda parameter
<br/>
Used to cause side effects and returning the original object</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="nohighlight" data-noescape><span style="color:#00d;font-weight:bold">1.</span>also { println(<span style="color:#d20;background-color:#fff0f0">&#34;${it + 1}1&#34;</span>) } <span style="color:#888">// Prints 21, returns 1
</span></code></pre></div></section><section>
<h1 id="extra-content">Extra content</h1>
<p>A lot of language details have been left out of this guide, non complete list:</p>
<ul>
<li>arrays</li>
<li>enum classes</li>
<li>spread operator</li>
<li>annotations</li>
<li><code>noinline</code> and <code>crossinline</code></li>
<li>coroutines</li>
<li>interoperatibility with Java</li>
<li><code>inline class</code>es</li>
</ul>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/Course-Laboratory-of-Software-Systems/reveal-hugo/object-assign.js></script>

<a href="/Course-Laboratory-of-Software-Systems/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"height":"100%","pdfseparatefragments":false,"theme":"white","width":"100%"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"custom_theme":"custom-theme.scss","custom_theme_compile":true,"custom_theme_options":{"enablesourcemap":true,"targetpath":"css/custom-theme.css"},"transition":"slide","transition_speed":"fast"}</script>

<script src="/Course-Laboratory-of-Software-Systems/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/Course-Laboratory-of-Software-Systems/reveal-js/plugin/notes/notes.js"></script>



    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>

<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

    
  </body>
</html>
